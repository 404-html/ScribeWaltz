1
00:00:00,150 --> 00:00:01,590
Hello world,
it's Saroj.

2
00:00:01,650 --> 00:00:06,360
And today we're going to build a genetic
algorithm for the game space invaders.

3
00:00:06,540 --> 00:00:10,830
Well, it's actually not space invaders
is called Citius invaders invaders,

4
00:00:10,980 --> 00:00:13,980
but it's our, it's very similar.
It's based off of space invaders.

5
00:00:14,160 --> 00:00:16,830
So I'm going to start off with a
demo of what we're going to build.

6
00:00:17,040 --> 00:00:20,550
There's a javascript version of this
and there's a python version of this.

7
00:00:20,580 --> 00:00:23,970
And of course we're going to do the
python version because that's what we do.

8
00:00:23,971 --> 00:00:28,830
Python, of course. So let's, let's look
at this game first. Ready, set, go.

9
00:00:28,831 --> 00:00:31,240
Okay. So we are this dude
at the bottom. You've,

10
00:00:31,260 --> 00:00:32,820
you've played space invaders before.

11
00:00:32,821 --> 00:00:34,650
I don't need to tell you
how space invaders works,

12
00:00:34,830 --> 00:00:39,830
but this is a special version because
what happens is these invaders will,

13
00:00:40,700 --> 00:00:41,130
uh,

14
00:00:41,130 --> 00:00:46,130
breed or crossover every five seconds
they're going to breed every five seconds

15
00:00:46,351 --> 00:00:50,070
in my job, I'll hit the space
bar is to kill them all,

16
00:00:50,610 --> 00:00:54,630
all the time. All of them that are going
to keep on breeding over and over again.

17
00:00:54,930 --> 00:00:57,840
And I've got to get
them to be obliterated,

18
00:00:58,110 --> 00:00:59,490
but they're just going
to keep on breeding.

19
00:00:59,970 --> 00:01:02,640
And what they're going to do is
they're learning from my behavior.

20
00:01:02,810 --> 00:01:05,160
They're not just breeding
for the sake of breeding.

21
00:01:05,430 --> 00:01:09,480
They are learning from my behavior
and they're getting better over time.

22
00:01:09,510 --> 00:01:11,130
There's a learning process happening here,

23
00:01:11,850 --> 00:01:15,120
but it's not gradient based optimization,
which is what we're used to.

24
00:01:15,300 --> 00:01:17,100
And it's not reinforcement learning base,

25
00:01:17,101 --> 00:01:19,740
which I talked about last
week with the deep learner.

26
00:01:19,860 --> 00:01:21,390
This is a whole different paradigm.

27
00:01:21,570 --> 00:01:26,370
It's called genetic algorithms
and sometimes it's called
evolutionary algorithms

28
00:01:26,371 --> 00:01:29,430
as well. But now there's, there's
a, there's a million of them anyway.

29
00:01:29,640 --> 00:01:32,160
So that's what the game is going to
look like. This is in the browser.

30
00:01:32,161 --> 00:01:35,850
We can also compile it from our desktop.
But that's the basic idea. Oh my God,

31
00:01:35,851 --> 00:01:39,870
there's so many of them. They are
breeding like ray invaders. Okay.

32
00:01:39,900 --> 00:01:44,400
So that's what we're going to do.
And so what our algorithm does,

33
00:01:44,430 --> 00:01:46,590
very simple.
It's a very simple algorithm,

34
00:01:46,710 --> 00:01:50,550
but the concept itself is very cool.
Uh,

35
00:01:50,551 --> 00:01:53,790
is it starts off with four invaders.
So the game doesn't,

36
00:01:53,820 --> 00:01:57,060
can never have less than four invaders
for is the minimum. So there's no,

37
00:01:57,210 --> 00:02:00,180
there's no winning the game.
Just, you know, whatever,

38
00:02:00,420 --> 00:02:03,930
but you can't have more than a hundred
invaders so that the interval is between

39
00:02:03,931 --> 00:02:07,770
four and 100 if there are a
hundred invaders on the screen,

40
00:02:07,800 --> 00:02:09,760
we lose it's game over.
But if there,

41
00:02:09,780 --> 00:02:13,500
what we try to keep them as close to
four as possible by shooting them.

42
00:02:14,130 --> 00:02:17,820
And so each invader has
for what are called genes,

43
00:02:17,821 --> 00:02:21,960
you can think of them as attributes
as well. Speed, how fast it's moving,

44
00:02:22,170 --> 00:02:25,110
the probability that it's
going to change direction,

45
00:02:25,630 --> 00:02:30,390
which is between zero and one as all
probabilities are the size of the invader.

46
00:02:30,420 --> 00:02:30,991
It could be big,

47
00:02:30,991 --> 00:02:34,590
it could be small there variational
there's all sorts of sizes and the color,

48
00:02:34,620 --> 00:02:37,890
which is kind of negligible really. But
uh, we'll, we'll update that as well.

49
00:02:37,891 --> 00:02:42,840
It's a hex value and so it
has four attributes or genes
as we call them in this

50
00:02:42,841 --> 00:02:43,674
paradigm.

51
00:02:43,770 --> 00:02:48,770
And every five seconds they
mate or crossover and it
produces children like new

52
00:02:49,891 --> 00:02:53,910
invaders that are supposed to be better
than then it's parent than their parents.

53
00:02:55,140 --> 00:02:58,830
And the invaders were the highest fitness
by some measure of fitness that we,

54
00:02:59,210 --> 00:03:02,560
we're going to define what fitness
means. It's like a, you know,

55
00:03:03,310 --> 00:03:08,310
our measuring contest and by some measure
of fitness we're going to determine

56
00:03:08,710 --> 00:03:12,790
who gets to breed and who doesn't.
It's a very Darwinian process.

57
00:03:13,120 --> 00:03:17,200
So that's what it is. And the
invaders that learned the best or or,

58
00:03:17,260 --> 00:03:21,640
or who have the best set of genes are
going to be the ones who get to crossover

59
00:03:22,240 --> 00:03:25,840
or breathe. So this is
uh, this is this image.

60
00:03:25,870 --> 00:03:27,490
All of genetic algorithms,

61
00:03:27,491 --> 00:03:31,000
all of genetic algorithms can
be summed up in this image.

62
00:03:31,001 --> 00:03:32,320
But before I get to this image,

63
00:03:32,410 --> 00:03:35,650
let me look down here a little bit
and give it a little bit of background

64
00:03:35,740 --> 00:03:39,910
because I never talk about
biology, but it's dope. So
let me talk about it. So Dna,

65
00:03:39,911 --> 00:03:43,450
we all know what DNA is, right?
It's the blueprint of life. All,

66
00:03:43,451 --> 00:03:47,320
all humans share 99.9% of the same DNA.

67
00:03:47,500 --> 00:03:51,940
It's that 0.1% difference
that results in our,

68
00:03:51,941 --> 00:03:56,550
the way we are different. The results
in Charlottesville and Oh, anyway, to,

69
00:03:56,610 --> 00:04:00,610
you know, I got to stay relevant here,
you know, trending terms anyway, uh,

70
00:04:01,210 --> 00:04:05,620
but DNA is the blueprint of life
from Dna Springs, everything else.

71
00:04:05,800 --> 00:04:10,450
And so genes are the recipes.
So you can think of DNA as the cookbook.

72
00:04:10,480 --> 00:04:14,500
It's the book of all the recipes.
And the recipes are the genes, right?

73
00:04:14,590 --> 00:04:17,760
You have a gene for your hair color,
you have a gene for your eye color,

74
00:04:17,770 --> 00:04:19,120
your gene for everything,
right?

75
00:04:19,420 --> 00:04:24,370
And so DNA consists of genes and from
these genes that make up the DNA strand

76
00:04:24,520 --> 00:04:29,520
come proteins and proteins make up the
physical attributes that make up who you

77
00:04:29,561 --> 00:04:34,240
are. So, uh, right? So that's the,
that's DNA. And those are genes.

78
00:04:34,241 --> 00:04:38,170
And so we could think of these genes
as parameters for each individual.

79
00:04:38,171 --> 00:04:39,790
So each individual is like,

80
00:04:40,000 --> 00:04:44,830
has a set of genes or parameters that
adapt over time based on how they breed.

81
00:04:45,970 --> 00:04:49,600
And so all life on earth has sprung
up this way through Darwinian natural

82
00:04:49,601 --> 00:04:53,660
selection. The idea is that
usually species will overpopulate,

83
00:04:54,070 --> 00:04:57,070
they'll create more than
necessary to survive.

84
00:04:57,250 --> 00:05:00,440
And then there's going to be variation
amongst all the individuals of the

85
00:05:00,441 --> 00:05:03,590
species. This, this guy's
skin color will be ground.

86
00:05:03,600 --> 00:05:05,980
It's kind of skin color would be why
this guy's going to call the way black,

87
00:05:06,220 --> 00:05:09,520
all sorts of different people.
And then what happens is selection.

88
00:05:09,521 --> 00:05:12,790
So everybody's going to try to reproduce.
I mean that's the point of life.

89
00:05:12,791 --> 00:05:16,570
If you think about it at the,
at the low level or at the basic level,

90
00:05:16,870 --> 00:05:18,370
I mean there,
there are other points of life.

91
00:05:18,371 --> 00:05:22,090
Like it doesn't just have to be about sex,
it's going to be about social impact.

92
00:05:22,240 --> 00:05:25,630
You make your own meaning in the end.
But I digress anyways,

93
00:05:25,660 --> 00:05:29,110
everybody tries to breed,
but the ones that uh,

94
00:05:29,140 --> 00:05:34,140
whose children are the most fit are the
ones who get to survive or the ones who

95
00:05:34,241 --> 00:05:36,310
are most likely to survive.

96
00:05:36,550 --> 00:05:39,920
And the way that nature
does this is it lets it, it,

97
00:05:39,970 --> 00:05:44,970
it finds those that are most fit by some
measure of fitness and the real world.

98
00:05:45,270 --> 00:05:47,770
It would be brute
physical strength and it,

99
00:05:47,800 --> 00:05:51,730
those genes are then more
likely to be passed on to next,

100
00:05:51,910 --> 00:05:55,480
the next generations.
And so that's adoption.

101
00:05:56,470 --> 00:06:01,470
So like the idea behind which now go
back to this genetic algorithms are based

102
00:06:01,761 --> 00:06:05,690
off of, so we initialize, so the
first step is initialization.

103
00:06:05,750 --> 00:06:09,020
So we'll create a population
whether that's space invaders,

104
00:06:09,110 --> 00:06:10,580
whether that's different solutions,

105
00:06:10,581 --> 00:06:14,720
possible solutions to some train
route optimization problem,

106
00:06:14,721 --> 00:06:18,290
like different routes and then
those routes evolve. But anyway,

107
00:06:18,320 --> 00:06:23,180
we initialize some population of of of
solutions possible solutions and then we

108
00:06:23,181 --> 00:06:28,181
assign each of those individuals a fitness
value by some fitness function that

109
00:06:28,191 --> 00:06:31,730
we decide what it's,
it's very problem specific as well.

110
00:06:31,790 --> 00:06:34,400
Like based on the problem,
what is the,

111
00:06:34,460 --> 00:06:39,320
how fit is this individual or
solution you can call it as well.

112
00:06:39,530 --> 00:06:44,480
And then we select those individuals
that are the fittest and then by some

113
00:06:44,600 --> 00:06:49,340
measure of you know,
what that fitness is and the easy case,

114
00:06:49,341 --> 00:06:53,330
we can just think about it. Fitness as
outputting just a single scalar value,

115
00:06:53,510 --> 00:06:56,240
right? For each person. And
then we just choose those

116
00:06:57,860 --> 00:07:01,460
individuals that had the highest fitness
level and that highest fitness level

117
00:07:01,480 --> 00:07:05,150
could be, you know, it has to be greater
than 10 or else they don't get to breed.

118
00:07:05,420 --> 00:07:07,580
And then we choose all those.
That's just selection process.

119
00:07:07,850 --> 00:07:11,900
And then there's crossover or mating or
sex if you want, you know, whatever it is.

120
00:07:12,200 --> 00:07:14,690
And uh,
right.

121
00:07:14,810 --> 00:07:19,280
So they reproduce these jeans.
Why am I laughing?

122
00:07:19,640 --> 00:07:24,500
Cause I said sex. I know. Oh my God,
my uh, so these genes reproduce.

123
00:07:24,530 --> 00:07:27,590
That's the whole point, right? That's
how you came out. That's how I came out.

124
00:07:28,310 --> 00:07:32,900
Oh okay. So then they crossover and then
the fittest ones, those are the children.

125
00:07:33,110 --> 00:07:37,040
We then the last step is mutation.
We take those children and we add some,

126
00:07:37,400 --> 00:07:41,150
we add some kind of mutation to them
so we can multiply them by some random

127
00:07:41,151 --> 00:07:45,820
distribution, like a golf, Sian or
you know, whatever else. And that's,

128
00:07:45,830 --> 00:07:49,490
that's how that works. So
let me go back to this. Okay.

129
00:07:49,790 --> 00:07:53,300
So then we mutate them. And so the
reason we mutate them, so there,

130
00:07:53,330 --> 00:07:54,620
there is some variation.

131
00:07:54,621 --> 00:07:59,420
Right now it doesn't necessarily mean
that the genes that are passed on are the

132
00:07:59,450 --> 00:08:01,820
optimal gene values.
Like they could be better,

133
00:08:01,970 --> 00:08:05,450
but we know that they are the best of
the type of genes that we've been given.

134
00:08:05,600 --> 00:08:08,960
So we could take those best of what
we've been given and if we mutate them,

135
00:08:09,110 --> 00:08:13,340
we opened up the possibilities of
there being better genes out there that

136
00:08:13,341 --> 00:08:15,440
weren't even from the parents.
Right. And you see what I'm saying?

137
00:08:15,530 --> 00:08:17,090
So that's why we vary them a little bit.

138
00:08:17,091 --> 00:08:20,480
We had some kind of variational
probabilistic aspect.

139
00:08:20,540 --> 00:08:23,420
I'm doing this because I'm talking, I'm
thinking about distributions, right?

140
00:08:23,960 --> 00:08:27,090
And also in terms of crossover,
uh,

141
00:08:27,170 --> 00:08:29,180
there are different ways
of crossing over parents.

142
00:08:29,330 --> 00:08:32,870
You could add these to scalar values
together. You could multiply them,

143
00:08:32,930 --> 00:08:35,300
you could multiply divide by two
and then square it. You know,

144
00:08:35,390 --> 00:08:37,550
it depends on what you
define by crossing over.

145
00:08:37,790 --> 00:08:42,260
And once we meet some stopping criteria,
uh, then we, we, we end the game.

146
00:08:42,261 --> 00:08:43,400
Like let's say,
you know,

147
00:08:43,401 --> 00:08:46,580
we want the solution to be x amount
so it will measure how good it is.

148
00:08:46,700 --> 00:08:49,430
And so in our case, that's going
to be having a hundred invaders.

149
00:08:49,431 --> 00:08:51,800
That's the stopping criteria.
But if we haven't met it,

150
00:08:51,801 --> 00:08:55,620
then we just repeat this process over
and over and over again. All right,

151
00:08:55,621 --> 00:09:00,390
so that's that. And, uh, now we're going
to talk about the use cases. So, okay.

152
00:09:00,391 --> 00:09:04,170
So most of the advances in machine
learning have been due to gradient based

153
00:09:04,171 --> 00:09:07,500
optimization. As long as we can
compute some gradient value,

154
00:09:07,740 --> 00:09:11,640
we can compute how best to update
the weights of our network,

155
00:09:11,641 --> 00:09:13,440
the parameters of our network,
right?

156
00:09:13,650 --> 00:09:16,860
Whether that's through supervised or
unsupervised learning, clustering,

157
00:09:17,640 --> 00:09:21,540
classification generation, you
know, variational auto encoding,

158
00:09:21,840 --> 00:09:25,800
all of these things are based off of
having a gradient value that we can then

159
00:09:25,830 --> 00:09:29,970
update our, our weights with. But in
this case there's no gradient value.

160
00:09:30,240 --> 00:09:31,770
This is a totally different paradigm.

161
00:09:32,800 --> 00:09:35,760
There is no linear Algebra and
there's no calculus involved.

162
00:09:35,880 --> 00:09:37,260
There is just Algebra,

163
00:09:37,560 --> 00:09:40,710
like performing the crossover
and then performing the mutation.

164
00:09:40,711 --> 00:09:43,110
It's like multiplication,
addition, subtraction,

165
00:09:43,170 --> 00:09:45,570
basic operations and then probability.

166
00:09:45,571 --> 00:09:48,510
And the probability is the mutation
as well. Like you know, it's,

167
00:09:48,511 --> 00:09:53,010
there's a probabilistic aspect to who
gets to reproduce and what those mutations

168
00:09:53,011 --> 00:09:55,800
look like.
So there's only probability and Algebra.

169
00:09:55,801 --> 00:09:58,500
Whereas in gradient based optimization,

170
00:09:58,501 --> 00:10:01,140
where most of the advances in
machine learning have occurred,

171
00:10:01,380 --> 00:10:05,310
there's calculus and linear Algebra
and probability theory and statistics.

172
00:10:05,640 --> 00:10:08,490
So it's an easier way
of thinking about it.

173
00:10:08,640 --> 00:10:10,770
And it's not necessarily as a,

174
00:10:10,780 --> 00:10:14,400
it's not necessarily as efficient
when it comes to certain use cases,

175
00:10:14,520 --> 00:10:18,870
but these genetic algorithms are
used in real world applications.

176
00:10:19,200 --> 00:10:23,670
One of them, one example is for relational
databases like posts gray or h two,

177
00:10:23,850 --> 00:10:25,960
they select the best query plan by the,

178
00:10:26,100 --> 00:10:28,830
which is the one with the
lowest estimated cost.

179
00:10:29,340 --> 00:10:32,750
They're using finance a lot
for stock price prediction, um,

180
00:10:33,030 --> 00:10:35,790
for portfolio optimization,
evolving design.

181
00:10:35,791 --> 00:10:40,791
So computer aided design is
a great example where you
have some idea of what the

182
00:10:41,341 --> 00:10:44,160
solution should be.
You don't know exactly what it is,

183
00:10:44,370 --> 00:10:47,940
but you have some kind of base design,
whether that'd be a cad model,

184
00:10:47,941 --> 00:10:52,941
like a three d cad model or a set of
rules to conduct some kind of experiments.

185
00:10:55,710 --> 00:10:59,970
And you can evolve these roles over time,
uh, so that they get better and better.

186
00:11:00,270 --> 00:11:04,500
And so this is used in evolving
cad models in engineering,

187
00:11:04,830 --> 00:11:07,200
wind turbines and things like that.
Things that you would design,

188
00:11:07,410 --> 00:11:10,920
which is a really cool field and it's
very closely related to generative

189
00:11:10,921 --> 00:11:13,800
generative modeling, uh, from
grain based optimization.

190
00:11:13,950 --> 00:11:17,160
Like generative adversarial networks
and variational auto encoders where you

191
00:11:17,340 --> 00:11:19,500
generate new data.
It's kind of similar to that.

192
00:11:19,501 --> 00:11:22,020
It's in the same kind of
subfield computer aided design.

193
00:11:22,530 --> 00:11:26,100
So those are two use cases, although
right, you don't, you don't see these,

194
00:11:26,160 --> 00:11:30,200
you don't see like the top researchers
at deep mind or open AI or you know,

195
00:11:30,210 --> 00:11:34,290
anywhere posting, uh, papers
on genetic algorithms.

196
00:11:34,291 --> 00:11:37,260
It just doesn't happen. Uh,
but I still believe in them.

197
00:11:37,290 --> 00:11:40,050
I still believe in them
and when to use this,

198
00:11:40,200 --> 00:11:43,410
if you have a huge search space and
you're not really sure what the ideal

199
00:11:43,411 --> 00:11:46,920
solution should be, like computer
aided design, it's a very creative,

200
00:11:47,040 --> 00:11:51,340
open ended solution, then
that would be a good, um, uh,

201
00:11:51,390 --> 00:11:53,470
this would be a good
solution to that problem.

202
00:11:54,070 --> 00:11:57,730
And so whenever you have
a multidimensional search
space is just a huge search

203
00:11:57,731 --> 00:12:00,670
space and you don't even
know what the deal is. Okay?

204
00:12:00,671 --> 00:12:04,840
So that's the high level of
what genetic algorithms are.

205
00:12:05,140 --> 00:12:08,830
Now what I'm gonna do is I'm going
to go over the code for this game.

206
00:12:08,950 --> 00:12:11,170
It's very doable and it's
all going to be in python.

207
00:12:11,500 --> 00:12:15,400
The only parts that I'm going to code
are the three main parts and the three

208
00:12:15,401 --> 00:12:19,600
main parts are selection,
crossover, and mutation.

209
00:12:19,660 --> 00:12:21,100
So those are the parts I'm going to code.

210
00:12:21,280 --> 00:12:24,550
The rest of it we're going to go and
just glaze over it and I'm going to talk

211
00:12:24,551 --> 00:12:29,020
about what's happening there.
So there are four different classes here.

212
00:12:29,021 --> 00:12:31,990
There are four different classes and
we're going to start at the highest level

213
00:12:31,991 --> 00:12:36,190
class, which is just this right here,
this 30 lines of code, the main code,

214
00:12:36,370 --> 00:12:40,370
and then we're going to eight her of like
go down the hierarchy of functions to

215
00:12:40,371 --> 00:12:42,920
we get to the lowest level,
which is evolution would that,

216
00:12:42,930 --> 00:12:45,190
that is where the real
evolutionary code is happening.

217
00:12:45,340 --> 00:12:47,110
And that's where I'm going to
code some parts. All right,

218
00:12:47,260 --> 00:12:48,430
so let's start at the high level.

219
00:12:48,640 --> 00:12:51,010
So we have four dependencies here that
we're going to importantly make this

220
00:12:51,011 --> 00:12:54,910
really big for us so we can
really see what's going on here.

221
00:12:55,710 --> 00:12:58,120
All right,
make it bigger.

222
00:12:58,390 --> 00:13:02,800
Bigger is better as they
say in, as I say. Okay?

223
00:13:02,830 --> 00:13:06,940
So for for dependencies,
SGE is a wrapper around pie game.

224
00:13:07,000 --> 00:13:12,000
Now Pie game is the most popular game
building library in Python and SGE you

225
00:13:13,860 --> 00:13:17,140
pronounce it sage is a
wrapper over pie game,

226
00:13:17,170 --> 00:13:20,950
which makes it even easier to use.
However, like with all rappers,

227
00:13:20,980 --> 00:13:22,750
because there's a layer of abstraction,

228
00:13:22,810 --> 00:13:26,210
the trade off is you don't get as
much control over the details. Um,

229
00:13:26,350 --> 00:13:28,880
but we're not going to talk about,
you know, the details we were,

230
00:13:28,881 --> 00:13:33,250
we're building a very simple game.
And so SGG SGE is essentially pie game,

231
00:13:33,251 --> 00:13:37,840
but wrapped to a higher level game is
our objects that's going to contain the

232
00:13:37,841 --> 00:13:40,270
game logic.
Objects are,

233
00:13:40,360 --> 00:13:44,950
are the player and the invader
class that will define as well.

234
00:13:45,160 --> 00:13:48,640
And [inaudible] is just for, you know,
operating system functionality, right?

235
00:13:48,641 --> 00:13:51,100
So in our main function,
here's the highest level of the code.

236
00:13:51,370 --> 00:13:54,910
So first we're going to define where the
file is and then we'll create the game

237
00:13:54,911 --> 00:13:58,030
object. So when we, when we
initialize invaders game,

238
00:13:58,180 --> 00:14:01,560
that's just going to set some basic
parameters like the clock time, uh,

239
00:14:01,750 --> 00:14:02,980
whether or not there's a game over,

240
00:14:02,981 --> 00:14:06,610
which there's not going to be when we
start off de and some other things.

241
00:14:06,611 --> 00:14:08,710
But these are just games
specific parameters,

242
00:14:08,860 --> 00:14:13,090
not player or invaders specific
parameters. Those are objects. All right,

243
00:14:13,091 --> 00:14:17,050
so then we'll initialize the game and then
we're going to load up the background.

244
00:14:17,051 --> 00:14:20,950
And by the background I mean the color
of the, the back of the game, right?

245
00:14:20,951 --> 00:14:23,980
Let me just show it over here. So the
color of the back of the game, I'll,

246
00:14:23,981 --> 00:14:26,260
I'll keep going back to this by the way.
Right?

247
00:14:26,261 --> 00:14:28,990
So we want a black screen and
so that's what we're doing here.

248
00:14:29,170 --> 00:14:32,380
We're defining a black screen.
We have a wall height,

249
00:14:32,650 --> 00:14:37,480
we have a resolution and we call it wall
sprite. A sprite is like a a figure,

250
00:14:37,481 --> 00:14:38,470
right?
And animation.

251
00:14:38,471 --> 00:14:42,010
But the way we're just going to call
the background a wall sprites as well,

252
00:14:42,250 --> 00:14:46,030
and we'll set it as a background
layer and we only have one layer.

253
00:14:46,031 --> 00:14:48,700
So it's just setting the
background layer to that wall.

254
00:14:48,701 --> 00:14:51,530
Sprites as a rectangle that we draw.
Once we have that,

255
00:14:51,531 --> 00:14:52,610
we'll add it to the background.

256
00:14:52,611 --> 00:14:55,580
So we take our background layer that
we've initialized and add it to the

257
00:14:55,581 --> 00:14:59,390
background. And so that now we
have a black box for games so far,

258
00:14:59,750 --> 00:15:03,230
and now we have a background.
Now we'll initialize our objects.

259
00:15:03,350 --> 00:15:07,590
We have a set of invaders, so we'll start
off with six of them. So we say let's,

260
00:15:07,760 --> 00:15:12,060
let's create and initialize an invader
six times and we'll store them all in

261
00:15:12,061 --> 00:15:14,210
this invaders, uh, array or list.

262
00:15:14,600 --> 00:15:17,480
And then we have our player
with just one that's us.

263
00:15:17,840 --> 00:15:20,300
And then we say the player
is always the first objects.

264
00:15:20,301 --> 00:15:23,510
We take both of them and we add them to
this object or ray with the player being

265
00:15:23,511 --> 00:15:26,510
first. So it's an we're initialized
before the invaders are.

266
00:15:27,130 --> 00:15:29,870
And then we start the game.
Well we don't start the game,

267
00:15:29,871 --> 00:15:31,910
we initialize a session of the game.

268
00:15:32,110 --> 00:15:35,990
And so this is kind of like the pie
game specific syntax of like, you know,

269
00:15:35,991 --> 00:15:37,100
syntactic sugar,

270
00:15:37,760 --> 00:15:40,610
it's like intentional level where you
initialize a session and then you run the

271
00:15:40,611 --> 00:15:41,480
computation graph.

272
00:15:41,780 --> 00:15:44,330
So we initialize this session
here with the game room function,

273
00:15:44,510 --> 00:15:46,310
giving it the background that we defined.

274
00:15:46,430 --> 00:15:49,040
And the objects are
player in the invaders.

275
00:15:49,430 --> 00:15:51,710
And then we were moved the mouse because
we don't want to see any of that.

276
00:15:51,711 --> 00:15:54,350
We have, we're focused on are invaders
in our player. That's it. Right?

277
00:15:54,680 --> 00:15:57,830
And then here we go. We start the game.
Why would we initialize this session?

278
00:15:58,190 --> 00:16:01,520
And then we start the game. And that's it
at a high level, right? Very easy stuff.

279
00:16:01,521 --> 00:16:05,900
No, no evolutionary anything.
Know anything really too
easy, almost. Right? I know.

280
00:16:05,901 --> 00:16:10,010
It's too easy for you. You
smart, you smart person.

281
00:16:10,011 --> 00:16:14,960
You all right? So all right.
Anyway, where were we? Uh, right.

282
00:16:14,961 --> 00:16:17,900
So now we're going down a level of
hierarchy. We're going down one,

283
00:16:18,050 --> 00:16:22,500
we're going to objects. So for objects,
we define our invaders, right? So we,

284
00:16:22,530 --> 00:16:25,130
we define our game and
we define our classes.

285
00:16:25,131 --> 00:16:28,040
So now let's define those objects,
those,

286
00:16:28,041 --> 00:16:30,170
those entities inside of the game.

287
00:16:30,350 --> 00:16:32,500
So our first entity is
going to be our invader.

288
00:16:32,530 --> 00:16:37,190
Now how are invader is the one that
is the individual that will breed and

289
00:16:37,191 --> 00:16:39,530
crossover. You know, all
this, you know, mutation.

290
00:16:39,710 --> 00:16:44,210
All of this evolutionary logic will be
applied to this invader. So let's, let's,

291
00:16:44,211 --> 00:16:47,810
let's define what this invader,
uh, what the attributes are.

292
00:16:48,020 --> 00:16:51,560
So our first step is going
to be to define the genes,

293
00:16:51,830 --> 00:16:54,950
the genes for the invader. So when I
say attributes, this is what I mean.

294
00:16:55,310 --> 00:16:56,810
The first one is going to be size.

295
00:16:56,811 --> 00:17:00,470
And so these are key value pairs
stored in a dictionary, okay?

296
00:17:00,710 --> 00:17:03,980
These are key value pairs.
So for each of these genes,

297
00:17:04,250 --> 00:17:07,220
we are going to store a minimum
value and a maximum value.

298
00:17:07,520 --> 00:17:10,490
And we're going to have some
generated a random number here.

299
00:17:10,610 --> 00:17:12,440
So we're going to be able to say,

300
00:17:12,530 --> 00:17:16,700
let's generate a value for
this individual, for this gene.

301
00:17:16,940 --> 00:17:19,190
And it's gotta be between
the Min and the Max.

302
00:17:19,370 --> 00:17:21,440
And if it's smaller than the men
or it's greater than the Max,

303
00:17:21,500 --> 00:17:23,990
then we're just returned the
men or the Max respectfully.

304
00:17:24,110 --> 00:17:28,130
But you can't generate the value for this
gene for any individual that's beyond

305
00:17:28,131 --> 00:17:32,360
the scope of this min and
Max value, right? So we'll
do that for the size of them,

306
00:17:32,390 --> 00:17:36,110
right? So it's, the size has to be
between one and seven the color, right?

307
00:17:36,111 --> 00:17:40,190
We have colors on a scale of zero to
two 55 but our main is going to be five.

308
00:17:40,940 --> 00:17:45,940
Our speed between 0.01 and five are
why velocity or x and y velocity,

309
00:17:47,151 --> 00:17:49,950
our speeds in both directions,
axes,

310
00:17:50,670 --> 00:17:54,420
and then our probability of changing
directions in both the x direction,

311
00:17:54,960 --> 00:17:59,160
x direction and the y direction
up and down, up and down,

312
00:17:59,190 --> 00:18:03,360
up and down wavy hair. I got my hair
dyed silver again. Yes. Oh my God,

313
00:18:03,990 --> 00:18:08,400
it was so long. I'm so happy to have this
silver again, back to this, back to this,

314
00:18:08,520 --> 00:18:09,720
back to this.
Okay.

315
00:18:09,721 --> 00:18:12,990
So we have those genes and now
let's look at this next function,

316
00:18:13,170 --> 00:18:15,630
which is to generate some
jeans for an invader.

317
00:18:15,631 --> 00:18:17,730
So whenever we initialize an invader,

318
00:18:17,880 --> 00:18:22,680
this generate gene function is called
right here as it set of attributes when we

319
00:18:22,681 --> 00:18:25,170
initialize it. So let's look
at what this code looks like.

320
00:18:25,410 --> 00:18:29,630
We're going to use that generated number
like we define over here to define, uh,

321
00:18:29,820 --> 00:18:32,820
what this is going to be like.
Write a value for the specific gene.

322
00:18:33,030 --> 00:18:35,670
So we know what the Max value
is and what the min value is,

323
00:18:35,850 --> 00:18:38,270
and at the generated number is
less than the men returned them in.

324
00:18:38,280 --> 00:18:42,240
If it's greater than the Max returned
the Max else return the generated number.

325
00:18:42,390 --> 00:18:43,223
And so that's how we,

326
00:18:43,230 --> 00:18:46,380
that's how we generate genes for each
individual in this function, right?

327
00:18:46,381 --> 00:18:50,640
So when we, when we, when we initialize
an invader like we did over here,

328
00:18:50,670 --> 00:18:54,210
we said let's initialize six of them.
When we initialized an invader,

329
00:18:54,300 --> 00:18:57,240
this is the logic that's being
called, right? So first of all,

330
00:18:57,241 --> 00:19:01,230
we'll generate some random values for its
genes and store them in the attributes.

331
00:19:01,800 --> 00:19:05,040
And then we'll set the generator genes
for this invader. In terms of genes,

332
00:19:05,041 --> 00:19:08,520
that's just, you know, jeans
are the attributes. Same thing.

333
00:19:09,360 --> 00:19:13,170
And then we'll set it sprite
animation, which is that like, uh,

334
00:19:13,860 --> 00:19:18,090
now robot looking dude, that was,
what was it? This, this thing, right?

335
00:19:18,420 --> 00:19:19,320
It's not game over.

336
00:19:19,470 --> 00:19:23,490
The game isn't over till I say it's
over or til we say it's over. Okay.

337
00:19:23,610 --> 00:19:28,140
Press enter. Ready. Steady go.
He, come on, come on. Jean.

338
00:19:28,230 --> 00:19:32,160
There we go. Such a fun game, right?
So his, his little sprite animation,

339
00:19:32,161 --> 00:19:35,810
this like little character thing here
and it's just a, it's just a PNG.

340
00:19:35,840 --> 00:19:39,190
It's just an image, a static image
that we're setting here using the,

341
00:19:39,191 --> 00:19:43,540
the beauty of SGE that just lets us,
you know, magically set these, uh,

342
00:19:43,860 --> 00:19:46,140
sprites for an object that we declare.

343
00:19:46,680 --> 00:19:48,450
And then we're going to pull
these values from the gene.

344
00:19:48,451 --> 00:19:51,780
So we have these generated values and
they're all stored in this genes list,

345
00:19:52,020 --> 00:19:56,640
but we'll also have individual, uh,
variables for each of these gene values.

346
00:19:56,641 --> 00:20:01,110
Just cause it's easier to call
later to get to pull later on.

347
00:20:01,740 --> 00:20:05,130
And we'll set the width for the image
and the, and the height, the scale,

348
00:20:05,131 --> 00:20:07,830
and it's going to start off with zero.
In terms of his fitness score,

349
00:20:07,831 --> 00:20:11,610
we don't know how fit it is yet
because it was just initialized.

350
00:20:11,670 --> 00:20:16,110
So we'll initialize that value as zero,
zero to hero Hercules.

351
00:20:16,530 --> 00:20:21,210
That I would just saying that I try to
keep it interesting anyway. Uh, right.

352
00:20:21,211 --> 00:20:24,350
So we have those values and
now, okay, so here's, here's,

353
00:20:24,480 --> 00:20:27,570
here's something really cool. So notice
this function right here. Events step.

354
00:20:27,571 --> 00:20:30,840
You're like, okay, events
step, great. What this,

355
00:20:30,870 --> 00:20:35,670
what this does is it uh, in
one. So there are events, right?

356
00:20:35,671 --> 00:20:39,890
So every step or time step in the game,
there's a series of time step, you know,

357
00:20:39,900 --> 00:20:42,420
every interval. Like does it
[inaudible] it was always time,

358
00:20:42,421 --> 00:20:46,500
steps in machine learning and so at
every time step do something, right?

359
00:20:46,501 --> 00:20:50,050
So what is that that uh,
this invader is going to do?

360
00:20:50,170 --> 00:20:54,910
What it's going to do is it's going to
increase its fitness score by one because

361
00:20:54,940 --> 00:20:58,540
the longer it's alive, the more fit
it is. That's what we're saying.

362
00:20:58,570 --> 00:21:01,260
That's what our fitness chorus,
there's more to the fitness score, um,

363
00:21:01,480 --> 00:21:03,850
that I'll talk about in a second.
But that's the kind of the basic idea.

364
00:21:03,940 --> 00:21:08,200
But because this, this, this, this
invader has survived a single time step.

365
00:21:08,350 --> 00:21:10,570
We're going to increase
that fitness score by one.

366
00:21:10,930 --> 00:21:13,630
And so then we changed directions
randomly. So we'll still,

367
00:21:13,660 --> 00:21:17,380
we'll initialize some random value and
say if it's less than the probability of

368
00:21:17,381 --> 00:21:21,220
changing directions than change
the direction else, you know, for,

369
00:21:21,221 --> 00:21:25,990
for both x and y, then we have logic
for bouncing off the edges and the wall,

370
00:21:25,991 --> 00:21:29,110
all four sides up, down,
left and right. Okay.

371
00:21:29,111 --> 00:21:31,690
So that's all it does
is it computes movement.

372
00:21:31,810 --> 00:21:34,510
Like where should this invader
move in this time step.

373
00:21:34,690 --> 00:21:37,630
And so that's how the invader is just
moving randomly all over the place.

374
00:21:37,780 --> 00:21:42,760
But it's not just moving randomly, it's
moving randomly, but based on the genes,

375
00:21:42,761 --> 00:21:44,440
like what these values of these genes are.

376
00:21:44,590 --> 00:21:48,190
So you see how it's movement is
dependent on the jeans, right?

377
00:21:48,400 --> 00:21:52,090
One gene would be x probability one
gene would be the why probability,

378
00:21:52,370 --> 00:21:56,740
The v x velocity, the Wiva
la city. Okay. So, okay,

379
00:21:56,741 --> 00:21:59,620
so here's the interesting thing. So you're
looking at this and you're like, okay,

380
00:21:59,680 --> 00:22:02,590
so this happens at every time step.
When is this function called?

381
00:22:02,710 --> 00:22:05,170
So you'll look at this, you'll
copy it, you'll control app,

382
00:22:05,171 --> 00:22:07,810
you'll try to find where it's, where
it's called. Well, this is just the,

383
00:22:07,870 --> 00:22:09,970
this is just a duplicate of it.
This is not called there.

384
00:22:10,240 --> 00:22:14,410
This is another duplicate. Where's
this thing called? So the thing is,

385
00:22:14,411 --> 00:22:17,500
it's not called anywhere. There
are event listeners. So that's,

386
00:22:17,530 --> 00:22:20,500
that's another thing about
a SGE or sage with pie game.

387
00:22:20,860 --> 00:22:23,860
You have event listeners
because if we were to call this,

388
00:22:23,920 --> 00:22:25,720
we would just have like a while loop,
right?

389
00:22:25,750 --> 00:22:28,480
Because we'd have to call it
continuously throughout the whole game.

390
00:22:28,690 --> 00:22:30,900
But we're not going to do that.
Why should we do that? Uh,

391
00:22:31,090 --> 00:22:34,030
we're just going to have these event
listeners and they're built into Sgg.

392
00:22:34,031 --> 00:22:39,031
So what I'm saying is these functions
are going to fire every time there is a

393
00:22:40,271 --> 00:22:43,420
new time step by themselves
kind of auto magically.

394
00:22:43,421 --> 00:22:46,570
It's built into the framework. It's
kind of like ios or android programming.

395
00:22:46,571 --> 00:22:50,230
If you've ever done mobile developments,
you don't want to just, you're not,

396
00:22:50,380 --> 00:22:54,940
you're not manually constructing event
listeners for all the actions that a user

397
00:22:54,941 --> 00:22:59,770
can do. Swipe up, swipe down, tap,
you know, two fingers, three fingers.

398
00:22:59,920 --> 00:23:01,950
You have those that listeners,
uh,

399
00:23:02,140 --> 00:23:06,040
that are a part of the core framework
that are going to fire whenever a user

400
00:23:06,041 --> 00:23:10,840
does that action. So user swipes
up, which would fire. So if you're,

401
00:23:10,960 --> 00:23:14,530
if you're to put a breakpoint inside of
that function and the user swipes up,

402
00:23:14,650 --> 00:23:18,700
the breakpoint would catch that action
and then you can execute whatever code

403
00:23:18,701 --> 00:23:21,400
you want to. And it's very
useful for mobile developments.

404
00:23:21,490 --> 00:23:24,280
And it's also very useful
for game development.

405
00:23:24,310 --> 00:23:27,600
Having event listeners built into the
framework so we don't have to build them.

406
00:23:27,790 --> 00:23:30,130
So we can just say events
step is going to be this.

407
00:23:30,280 --> 00:23:35,280
And the reason we can say this is
because this class inherits from the ste,

408
00:23:35,950 --> 00:23:40,750
a DSP object class. We're overriding
these functions, right? So that's,

409
00:23:40,780 --> 00:23:44,100
that's it for our invader, right?
That, that's the basic logic of,

410
00:23:44,200 --> 00:23:48,800
of us defining what those genes are
and then logic for moving and for

411
00:23:48,801 --> 00:23:53,210
generating, generating those
values for each gene. Okay,

412
00:23:53,211 --> 00:23:55,070
so in a single time step,

413
00:23:56,880 --> 00:24:00,120
now let's define it for the player,
right? So when we initialize a player,

414
00:24:00,330 --> 00:24:04,470
we are going to say, okay, we can only
move in two directions left or right,

415
00:24:04,471 --> 00:24:05,040
that's it.

416
00:24:05,040 --> 00:24:08,640
So we'll define maps for both of those
keys and then we're going to say, okay,

417
00:24:08,641 --> 00:24:12,180
what's the starting position?
What's the sprite image? Right?

418
00:24:12,270 --> 00:24:15,750
And that's it for our initialization
steps. Then we can go to our events step.

419
00:24:15,751 --> 00:24:20,220
And remember this is called every time
step of the game. So we'll say, okay,

420
00:24:20,250 --> 00:24:23,160
first of all, let's capture the
direction entered by the player,

421
00:24:23,250 --> 00:24:26,310
whether it's left or right. And we'll
put that in the key motion variable.

422
00:24:26,610 --> 00:24:29,820
We'll find a speed in the x direction
and then we'll animate the sprite

423
00:24:29,880 --> 00:24:32,250
according to the moving direction,
right? So if we're going left,

424
00:24:32,310 --> 00:24:35,070
then move the image this way, if we're
going right with the image this way,

425
00:24:35,160 --> 00:24:37,920
that's it. And then we keep a
panel inside of the window, right?

426
00:24:38,250 --> 00:24:41,070
So then we were never outside of
the bounding box on both sides.

427
00:24:41,071 --> 00:24:43,530
We want to keep the player
inside of that bounding box.

428
00:24:44,730 --> 00:24:47,700
And so whenever the player shoots,
right, whenever the player shoots,

429
00:24:47,850 --> 00:24:50,190
we're going to say, you know,
whenever the space button is pressed,

430
00:24:50,550 --> 00:24:54,360
the number of invaders must be higher
than the minimum allowed and a number of

431
00:24:54,361 --> 00:24:58,290
bullets lower than the maximum.
And only if that's the case,

432
00:24:58,320 --> 00:25:00,970
can the player fire a
bullet? So these are, uh,

433
00:25:01,050 --> 00:25:04,440
parameters for which for when
we can fire a bullet or not,

434
00:25:04,650 --> 00:25:09,060
which means we have one more class
and that class is the bullet itself.

435
00:25:09,061 --> 00:25:12,000
So like that little bullet
that's traveling when the,
when the player shoots.

436
00:25:12,330 --> 00:25:15,320
So we'll animate that using this
sprite function. It's that lettuce,

437
00:25:15,360 --> 00:25:19,710
a little fiery little image
we'll set that will set it speed,

438
00:25:19,711 --> 00:25:22,770
which is going to be the starting
speed that we define as a beforehand.

439
00:25:23,130 --> 00:25:26,490
And then we'll say in the event step,
which is happening at every iteration,

440
00:25:26,700 --> 00:25:30,900
either destroy it or if there's a
collision, then, uh, kill that invader,

441
00:25:30,901 --> 00:25:34,530
whoever it touches. All right?
So that's where objects class.

442
00:25:35,720 --> 00:25:36,553
Okay.

443
00:25:36,780 --> 00:25:40,290
And now we have our game class. And
so in our game class we'll say, okay,

444
00:25:40,291 --> 00:25:45,180
we've got our game engine, we've got our
uh, player, an invader objects evolution,

445
00:25:45,181 --> 00:25:48,450
which I'll code into second
or time and then our clock.

446
00:25:48,630 --> 00:25:52,650
So then we have a bunch of, uh, global
parameters here for the resolution,

447
00:25:52,740 --> 00:25:56,220
for the position of the objects for how,
uh,

448
00:25:56,370 --> 00:25:58,680
how the number of milliseconds
between generations,

449
00:25:58,681 --> 00:26:00,810
like 5,000 milliseconds or five seconds.

450
00:26:01,410 --> 00:26:04,800
I had the minimum generation time as
well as like what's the Litho lower limit

451
00:26:04,801 --> 00:26:05,730
that we want it to be,

452
00:26:06,000 --> 00:26:10,320
the number and invaders for and the
Max 100 minimum for Max hundred.

453
00:26:10,590 --> 00:26:14,910
So in a game class,
which we initialized right here,

454
00:26:15,330 --> 00:26:17,190
what happens here? Well, like I said,

455
00:26:17,191 --> 00:26:21,120
we are initializing a bunch of these
game specific parameters. The Hud,

456
00:26:21,270 --> 00:26:25,440
which is the score and the timer, whether
or not to game over very basic stuff.

457
00:26:25,440 --> 00:26:30,270
The clock. And then we have some basic
code for the Hud, which is not, you know,

458
00:26:30,330 --> 00:26:33,920
I won't go over that. And then
a new generation. Okay, this is,

459
00:26:33,921 --> 00:26:35,130
this part's interesting.
So,

460
00:26:35,320 --> 00:26:38,760
so we'll generate some new invaders
and then we'll reduce the time between

461
00:26:38,761 --> 00:26:41,250
generations, which makes it
harder for the player, right?

462
00:26:41,251 --> 00:26:45,630
So that's what we had this minimum value
for generations 2000 because the time

463
00:26:45,631 --> 00:26:48,870
for generation between generations
will decrease every time step.

464
00:26:48,960 --> 00:26:52,890
So it gets harder and harder. And then
in an events that for one full game,

465
00:26:53,130 --> 00:26:56,880
well first calculate the number of
invaders on the screen, show the score.

466
00:26:57,060 --> 00:27:01,140
And if it's more than our threshold, it's
game over. We're done, we're through our,

467
00:27:01,170 --> 00:27:05,670
the Jig is up. Uh, the GIG is up.
But if, if it's over our threshold,

468
00:27:05,700 --> 00:27:09,510
then it's time to breathe again. So we'll
create a new generation, right? And so,

469
00:27:09,511 --> 00:27:12,550
but if it's for, if it, if it's, if, if,

470
00:27:12,600 --> 00:27:15,570
if there's four invaders on the screen
and we're trying to kill one of them,

471
00:27:15,630 --> 00:27:18,510
we can't do that. So we'll draw
this immunity bubble around them,

472
00:27:18,720 --> 00:27:21,600
which means that you just can't
kill them until more are generated.

473
00:27:21,720 --> 00:27:25,890
So that's kind of our way of saying this
is the minimum number of invaders we'll

474
00:27:25,891 --> 00:27:30,490
have key prices for, you know, escaping
and for, for pausing the game. Um,

475
00:27:31,500 --> 00:27:33,810
and so, okay, so this is
this an interesting step.

476
00:27:33,900 --> 00:27:38,550
This is where the animation
for how crossover is
happening. Happens right here.

477
00:27:38,551 --> 00:27:42,510
So whenever, so every five seconds, the
game pauses and then those invaders will,

478
00:27:42,540 --> 00:27:46,770
we'll breed. And then, uh, so what's
happening is we'll say recombinase,

479
00:27:46,800 --> 00:27:51,510
which is the crossover step to create
those chill child jeans and add the new

480
00:27:51,511 --> 00:27:54,840
individuals to our current
list and then reanimate. Okay.

481
00:27:55,140 --> 00:27:57,960
And so then for key pressing in
for event closing. All right,

482
00:27:58,020 --> 00:28:01,410
so now let's get to our good
stuff. The real, the real,
the real meat of this code.

483
00:28:01,740 --> 00:28:03,750
So before I get to these three things,

484
00:28:03,860 --> 00:28:06,090
let me talk about the bounding
interval for the genes.

485
00:28:06,270 --> 00:28:09,180
So we always have some downing interval,
like it's gotta be between this,

486
00:28:09,480 --> 00:28:11,610
this scalar value in this scalar value.

487
00:28:12,330 --> 00:28:15,570
So this is where the crossover and the
mutation is happening and this is where

488
00:28:15,571 --> 00:28:16,530
the selection is happening.

489
00:28:16,531 --> 00:28:20,640
So those are the three really key
aspects of of how this works. We'll,

490
00:28:20,840 --> 00:28:24,360
we'll create an analyst for the offspring
that will store the values in for all

491
00:28:24,361 --> 00:28:27,390
the, for all the children. And so
for each pair of parents, right?

492
00:28:27,391 --> 00:28:30,960
We're giving it parents as the parameters
here, we're going to say, okay,

493
00:28:30,961 --> 00:28:32,520
so for each pair of parents,

494
00:28:32,820 --> 00:28:37,350
let's go ahead and create an empty store
for the offspring's genes. So we'll say,

495
00:28:37,351 --> 00:28:40,440
okay, so the for the genes
of each child, for these,

496
00:28:40,470 --> 00:28:44,190
this pair of parents per each
gene from the key value pairs,

497
00:28:44,191 --> 00:28:47,430
remember it's a dictionary that
these gene values are stored in.

498
00:28:47,760 --> 00:28:52,200
We're going to store both pairs as gene
attributes. Okay? So for both parents,

499
00:28:52,500 --> 00:28:57,500
we're going to compute what those genes
are that we want to give to our children

500
00:28:58,530 --> 00:29:01,830
as values and we're going to
randomly generate the Cha,

501
00:29:01,860 --> 00:29:05,810
the child genes attributes. So
for the children, the, for the,

502
00:29:06,180 --> 00:29:08,790
for each child genes in this,
Jen is going to be the index.

503
00:29:08,791 --> 00:29:09,870
For this specific child,

504
00:29:10,170 --> 00:29:15,170
we'll use a uniform distribution to
compute what the values should be.

505
00:29:16,231 --> 00:29:19,950
So we'll say, okay, min
values and then Max value.

506
00:29:19,951 --> 00:29:23,730
So it's going to be a distribution between
the min and Max values for this gene.

507
00:29:26,040 --> 00:29:30,260
And then we'll randomly decide if it's
time to mutate the children. So if,

508
00:29:30,350 --> 00:29:35,350
if it's so generate some random number
and then if it's less than the mutation

509
00:29:35,371 --> 00:29:39,960
probability, then we'll go ahead and
mutate. The children helps. We won't.

510
00:29:40,110 --> 00:29:44,050
So this is, this is how we select, uh,
whether or not we're going to mutate.

511
00:29:44,051 --> 00:29:48,250
The children are not right.
So Emar mutation probability is 0.1.

512
00:29:48,640 --> 00:29:50,980
So it's got to be less than
that. So we'll say, okay,

513
00:29:50,981 --> 00:29:53,860
so the first get the Min and
the Max values for the parent.

514
00:29:54,310 --> 00:29:56,290
So the Min and the Max
value is part of the parents

515
00:29:59,050 --> 00:30:03,390
will say Jen men.
And then we have for the,

516
00:30:03,450 --> 00:30:06,940
the Max value for the parent will say,
Jean props,

517
00:30:09,050 --> 00:30:12,310
Gen Max,
all right.

518
00:30:12,700 --> 00:30:16,780
And then we'll get the value for the
child and the child is going to be

519
00:30:18,520 --> 00:30:23,170
that same index and now it's
time to mutate. So for mutation,

520
00:30:23,380 --> 00:30:27,970
here's what it looks like for mutation.
So, so basically for this mutation step,

521
00:30:28,150 --> 00:30:32,440
we're introducing new genetic material
into the population by replacing one

522
00:30:32,441 --> 00:30:36,790
parameter in the genome by this
random value within the allowed range.

523
00:30:37,000 --> 00:30:40,750
And then once we have that,
then we can go ahead and return.

524
00:30:41,470 --> 00:30:43,510
We can go ahead and add
the children to the store.

525
00:30:43,511 --> 00:30:47,230
So offspring dot append
and then the children gene.

526
00:30:49,030 --> 00:30:51,910
And then finally we'll
return all of the children,

527
00:30:54,340 --> 00:30:55,240
paternal offspring.

528
00:30:57,700 --> 00:31:01,660
And this goes right
here. Okay, great. Right?

529
00:31:01,661 --> 00:31:05,410
So that's for a crossover and mutation.
That's how we were crossing over. Parents,

530
00:31:05,740 --> 00:31:05,921
uh,

531
00:31:05,921 --> 00:31:10,921
were saying we're taking these values
from both parents and using those values

532
00:31:11,291 --> 00:31:14,020
for those genes to help
compute this child gene.

533
00:31:14,260 --> 00:31:16,180
And then we're mutating
the child, Jane, right?

534
00:31:16,181 --> 00:31:21,040
Using this a random normal distribution.
So that's crossover and mutation,

535
00:31:21,041 --> 00:31:24,910
and then their selection. So all of
these children who gets to reproduce,

536
00:31:25,750 --> 00:31:29,620
so for all the members of the population
will sum up all of their fitness scores.

537
00:31:29,890 --> 00:31:33,250
And then we'll say, okay, so we'll
randomly generate a distribution.

538
00:31:33,251 --> 00:31:36,340
And then for each invader,
we'll subtract its value.

539
00:31:36,730 --> 00:31:39,400
That's fitness value from the
randomly generated number.

540
00:31:39,520 --> 00:31:43,450
And if it's less than zero, then that
invader gets to breed. So here's why.

541
00:31:43,480 --> 00:31:45,640
Here's why we're doing this.
So you might be thinking, okay,

542
00:31:45,670 --> 00:31:50,080
so why couldn't we just compute the
fitness for each individual and then say,

543
00:31:50,140 --> 00:31:52,360
whichever you know,
however long it's alive,

544
00:31:52,361 --> 00:31:54,850
we'll just keep incrementing that
fitness value. That's scale, scalar,

545
00:31:54,851 --> 00:31:58,150
single value, and then the ones that
have the highest fitness scaler,

546
00:31:58,180 --> 00:32:01,240
why don't we just choose those?
Why do we have to add this random value?

547
00:32:01,480 --> 00:32:04,600
The reason we're adding a random
value here is because, um,

548
00:32:06,100 --> 00:32:11,100
the ones with the best jeans and the
immediate term doesn't necessarily mean it

549
00:32:11,231 --> 00:32:13,060
has the best jeans in the longterm.

550
00:32:13,180 --> 00:32:16,600
So if we add some kind of variational
or probabilistic aspect to it,

551
00:32:16,870 --> 00:32:20,770
then that allows for, um,
different possibilities, right?

552
00:32:20,920 --> 00:32:23,590
It means that these jeans
right now where the best ones,

553
00:32:23,740 --> 00:32:27,910
but let's add some variation to it just
in case there's other possibilities out

554
00:32:27,911 --> 00:32:31,510
there. Do you see what I'm saying? So by
adding a variational aspect to selection,

555
00:32:31,780 --> 00:32:35,830
it's, it just improves how we evaluate
the fitness for each individual.

556
00:32:36,220 --> 00:32:38,290
And so that's,
that's it really for this.

557
00:32:38,320 --> 00:32:40,820
And then we had this meeting Paul
and tournament, but that's just for,

558
00:32:40,970 --> 00:32:44,880
that's just for printing out to
terminal. So that's it for this code. Uh,

559
00:32:44,900 --> 00:32:47,570
if you liked it,
please check out the get hub repository.

560
00:32:47,720 --> 00:32:50,090
I've got all the instructions
in the details in there.

561
00:32:50,390 --> 00:32:54,140
Definitely try out a genetic algorithm
on your own. They're very simple,

562
00:32:54,141 --> 00:32:55,430
very easy to understand.

563
00:32:55,580 --> 00:32:58,670
You don't need to know backpropagation
or calculus or linear Algebra.

564
00:32:58,880 --> 00:32:59,930
Very simple stuff.

565
00:33:00,050 --> 00:33:04,220
You can easily implement them in pie
game and open AI's Jim and open AI's

566
00:33:04,221 --> 00:33:08,090
universe. There's a bunch of
possibilities and if you do this,

567
00:33:08,091 --> 00:33:11,180
then it's just going to increase
your confidence as a developer,

568
00:33:11,181 --> 00:33:14,570
as a machine learning engineer, as
a data scientist, whatever it is.

569
00:33:14,600 --> 00:33:17,780
So thank you for watching.
I love you guys. Seriously,

570
00:33:17,781 --> 00:33:21,200
I do it for you and if you made it this
far, I'm very proud of you. Thank you.

571
00:33:21,440 --> 00:33:23,060
And I'll tell you a little secret.

572
00:33:23,090 --> 00:33:26,750
Something big is coming up and only you
get to know that because you made it to

573
00:33:26,751 --> 00:33:28,430
the end.
I can't say what it is,

574
00:33:28,550 --> 00:33:31,520
but something big is coming
up before the year ends.

575
00:33:31,610 --> 00:33:35,150
For this channel is going to be
amazing. All right, so that's it.

576
00:33:35,360 --> 00:33:37,760
Please subscribe for more
programming videos, and for now,

577
00:33:37,790 --> 00:33:40,600
I've got to evolve my hair,
so thanks for watching.

