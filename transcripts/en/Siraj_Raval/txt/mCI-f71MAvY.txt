Speaker 1:          00:00          So it requires math to help arms move. Thanks brain. Hello world. It's or Raj and robots are a lot of fun to read about and imagined, but they're also used in a ton of real world applications. We're going to go over two really important concepts in robotics forward and inverse kinematics so that we can program a robotic arm in a simulated environment to pick up an object in front of it. It's a simple task, but to solve it, we'll need to make use of both trigonometry and calculus. If you're new to this channel, hit subscribe to stay updated on my educational content. Robots come in all sorts of shapes and sizes on land. We've got autonomous cars, which can be considered robots and they're already street legal in Frisco, Texas. Drive dot. Ai is running a pilot program offering rides to over 10 k people using their app Ip.

Speaker 1:          00:56          Dole humanoids are being trained to complete complex rescue operations for both militaries and private industry. Just don't expect them to know how to balance and let's not forget Tesla, where robots are building thousands of electric cars in there. Gigafactory in an almost completely automated pipeline. The first of its kind in the air. Drones are used for everything from video production to crop monitoring. Even underwater robots are exploring the deep sea and helping mind for resources. And while all of these robots might look different and perform different tasks, one thing that the vast majority of them have in common is having an arm more formally. We can call it a robotic manipulator and it's one piece of robotics that is quintessential to study for any aspiring roboticist. I built one of these myself a couple of years ago, uh, using a three d printer, some motors, open source software, and lots of late nights in the lab with no Netflix.

Speaker 1:          01:59          The project was called in move and help me learn a lot about mechatronics and control theory. Robotic manipulators are used to pick up objects, manipulate control panels, and build components all autonomously. Studying robotics gives us a deeper appreciation for our brain's own incredible capabilities. Robots like us are able to reach several points in space from multiple angles and joined configurations. This type of task requires a robot to do some planning and it's why roboticists must study kinematics. Kinematics is the branch of classical mechanics that describes the motion of points, objects and systems of groups of objects without reference to the causes of motion. In fact, a lot of times the study of kinematics is referred to as the geometry of motion and we can actually divide kinematics into two subfields forward and inverse kinematics. Inverse kinematics takes a point in space as input and tells us how to move our arm optimally to reach that point forward.

Speaker 1:          03:05          Kinematics solves the opposite dual problem. Knowing how our arm works, it tells us which points in space it can reach. Let's start with a simple robotic arm in simulation. Anyone can view this in the browser. It was built with a simple javascript library specifically for simulating robotic motion. This robotic arm is made up of limbs connected by joints and since the arm has three independent joints, we can say that this robot has three degrees of freedom. If it had four joints, we'd say it has four degrees of freedom. Each joint is controlled by a motor which allows it to move the connected link to a certain angle. We can't in fact draw out a very precise schematic of the joints by hand to help us better visualize it. We will assume that each joint can only rotate on a single access for this demo. Depending on the context, we can count the end effector has a degree of freedom or not, but right now let's not for simplicity's sake, we can advance to terminator robots later.

Speaker 1:          04:08          Each joint here is able to rotate on a specific axis and the state of each joint is measured as an angle by rotating each joint to an angle. We caused the end effector to reach different points in space and remember knowing where the end effector is given the angles of the joints is known as forward kinematics. This is an easy problem, meaning for each set of angles there is one and only one result which can be calculated precisely. Understanding how this arm moves depending on the inputs that we provide to each of its motors is a crucial step in finding a solution to its dual problem. Of Inverse kinematics. So how do we solve both of these problems both forward and inverse kinematics for our arm. Each joint contributes to the local rotation of it's forward chain of links. When the second joint rotates a given number of degrees, we again see our arms configuration change.

Speaker 1:          05:06          The first degree change determine the position of the first joint, but the position of the second joint is affected by the degree change for both the first and second joint. The arrows are oriented according to this, some of the rotations of the earlier chain of links they're connected to. To solve the problem of forward kinematics for our arm, we need to be able to calculate the position up nested objects in this chain, do their rotation if we had just two joints. Once we solve for two, we can replicate it in sequence to solve chains of any length. In the simple case where the first joint is in its starting position, we can simply say that the position of the second joint is equal to the position of the first plus a distance Vector d. When the first joint is not zero, we have to rotate the distance factor at rest around the first joint by that many degrees and by replicating the same logic we can derive the equation for this second joint.

Speaker 1:          06:03          Looks like there is a generalized pattern here. We can just add more joints in the equation gets bigger to encompass those variables. We can write out a general equation here that will output the position of any joint given the joints and angles that came before it. Thanks to the rules of trigonometry. We can write this out such that the value of any joints position can be expressed in relation to the value of the other joints and angles of our arm. Because of this, when one of our variables is known, we can solve for the others forward and inverse kinematics problems are very common and there are several approaches to solving them. One of them, for example, associates for parameters with each joint. They're called the denovate Herzenberg parameters. They're easy to manipulate in a matrix format and are absolutely perfect to solve inverse kinematics analytically, but solving identified Herzenberg Matrix take some time and is overly complicated compared to an optimization technique that all machine learning engineers know and love popularized by neural networks called gradient descent.

Speaker 1:          07:10          We can summarize the behavior of our system in two equations. The first one we'll describe the rotation of a joint which is the sum of the rotations of all previous joints and we have the position of a joint. If we write our forward kinematics function for our robot, it will take us input, an array of float values called angles. Each angle is there local rotation for each joint. The function will need to return the position of the end effector. In global coordinates rotations are often described with Euler angles. These are three numbers that correspond to the rotation of an object along the x, y, and z access. But using these angles can be expensive to compute a better way to work with angles. It's a used quaternions. These are the mathematical objects that are used to represent rotations. Euler angles, however, represent orientations a quaternary and represents a way to go from one orientation to another.

Speaker 1:          08:09          We can imagine it as a rotation. If we take an object in space, multiply, it's positioned by a quaternary in, we get a rotation and if we multiply two quaternions to create a new one, it will incorporate both rotations. A multiplication between a quaternary and and a vector applies the rotation. So for our forward kinematics, when we have a specific point in space we want to reach, we can estimate how close we are given the current joint configuration. The distance from the target is a simple function. Finding a solution for inverse kinematics, however means we want to minimize the value returned that measures the distance between the end effector and the target. Ideally it's zero, which means we've reached our target. This is a mathematical optimization problem and gradient descent is a technique that can be used to find the minimum in a landscape of possibilities.

Speaker 1:          09:03          We can imagine it like dropping a ball into a valley where we have two axes, one for the possible errors and one for the possible parameter values. Once we drop a ball in, the ball will eventually rest at the minimum where the error is smallest, which will give us the optimal parameters for our arm. We have a function which we'll take a parameter for each joint of our robotic arm. That parameter is the current angle of the joint. Given a particular configuration of joints, the function will return a single value that indicates how far the end effector is from the target points to find the values for the joints that minimizeF , we first calculate the gradient of a function for the current joint angle. The gradient is a vector that indicates the direction of the steepest ascent. It's an Arrow that tells us the direction in which the function grows.

Speaker 1:          09:55          Every element of our gradient is an estimation of the partial derivative of f. The power of calculus helps us compute change in our system are weights that will be updated. In this case are our joint angles for each of our robots. Three joints. Our function will take in all three parameters and output a gradient that we can use to iteratively update our joint angles until we reached the target. Once we have these functions, we can easily click on a point in space and watch as our robot moves optimally. To that point, I've got helpful links and code for you in the video description. Check it out. Robots are so bay. Have you built one before? If so, share your experience with us in the comments section. I'd love to learn more. Please subscribe for more programming videos, and for now I'm going to fly, so thanks for watching.