Speaker 1:          00:00          Oh, well it's Saroj and I've got sand between my cheeks. Feels really weird. Check out this pine cone that I found on the way. Here are eight sets of clockwise spirals. While there are 13 sets of counterclockwise spirals, when we divide 13 bikey, the answer is 1.6 better known as the golden ratio. The golden ratio is all around us. It's in the curvature of the ocean waves, it's in seashells, it's in the spiral that makes up our milky way galaxy from a simple set of rules and were just enormous complexity and the universe works this way. Our brains must as well. We're going to create our own universe simulation in 60 lines of python in 1970 and article was published in scientific American about a game created by a mathematician named John Conway called the game of life. Conway was interested in a problem presented by the computer scientist, von Neumann, von Neumann theorize of a type of machine that could build copies of itself.

Speaker 1:          00:55          He called the universal constructor. This machine would be useful for colonizing other planets. We could theoretically send this machine to Mars before humans and it could mine and smelt iron in order to make more copies of itself and soon an army of these could help develop an atmosphere before humans arrived or it's like independence. Then only Wellsmith could save us. Welcome to Mars. He based it off a concept he called cellular automaton or ca. The idea behind [inaudible] is that the behavior of a group can be described by the interactions between a simple machine or automaton and you're by identical automaton that interact with it. In the game of life, the universe is infinite. Two dimensional grid of squares cells. Each cell can be one of two states, either alive or dead and every cell interacts with its eight neighbor sells their just for rules to the game.

Speaker 1:          01:41          Any lifestyle with less than two live neighbors dies up loneliness and you live cell with two or three live neighbors lives on to the next generation or survives any lives saw with more than three live neighbors dies of overpopulation and lively. Any dead cell with exactly three live neighbors becomes a lifestyle as if by reproduction. Once you say your initial configuration of cells on the grid and start the game, complex patterns will start to emerge. We just, those four rules like the eater which eats all sorts of organisms or a breeder which grows its number of life cells faster and faster or gliders and spaceships and really crazy gigantic ecosystems that become more complex with time. Yo. Okay, let's build our own command line version of the game of life. In Python. We just have to libraries to import both CIS and terminal well that it's input data and read it from terminal.

Speaker 1:          02:28          Let's get right into the main method, but we will implement our high level code well. First one I defined our grit universe. Get term side is a function that returns the host terminals within height. Once we have those two values, we can format her grid so that it fits into our terminal. The grid will be a two dimensional array. Now that we have our grid defined, we can try it on the screen with the update screen function, which will update the terminal to display it with a set of ones and Zeros for each cell. That cells will be white zeros in living cells will be read once the Greg, we'll start off with all dead cells, so we'll want to set our initial living cells. Once we set these, they will evolve within the simulation while abiding by the four simple rules we talked about earlier, the read initial configuration function.

Speaker 1:          03:05          It takes the grid as a perimeter and we'll ask the user to input the coordinates of their living cells to start the game. Once we have our initial configuration set, we'll need to know how many iterations to play the game, so we'll ask a user for that number. We'll set an iteration step variable to keep track of which iteration we're on. Then update the screen to show our user input. It's structures will then create a while loop that will run for the length of the game. Inside of our while loop, we'll create a variable called play, which will represent the user input. Either the number of steps remaining or the quit input, but don't quit because we're, if the user types in quit, we'll break the loop and the game is over. We will code a try except block to convert the string input to an integer for the number of steps and set them to one.

Speaker 1:          03:45          If there is an exception, then we'll start our for loop for each step defined by the user. That means that each time step we're going to apply the four rules to what's on the screen until the total number of iterations is over. We'll create a new grid that will store the original grades. Next step. The next step function will help us do this. Let's take a look at that function in more detail. It's got a nested for loop in it. This is where we're going to take our old grid, apply our four rules to it and store the result and the updated grill. It's a nested for loops. Since we're going to go through every single cell and the grid matrix to apply our four rules to each of them at each of these cells will need to count the number of live cells around it, which is what the healthy neighbors function looks for.

Speaker 1:          04:22          It takes our grid and x, y coordinates as its parameters. The live neighbors variables stores are number of live cells. Once we have that number, we can apply our four rules in the case that our current cell is alive, any lifestyle with fewer than two live neighbors dyes as it caused by under population and any lifestyle with more than three live neighbors dies as if I overpopulation. The end result for both of these cases is a dead cell, so we can set our current self to zero or dead. If either of these is the case else, it lives since that is our third rule. Any live cell with exactly two or three live neighbors lives on to the next generation. That leads our last rule, which is four dead cells. Any dead cell with exactly three live neighbors, he comes alive. Sal as if by reproduction, uh, sex.

Speaker 1:          05:03          So we'll send it to alive so that we'll place our new cell states in the new grid. Once we have this new grid, we'll set it to the original grid and the new grade where we said to the original grid, they switched values. We can then update the screen to show the state of our updated grid. When our loop finishes, we'll update our iteration step variable to include the number of steps, the user input, and that'll be the end of our wild loop will run on a script by typing in python life.py. We'll be able to see our initial Greg with no values. I'm going to create two small glider organisms that will move through the space. I'll type in this set of coordinates for each of them for each. Then when I'm ready, I'll say, let's run this thing for 1000 iterations. Yeah, yeah, yeah, yeah, yeah. I've got links for you in the description and definitely subscribe. If you want to see more programming videos, I've got to go create a universe, so thanks for watching.