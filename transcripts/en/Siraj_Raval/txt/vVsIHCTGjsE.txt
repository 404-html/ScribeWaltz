Speaker 1:          00:00          Hello world, it's a Rod. And we're going to talk about a peer to peer chat protocol. So you don't need to use a server. And this is what etherium uses. It's a protocol called whisper. And I have a demo of it right here. So let's check it out. So my name, I'm going to put Saroj and then I'll put the chat as hello world, I'll hit send, boom. And if I have another peer in the network, it's going to send that message to that pier. No server involved from one peer to the other, peer to peer. And let me say that one more message. Hello again. And we send it. So in this video, we're gonna look at this app at the very end, the code programmatically. But before we get there, we've got to talk about the architecture of the whisper protocol because it's very important to the web 3.0 stack.

Speaker 1:          00:45          So that's what we're going to do at the end. But let's start off with talking about this stack. So recall that before I talked about the consensus layer and the consensus layer is the etherium blockchain. So what it's used for is for the network to come to consensus specifically any kind of depth that you're building, it has to come to consensus on what are called application level constructs. These can be usernames, tweets, timestamps, anything unit, the anything you need the network to agree upon, that's when you would use a blockchain. So that's one part of the stack. So we'll get these three gray boxes here. The other two boxes, one is for whisper, and that's the messaging stack, right when you need your app to communicate with other apps dapps. And then the third is swarm, which is the storage layer, which we're going to use IPFS for, which we'll talk about later.

Speaker 1:          01:36          But right now we're going to talk about whispers. Since we talked a bit about the EVM before, and we'll talk about that more as well, but let's, let's get right on into it. So if we look at the etherium stack, clearly they, they've had whisper as a very crucial part of the stack. Notice that the smart contracts live on the ethereum consensus layer. Swarm is used for file storage and in whisper is for dynamic communication between peers, peer to peer, right? So it's a communication protocol for gaps to communicate with each other and they, the main feature that whisper has that other chat protocols don't have is darkness. So what I mean by darkness is no one can trace who you are if you send a message to somebody. And even if they received the message and it's meant for them, they have plausible deniability.

Speaker 1:          02:24          What that means is no one could, could tell that that message was sent to them. And you might be thinking, how is that possible if that message lives on their computer? Of course it was meant for them. Well, the way whisper is set up is such that messages are continuously routed between all peers, whether or not that person is the recipient, they will receive the message and forward it along. And I'll talk about that in a second. It uses darkness as a feature, but it comes at a high cost. And we'll talk about that as well. So remember this is happening off chain. This has nothing to do with the blockchain. This is just a pure to pure communication protocol. And then we can think of whisper as kind of a distributed hash table. So a hash table has key value stores is the data structure I distributed hash table is the same idea except the stores of values are distributed across a network of peers.

Speaker 1:          03:13          So we can think of it that way because messages are the values that are being keyed in via the identity of the peers in a distributed way. The nodes in the theory of network, or we can think of it as a datagram messaging system, peer to peer messaging system. You could think about it different ways, but it is a messaging system that lives in a distributed network. So this is just an example of a bunch of nodes. They're passing messages between each other. So the way whisper works is that every message is delivered to every node. So if I'm, if I'm a node in the network and I want to deliver you a message, I'm going to first send that message to my nearby peers. And what's going to happen is this message is meant for you because you have a key that can unlock that message.

Speaker 1:          03:58          You and only you have that key. But regardless of whether or not it's meant for you, I'm going to send it to all these peers. Why for darkness? Because these peers, no, it's not for them, but they're going to receive it anyway and they're going to forward it to their neighbors until eventually that message reaches your intended recipients. Right? So that the point of this, instead of sending it directly to the recipient is so that it's untraceable and once the recipient receives that message, the recipient will then forward it on anyway to other peers nearby it to completely have it be a dark protocol. Now we can configure how dark we want it to be in that we can configure how much we want to give up in terms of speed and bandwidth and computational cost in terms of preserving. That's kind of a identity hiding, right? So nodes or message to neighboring nodes, etc. And it's an identity based messaging system, so everybody in the network has an identity. This is a unique key that's generated via via the Sha two five six hashing algorithm. So at its most secure mode of operation, it can theoretically does deliver 100% darkness. So there's a trade off though between the level of privacy you desire and the performance it's included by default in the go. If theory, I'm client get under the peer to peer package PTP.

Speaker 1:          05:24          And so crucially, in order to prevent ddosing, so if you think about this idea of how the messages are being routed, you might be wondering, wait a second, can someone just spam the network by sending millions of messages to all the peers and then it's just going to call some of the peers to go offline because of the amount of bandwidth and storage it's requiring, even though it's a femoral. Well, the way they prevent that is by using a proof of work algorithm. So messages will be process it process and forward if further only if the proof of work exceeds a threshold, otherwise they will be dropped. So all the notes are performing a proof of work on the message. So there's a kind of computational threshold to the amount of messages you can send and this prevents spamming the network. So what are the use cases of with of whisper?

Speaker 1:          06:13          So what I have here is a diagram of a decentralized games, specifically chess. And so notice that there are two players in this game and these players are using the blockchain for the application level construct. What do the players have to agree upon? I think about it for a second. They have to agree upon the state of the game. Who's winning, who's losing, how many pieces is each player having the game we can store that made it metadata on the blockchain, right? And when it comes to the actual storage, the heavy loads of, you know, what these objects look like and the shades and all that that we can store in a distributed hash table like for storage, right? Swarm. But when it comes to whisper, whisper is used for them to communicate with each other as in, okay, we see that this player is in a new state, let's sign the new state and increment the move count until the other player.

Speaker 1:          07:02          Right? So it's kind of a message, passage passing framework. And so that's neat to publish small amounts of nonpersistent information with a preset TTL. That means time to live, right? We can, it can be anywhere from 10 minutes to two days. Right. If you're dap needs that, then this was a good use case. Right? And if your dap needs to communicate with another one prior to actually sending a transaction, this would be a good use case. Right? So before let's say two nodes want to send a transaction to each other, they need to set up a deal, right? And they need to settle how much they want to send to each other. When a, what are the preconditions for that transaction? Whisper would be a great use case for that. Right? Cause so they can communicate and before they send the transaction, if you have adapt that provides non realtime updates, this would be useful as well.

Speaker 1:          07:51          So remember at whisper is not in real time. There is that cost in latency and in speed to ensure darkness and status is an example of an of a messaging APP. Look up status. Just status. If theory that is using whisper in production and they raised $44 million in a few minutes using an ICO and they're probably the most widely used APP that uses a theory I'm today and it's specifically the whisper protocol. So there have been a lot of existing solutions that whisper has built on. Uh, for example, UDP, which is a similar at an API level, they kind of took bits and pieces of these ideas from similar protocols and just use the best of them, which is generally how good research should happen. They've got a big message was another example, Tele Hash talks. They all had their pros and cons, but they kind of tried to synthesize the best ideas from all of them, similar to how IPFS was created.

Speaker 1:          08:48          But it has some really great features. So when it comes to whisper, the API is only exposed to contracts, never to user accounts. It's low bandwidth. So it's only designed for smaller data transfers. You shouldn't be sending giant movies on this thing, right? Just think about texts, right? Just strings of data. There's an unpredictable latency because there is a probabilistic routing mechanism here. So this adds to the darkness feature that I want to talk about, right? So because the routing isn't deterministic, meaning that we can't know who you're going to send those messages to, which order appears, there's a probabilistic aspect to it, then we can never trace back who it was or what that route was. We can't predict the route. So that's just for the darkness. But because of that probabilistic nature, we cannot predict the latency, how long it's gonna take to get your recipient.

Speaker 1:          09:40          And so all API calls for whisper are contained in the web, three dot s h h object, all of them. And we can type that into an interactive consult to get a list of all functions and variables that are provided. So if we look at this code snippet here, Var f equals web three dot. S H h. Dot filter. And then we'll have a topic. This is a topic for the message. What is it about? It's kind of an identifier. We'll say, we'll use a get function to retrieve that. And we'll say, let's get the message via the topic and then post the message via that, right? So we can get the message, we can post it via the topic, that's the parameter that we can use. And we have these other parameters as well in terms of payload, TTL worked, approve, et cetera. So the payload would be the message. TTL is a time to live, how long we want it to remain active in storage and work to prove is how much, how much work do we want it to require to, uh, compute that proof of work. So let's get right into the architecture. And I've got this really cool image of a solidity extension for visual studio just because it's awesome, but it has nothing to do with the actual architecture. But yeah, check that out. If you use visual studio, this is a really cool way to integrate solidity into your ide.

Speaker 2:          10:52          Okay.

Speaker 1:          10:53          Right? So let's talk about the message object. There are really two key objects here. When we're talking about whisper, we had the message and then we have the envelope. And so true, true their name. We can store the message in the envelope and we send that to the user. These are just objects. So each message is accompanied by a unique process of message, ceiling. So ceiling is the proof of work algorithm compression, which is just compressing it for faster data transfer and encryption. And this was just for security purposes. Each message has a lifespan of up to two days, right? The TTL and the proof of work infusing consists of a simple shot, three hour them. And what we try to find the smallest number within a given timeframe, and this requires computing power to find the smallest number in a given timeframe.

Speaker 1:          11:39          So it kind of looks like this. So sending a whisper, whisper message required you to number one, create a new whisper message. Number two, seal it. Optionally, you can encrypt it and sign and supply with the topic of your choice. And number three is send it to your, so this is in go right if you, if, if we want it to write this and go, we could, uh, but just because the client has written in gold, but we can easily write it with javascript. It doesn't matter if you don't know, go just, just take a look at this four lines snippet of code. So we have a topic, a message, an envelope, we seal it and then we send it. Boom. Just like that, right? Very easy. Four steps that we can do the same if we want to listen to messages, right? So if we're, if we are a recipient, if we're intending to receive a message, we can say, well this is the topic that we are waiting for and now we can use the watch event listener of the whisper object to wait for that topic to, to come into our, to our network and then we can print out what it is once we receive it.

Speaker 1:          12:32          Very similar to event listeners in javascript. So how does this ceiling work? Right? So proof of work. We know that in Bitcoin and etherium in general, they be consensus layer uses a proof of work algorithm using Sha two five, six. Well, this one uses shot through to find the smallest number.

Speaker 2:          12:49          Okay.

Speaker 1:          12:50          What I mean by that is we have to hash the contents of the message over and over and over again into the smallest possible number that we can get it to via a proof of work that that is the proof of work. The work that is being computed by the minor. In this case, it's any node can be a minor in terms of whisper is how small can we make that number by repeatedly hashing it and we can set how long we want to do that, right? That's that. That's that parameter. When we send a message, how much do we want to offer the proof of work? So the cost of computing, it can be regarded as the price you pay for allocated resources. If you want the network to store your message for a specific time.

Speaker 2:          13:31          Yeah,

Speaker 1:          13:31          and we can call this the best bit. The best bit is the number of leading zeroes of zero bits in the hash divided by the message size and TTL. And that is the proof of work that just repeats over and over and over and over again. But it results in a single aggregated parameter for the message rating or a scaler. What that means is us, we as developers, if we want our messages to have priority over others, then we'll need to spend more computational resources sealing them. So we can set that parameter higher if we want to have priority over others in the network, meaning faster data transfer for your message. So, uh, with for messages are encrypted by default. Now the [inaudible] developers encourage developers to use their own form of encryption on top of the standard encryption. Uh, but that just exists as a kind of default state and they can be encrypted either symmetrically or asymmetrically. Remember for symmetric encryption, uh, they use the same key for encrypting and decrypting. For asymmetric encryption, we use different keys for encrypting and decrypting, right? Public private key pair similar to bitcoin.

Speaker 2:          14:42          Okay.

Speaker 1:          14:44          Right? So when it comes to decrease decryption, this takes place using a private key. If the message envelope was encrypted by no more than one sender. Okay. So that's it for encryption decryption ceiling. We know the kind of routing mechanism that whisper uses. We know that it's a part of the theory I'm stack when it comes to communication between dapps. Let's look at this example. I have here about a way to send it to other peers in the network. So I've got the, the DAP that I just showed you in the browser. I've got get up and running here as well, so we can see the blockchain running. But, uh, let's, let's look at this. So it's using Vue Vue, which is, uh, which is a very simple framework for building web apps, right? So in our case, this would be a web three APP, but let's take a look in, in this file, whisper, chat dot Vue, which is really the, the main code that we want to look at. So it starts off with some html, you know, Hetero is dibs. This is our chat application. Here are some, uh, variables that we are computing before the asymmetric public key because we're using asymmetric encryption. In this example, here's our public key that ended up send a message easily hitting this button and then it's going to send it to everybody else. Now here is the really the, the, the key bit here. So,

Speaker 2:          15:59          okay,

Speaker 1:          16:00          so now we're going to look at these constant values here. So it's using a little bit of embedded go. Don't worry if you haven't used go before. It's a very simple language. I'm going to go through it with you right now. We're going to import some very important libraries. Web three is if [inaudible] the library for communicating with its stack in general. We have two libraries for symmetric and asymmetric encryption. And then we have a Hex, uh, a hexadecimal encoding a library as well. So the first thing we're going to do is we're going to say, okay, this is our data. We have some message, it's got an associated key, it's got a private key, and we're going to create a new key pair for this data specifically. And then we're going to return that data. So now we have this data object,

Speaker 1:          16:42          right? So the next step for us is going to be to define this. Send a message, function call, right? So in send message, we create a message. The message has a text, it's got a name, and then it has those key parameters we talked about before, right? What's the TTL is by default, it's going to be seven. What's the topic? We're going to use hexadecimal for the topic. Just for simplicity sake. What's our proof of work? Target. Let's say 2.01. Remember it's a scaler, how long a hundred. What's the payload? And that is going to be our message, right? We're going to string a Phi, that message encoded to hexadecimal, and that's our payload for the message. That's what we, the data that we want to send in this, uh, in this envelope

Speaker 1:          17:23          we have another function for updating the symmetric key if necessary. And then we have a configuration function as well. But the really, the really key, uh, function here is us saying this. We're going to say, get the filter messages. And then we're going to receive those messages as well, and then we're going to push them, right? So we can eat a, receive those messages or we can push those messages to other peers. And when we pushed them, we can use the push function right here and we can sit, we can print them out here, we can set our variables, et Cetera, et cetera.

Speaker 1:          17:54          Well, yeah, it's, it's a, it's a pretty simple protocol. Um, all the API is available in the documentation. I'm going to have great links for you in the description as well, but definitely take a look at this protocol. I think it's very cool and it's going to be a crucial part, whether it's whisper or some other peer to peer chat protocol of Building Adap, right? We cannot store everything in the blockchain. We cannot store anything on a server if we're building adapt or else it's not decentralized and we cannot store everything in IPFS. We have to have some way for notes and communicate in as close to real time as possible while preserving darkness while preserving privacy. Please subscribe for more programming videos. And for now, I'm going to go dark, so thanks for watching.