Speaker 1:          00:00          Hello world, it's Saroj. And today we're going to build a genetic algorithm for the game space invaders. Well, it's actually not space invaders is called Citius invaders invaders, but it's our, it's very similar. It's based off of space invaders. So I'm going to start off with a demo of what we're going to build. There's a javascript version of this and there's a python version of this. And of course we're going to do the python version because that's what we do. Python, of course. So let's, let's look at this game first. Ready, set, go. Okay. So we are this dude at the bottom. You've, you've played space invaders before. I don't need to tell you how space invaders works, but this is a special version because what happens is these invaders will, uh, breed or crossover every five seconds they're going to breed every five seconds in my job, I'll hit the space bar is to kill them all, all the time.

Speaker 1:          00:51          All of them that are going to keep on breeding over and over again. And I've got to get them to be obliterated, but they're just going to keep on breeding. And what they're going to do is they're learning from my behavior. They're not just breeding for the sake of breeding. They are learning from my behavior and they're getting better over time. There's a learning process happening here, but it's not gradient based optimization, which is what we're used to. And it's not reinforcement learning base, which I talked about last week with the deep learner. This is a whole different paradigm. It's called genetic algorithms and sometimes it's called evolutionary algorithms as well. But now there's, there's a, there's a million of them anyway. So that's what the game is going to look like. This is in the browser. We can also compile it from our desktop. But that's the basic idea.

Speaker 1:          01:35          Oh my God, there's so many of them. They are breeding like ray invaders. Okay. So that's what we're going to do. And so what our algorithm does, very simple. It's a very simple algorithm, but the concept itself is very cool. Uh, is it starts off with four invaders. So the game doesn't, can never have less than four invaders for is the minimum. So there's no, there's no winning the game. Just, you know, whatever, but you can't have more than a hundred invaders so that the interval is between four and 100 if there are a hundred invaders on the screen, we lose it's game over. But if there, what we try to keep them as close to four as possible by shooting them. And so each invader has for what are called genes, you can think of them as attributes as well. Speed, how fast it's moving, the probability that it's going to change direction, which is between zero and one as all probabilities are the size of the invader.

Speaker 1:          02:30          It could be big, it could be small there variational there's all sorts of sizes and the color, which is kind of negligible really. But uh, we'll, we'll update that as well. It's a hex value and so it has four attributes or genes as we call them in this paradigm. And every five seconds they mate or crossover and it produces children like new invaders that are supposed to be better than then it's parent than their parents. And the invaders were the highest fitness by some measure of fitness that we, we're going to define what fitness means. It's like a, you know, our measuring contest and by some measure of fitness we're going to determine who gets to breed and who doesn't. It's a very Darwinian process. So that's what it is. And the invaders that learned the best or or, or who have the best set of genes are going to be the ones who get to crossover or breathe.

Speaker 1:          03:23          So this is uh, this is this image. All of genetic algorithms, all of genetic algorithms can be summed up in this image. But before I get to this image, let me look down here a little bit and give it a little bit of background because I never talk about biology, but it's dope. So let me talk about it. So Dna, we all know what DNA is, right? It's the blueprint of life. All, all humans share 99.9% of the same DNA. It's that 0.1% difference that results in our, the way we are different. The results in Charlottesville and Oh, anyway, to, you know, I got to stay relevant here, you know, trending terms anyway, uh, but DNA is the blueprint of life from Dna Springs, everything else. And so genes are the recipes. So you can think of DNA as the cookbook. It's the book of all the recipes.

Speaker 1:          04:12          And the recipes are the genes, right? You have a gene for your hair color, you have a gene for your eye color, your gene for everything, right? And so DNA consists of genes and from these genes that make up the DNA strand come proteins and proteins make up the physical attributes that make up who you are. So, uh, right? So that's the, that's DNA. And those are genes. And so we could think of these genes as parameters for each individual. So each individual is like, has a set of genes or parameters that adapt over time based on how they breed. And so all life on earth has sprung up this way through Darwinian natural selection. The idea is that usually species will overpopulate, they'll create more than necessary to survive. And then there's going to be variation amongst all the individuals of the species. This, this guy's skin color will be ground.

Speaker 1:          05:03          It's kind of skin color would be why this guy's going to call the way black, all sorts of different people. And then what happens is selection. So everybody's going to try to reproduce. I mean that's the point of life. If you think about it at the, at the low level or at the basic level, I mean there, there are other points of life. Like it doesn't just have to be about sex, it's going to be about social impact. You make your own meaning in the end. But I digress anyways, everybody tries to breed, but the ones that uh, whose children are the most fit are the ones who get to survive or the ones who are most likely to survive. And the way that nature does this is it lets it, it, it finds those that are most fit by some measure of fitness and the real world.

Speaker 1:          05:45          It would be brute physical strength and it, those genes are then more likely to be passed on to next, the next generations. And so that's adoption. So like the idea behind which now go back to this genetic algorithms are based off of, so we initialize, so the first step is initialization. So we'll create a population whether that's space invaders, whether that's different solutions, possible solutions to some train route optimization problem, like different routes and then those routes evolve. But anyway, we initialize some population of of of solutions possible solutions and then we assign each of those individuals a fitness value by some fitness function that we decide what it's, it's very problem specific as well. Like based on the problem, what is the, how fit is this individual or solution you can call it as well. And then we select those individuals that are the fittest and then by some measure of you know, what that fitness is and the easy case, we can just think about it.

Speaker 1:          06:50          Fitness as outputting just a single scalar value, right? For each person. And then we just choose those individuals that had the highest fitness level and that highest fitness level could be, you know, it has to be greater than 10 or else they don't get to breed. And then we choose all those. That's just selection process. And then there's crossover or mating or sex if you want, you know, whatever it is. And uh, right. So they reproduce these jeans. Why am I laughing? Cause I said sex. I know. Oh my God, my uh, so these genes reproduce. That's the whole point, right? That's how you came out. That's how I came out. Oh okay. So then they crossover and then the fittest ones, those are the children. We then the last step is mutation. We take those children and we add some, we add some kind of mutation to them so we can multiply them by some random distribution, like a golf, Sian or you know, whatever else.

Speaker 1:          07:45          And that's, that's how that works. So let me go back to this. Okay. So then we mutate them. And so the reason we mutate them, so there, there is some variation. Right now it doesn't necessarily mean that the genes that are passed on are the optimal gene values. Like they could be better, but we know that they are the best of the type of genes that we've been given. So we could take those best of what we've been given and if we mutate them, we opened up the possibilities of there being better genes out there that weren't even from the parents. Right. And you see what I'm saying? So that's why we vary them a little bit. We had some kind of variational probabilistic aspect. I'm doing this because I'm talking, I'm thinking about distributions, right? And also in terms of crossover, uh, there are different ways of crossing over parents.

Speaker 1:          08:29          You could add these to scalar values together. You could multiply them, you could multiply divide by two and then square it. You know, it depends on what you define by crossing over. And once we meet some stopping criteria, uh, then we, we, we end the game. Like let's say, you know, we want the solution to be x amount so it will measure how good it is. And so in our case, that's going to be having a hundred invaders. That's the stopping criteria. But if we haven't met it, then we just repeat this process over and over and over again. All right, so that's that. And, uh, now we're going to talk about the use cases. So, okay. So most of the advances in machine learning have been due to gradient based optimization. As long as we can compute some gradient value, we can compute how best to update the weights of our network, the parameters of our network, right?

Speaker 1:          09:13          Whether that's through supervised or unsupervised learning, clustering, classification generation, you know, variational auto encoding, all of these things are based off of having a gradient value that we can then update our, our weights with. But in this case there's no gradient value. This is a totally different paradigm. There is no linear Algebra and there's no calculus involved. There is just Algebra, like performing the crossover and then performing the mutation. It's like multiplication, addition, subtraction, basic operations and then probability. And the probability is the mutation as well. Like you know, it's, there's a probabilistic aspect to who gets to reproduce and what those mutations look like. So there's only probability and Algebra. Whereas in gradient based optimization, where most of the advances in machine learning have occurred, there's calculus and linear Algebra and probability theory and statistics. So it's an easier way of thinking about it.

Speaker 1:          10:08          And it's not necessarily as a, it's not necessarily as efficient when it comes to certain use cases, but these genetic algorithms are used in real world applications. One of them, one example is for relational databases like posts gray or h two, they select the best query plan by the, which is the one with the lowest estimated cost. They're using finance a lot for stock price prediction, um, for portfolio optimization, evolving design. So computer aided design is a great example where you have some idea of what the solution should be. You don't know exactly what it is, but you have some kind of base design, whether that'd be a cad model, like a three d cad model or a set of rules to conduct some kind of experiments. And you can evolve these roles over time, uh, so that they get better and better. And so this is used in evolving cad models in engineering, wind turbines and things like that.

Speaker 1:          11:06          Things that you would design, which is a really cool field and it's very closely related to generative generative modeling, uh, from grain based optimization. Like generative adversarial networks and variational auto encoders where you generate new data. It's kind of similar to that. It's in the same kind of subfield computer aided design. So those are two use cases, although right, you don't, you don't see these, you don't see like the top researchers at deep mind or open AI or you know, anywhere posting, uh, papers on genetic algorithms. It just doesn't happen. Uh, but I still believe in them. I still believe in them and when to use this, if you have a huge search space and you're not really sure what the ideal solution should be, like computer aided design, it's a very creative, open ended solution, then that would be a good, um, uh, this would be a good solution to that problem.

Speaker 1:          11:54          And so whenever you have a multidimensional search space is just a huge search space and you don't even know what the deal is. Okay? So that's the high level of what genetic algorithms are. Now what I'm gonna do is I'm going to go over the code for this game. It's very doable and it's all going to be in python. The only parts that I'm going to code are the three main parts and the three main parts are selection, crossover, and mutation. So those are the parts I'm going to code. The rest of it we're going to go and just glaze over it and I'm going to talk about what's happening there. So there are four different classes here. There are four different classes and we're going to start at the highest level class, which is just this right here, this 30 lines of code, the main code, and then we're going to eight her of like go down the hierarchy of functions to we get to the lowest level, which is evolution would that, that is where the real evolutionary code is happening.

Speaker 1:          12:45          And that's where I'm going to code some parts. All right, so let's start at the high level. So we have four dependencies here that we're going to importantly make this really big for us so we can really see what's going on here. All right, make it bigger. Bigger is better as they say in, as I say. Okay? So for for dependencies, SGE is a wrapper around pie game. Now Pie game is the most popular game building library in Python and SGE you pronounce it sage is a wrapper over pie game, which makes it even easier to use. However, like with all rappers, because there's a layer of abstraction, the trade off is you don't get as much control over the details. Um, but we're not going to talk about, you know, the details we were, we're building a very simple game. And so SGG SGE is essentially pie game, but wrapped to a higher level game is our objects that's going to contain the game logic.

Speaker 1:          13:38          Objects are, are the player and the invader class that will define as well. And [inaudible] is just for, you know, operating system functionality, right? So in our main function, here's the highest level of the code. So first we're going to define where the file is and then we'll create the game object. So when we, when we initialize invaders game, that's just going to set some basic parameters like the clock time, uh, whether or not there's a game over, which there's not going to be when we start off de and some other things. But these are just games specific parameters, not player or invaders specific parameters. Those are objects. All right, so then we'll initialize the game and then we're going to load up the background. And by the background I mean the color of the, the back of the game, right? Let me just show it over here.

Speaker 1:          14:22          So the color of the back of the game, I'll, I'll keep going back to this by the way. Right? So we want a black screen and so that's what we're doing here. We're defining a black screen. We have a wall height, we have a resolution and we call it wall sprite. A sprite is like a a figure, right? And animation. But the way we're just going to call the background a wall sprites as well, and we'll set it as a background layer and we only have one layer. So it's just setting the background layer to that wall. Sprites as a rectangle that we draw. Once we have that, we'll add it to the background. So we take our background layer that we've initialized and add it to the background. And so that now we have a black box for games so far, and now we have a background.

Speaker 1:          15:01          Now we'll initialize our objects. We have a set of invaders, so we'll start off with six of them. So we say let's, let's create and initialize an invader six times and we'll store them all in this invaders, uh, array or list. And then we have our player with just one that's us. And then we say the player is always the first objects. We take both of them and we add them to this object or ray with the player being first. So it's an we're initialized before the invaders are. And then we start the game. Well we don't start the game, we initialize a session of the game. And so this is kind of like the pie game specific syntax of like, you know, syntactic sugar, it's like intentional level where you initialize a session and then you run the computation graph. So we initialize this session here with the game room function, giving it the background that we defined.

Speaker 1:          15:46          And the objects are player in the invaders. And then we were moved the mouse because we don't want to see any of that. We have, we're focused on are invaders in our player. That's it. Right? And then here we go. We start the game. Why would we initialize this session? And then we start the game. And that's it at a high level, right? Very easy stuff. No, no evolutionary anything. Know anything really too easy, almost. Right? I know. It's too easy for you. You smart, you smart person. You all right? So all right. Anyway, where were we? Uh, right. So now we're going down a level of hierarchy. We're going down one, we're going to objects. So for objects, we define our invaders, right? So we, we define our game and we define our classes. So now let's define those objects, those, those entities inside of the game.

Speaker 1:          16:30          So our first entity is going to be our invader. Now how are invader is the one that is the individual that will breed and crossover. You know, all this, you know, mutation. All of this evolutionary logic will be applied to this invader. So let's, let's, let's define what this invader, uh, what the attributes are. So our first step is going to be to define the genes, the genes for the invader. So when I say attributes, this is what I mean. The first one is going to be size. And so these are key value pairs stored in a dictionary, okay? These are key value pairs. So for each of these genes, we are going to store a minimum value and a maximum value. And we're going to have some generated a random number here. So we're going to be able to say, let's generate a value for this individual, for this gene.

Speaker 1:          17:16          And it's gotta be between the Min and the Max. And if it's smaller than the men or it's greater than the Max, then we're just returned the men or the Max respectfully. But you can't generate the value for this gene for any individual that's beyond the scope of this min and Max value, right? So we'll do that for the size of them, right? So it's, the size has to be between one and seven the color, right? We have colors on a scale of zero to two 55 but our main is going to be five. Our speed between 0.01 and five are why velocity or x and y velocity, our speeds in both directions, axes, and then our probability of changing directions in both the x direction, x direction and the y direction up and down, up and down, up and down wavy hair. I got my hair dyed silver again.

Speaker 1:          18:01          Yes. Oh my God, it was so long. I'm so happy to have this silver again, back to this, back to this, back to this. Okay. So we have those genes and now let's look at this next function, which is to generate some jeans for an invader. So whenever we initialize an invader, this generate gene function is called right here as it set of attributes when we initialize it. So let's look at what this code looks like. We're going to use that generated number like we define over here to define, uh, what this is going to be like. Write a value for the specific gene. So we know what the Max value is and what the min value is, and at the generated number is less than the men returned them in. If it's greater than the Max returned the Max else return the generated number.

Speaker 1:          18:42          And so that's how we, that's how we generate genes for each individual in this function, right? So when we, when we, when we initialize an invader like we did over here, we said let's initialize six of them. When we initialized an invader, this is the logic that's being called, right? So first of all, we'll generate some random values for its genes and store them in the attributes. And then we'll set the generator genes for this invader. In terms of genes, that's just, you know, jeans are the attributes. Same thing. And then we'll set it sprite animation, which is that like, uh, now robot looking dude, that was, what was it? This, this thing, right? It's not game over. The game isn't over till I say it's over or til we say it's over. Okay. Press enter. Ready. Steady go. He, come on, come on. Jean.

Speaker 1:          19:28          There we go. Such a fun game, right? So his, his little sprite animation, this like little character thing here and it's just a, it's just a PNG. It's just an image, a static image that we're setting here using the, the beauty of SGE that just lets us, you know, magically set these, uh, sprites for an object that we declare. And then we're going to pull these values from the gene. So we have these generated values and they're all stored in this genes list, but we'll also have individual, uh, variables for each of these gene values. Just cause it's easier to call later to get to pull later on. And we'll set the width for the image and the, and the height, the scale, and it's going to start off with zero. In terms of his fitness score, we don't know how fit it is yet because it was just initialized.

Speaker 1:          20:11          So we'll initialize that value as zero, zero to hero Hercules. That I would just saying that I try to keep it interesting anyway. Uh, right. So we have those values and now, okay, so here's, here's, here's something really cool. So notice this function right here. Events step. You're like, okay, events step, great. What this, what this does is it uh, in one. So there are events, right? So every step or time step in the game, there's a series of time step, you know, every interval. Like does it [inaudible] it was always time, steps in machine learning and so at every time step do something, right? So what is that that uh, this invader is going to do? What it's going to do is it's going to increase its fitness score by one because the longer it's alive, the more fit it is. That's what we're saying.

Speaker 1:          20:58          That's what our fitness chorus, there's more to the fitness score, um, that I'll talk about in a second. But that's the kind of the basic idea. But because this, this, this, this invader has survived a single time step. We're going to increase that fitness score by one. And so then we changed directions randomly. So we'll still, we'll initialize some random value and say if it's less than the probability of changing directions than change the direction else, you know, for, for both x and y, then we have logic for bouncing off the edges and the wall, all four sides up, down, left and right. Okay. So that's all it does is it computes movement. Like where should this invader move in this time step. And so that's how the invader is just moving randomly all over the place. But it's not just moving randomly, it's moving randomly, but based on the genes, like what these values of these genes are.

Speaker 1:          21:44          So you see how it's movement is dependent on the jeans, right? One gene would be x probability one gene would be the why probability, The v x velocity, the Wiva la city. Okay. So, okay, so here's the interesting thing. So you're looking at this and you're like, okay, so this happens at every time step. When is this function called? So you'll look at this, you'll copy it, you'll control app, you'll try to find where it's, where it's called. Well, this is just the, this is just a duplicate of it. This is not called there. This is another duplicate. Where's this thing called? So the thing is, it's not called anywhere. There are event listeners. So that's, that's another thing about a SGE or sage with pie game. You have event listeners because if we were to call this, we would just have like a while loop, right?

Speaker 1:          22:25          Because we'd have to call it continuously throughout the whole game. But we're not going to do that. Why should we do that? Uh, we're just going to have these event listeners and they're built into Sgg. So what I'm saying is these functions are going to fire every time there is a new time step by themselves kind of auto magically. It's built into the framework. It's kind of like ios or android programming. If you've ever done mobile developments, you don't want to just, you're not, you're not manually constructing event listeners for all the actions that a user can do. Swipe up, swipe down, tap, you know, two fingers, three fingers. You have those that listeners, uh, that are a part of the core framework that are going to fire whenever a user does that action. So user swipes up, which would fire. So if you're, if you're to put a breakpoint inside of that function and the user swipes up, the breakpoint would catch that action and then you can execute whatever code you want to.

Speaker 1:          23:19          And it's very useful for mobile developments. And it's also very useful for game development. Having event listeners built into the framework so we don't have to build them. So we can just say events step is going to be this. And the reason we can say this is because this class inherits from the ste, a DSP object class. We're overriding these functions, right? So that's, that's it for our invader, right? That, that's the basic logic of, of us defining what those genes are and then logic for moving and for generating, generating those values for each gene. Okay, so in a single time step,

Speaker 1:          23:56          now let's define it for the player, right? So when we initialize a player, we are going to say, okay, we can only move in two directions left or right, that's it. So we'll define maps for both of those keys and then we're going to say, okay, what's the starting position? What's the sprite image? Right? And that's it for our initialization steps. Then we can go to our events step. And remember this is called every time step of the game. So we'll say, okay, first of all, let's capture the direction entered by the player, whether it's left or right. And we'll put that in the key motion variable. We'll find a speed in the x direction and then we'll animate the sprite according to the moving direction, right? So if we're going left, then move the image this way, if we're going right with the image this way, that's it.

Speaker 1:          24:35          And then we keep a panel inside of the window, right? So then we were never outside of the bounding box on both sides. We want to keep the player inside of that bounding box. And so whenever the player shoots, right, whenever the player shoots, we're going to say, you know, whenever the space button is pressed, the number of invaders must be higher than the minimum allowed and a number of bullets lower than the maximum. And only if that's the case, can the player fire a bullet? So these are, uh, parameters for which for when we can fire a bullet or not, which means we have one more class and that class is the bullet itself. So like that little bullet that's traveling when the, when the player shoots. So we'll animate that using this sprite function. It's that lettuce, a little fiery little image we'll set that will set it speed, which is going to be the starting speed that we define as a beforehand. And then we'll say in the event step, which is happening at every iteration, either destroy it or if there's a collision, then, uh, kill that invader, whoever it touches. All right? So that's where objects class.

Speaker 2:          25:35          Okay.

Speaker 1:          25:36          And now we have our game class. And so in our game class we'll say, okay, we've got our game engine, we've got our uh, player, an invader objects evolution, which I'll code into second or time and then our clock. So then we have a bunch of, uh, global parameters here for the resolution, for the position of the objects for how, uh, how the number of milliseconds between generations, like 5,000 milliseconds or five seconds. I had the minimum generation time as well as like what's the Litho lower limit that we want it to be, the number and invaders for and the Max 100 minimum for Max hundred. So in a game class, which we initialized right here, what happens here? Well, like I said, we are initializing a bunch of these game specific parameters. The Hud, which is the score and the timer, whether or not to game over very basic stuff.

Speaker 1:          26:25          The clock. And then we have some basic code for the Hud, which is not, you know, I won't go over that. And then a new generation. Okay, this is, this part's interesting. So, so we'll generate some new invaders and then we'll reduce the time between generations, which makes it harder for the player, right? So that's what we had this minimum value for generations 2000 because the time for generation between generations will decrease every time step. So it gets harder and harder. And then in an events that for one full game, well first calculate the number of invaders on the screen, show the score. And if it's more than our threshold, it's game over. We're done, we're through our, the Jig is up. Uh, the GIG is up. But if, if it's over our threshold, then it's time to breathe again. So we'll create a new generation, right?

Speaker 1:          27:09          And so, but if it's for, if it, if it's, if, if, if there's four invaders on the screen and we're trying to kill one of them, we can't do that. So we'll draw this immunity bubble around them, which means that you just can't kill them until more are generated. So that's kind of our way of saying this is the minimum number of invaders we'll have key prices for, you know, escaping and for, for pausing the game. Um, and so, okay, so this is this an interesting step. This is where the animation for how crossover is happening. Happens right here. So whenever, so every five seconds, the game pauses and then those invaders will, we'll breed. And then, uh, so what's happening is we'll say recombinase, which is the crossover step to create those chill child jeans and add the new individuals to our current list and then reanimate.

Speaker 1:          27:54          Okay. And so then for key pressing in for event closing. All right, so now let's get to our good stuff. The real, the real, the real meat of this code. So before I get to these three things, let me talk about the bounding interval for the genes. So we always have some downing interval, like it's gotta be between this, this scalar value in this scalar value. So this is where the crossover and the mutation is happening and this is where the selection is happening. So those are the three really key aspects of of how this works. We'll, we'll create an analyst for the offspring that will store the values in for all the, for all the children. And so for each pair of parents, right? We're giving it parents as the parameters here, we're going to say, okay, so for each pair of parents, let's go ahead and create an empty store for the offspring's genes.

Speaker 1:          28:36          So we'll say, okay, so the for the genes of each child, for these, this pair of parents per each gene from the key value pairs, remember it's a dictionary that these gene values are stored in. We're going to store both pairs as gene attributes. Okay? So for both parents, we're going to compute what those genes are that we want to give to our children as values and we're going to randomly generate the Cha, the child genes attributes. So for the children, the, for the, for each child genes in this, Jen is going to be the index. For this specific child, we'll use a uniform distribution to compute what the values should be. So we'll say, okay, min values and then Max value. So it's going to be a distribution between the min and Max values for this gene.

Speaker 1:          29:26          And then we'll randomly decide if it's time to mutate the children. So if, if it's so generate some random number and then if it's less than the mutation probability, then we'll go ahead and mutate. The children helps. We won't. So this is, this is how we select, uh, whether or not we're going to mutate. The children are not right. So Emar mutation probability is 0.1. So it's got to be less than that. So we'll say, okay, so the first get the Min and the Max values for the parent. So the Min and the Max value is part of the parents will say Jen men. And then we have for the, the Max value for the parent will say, Jean props, Gen Max, all right. And then we'll get the value for the child and the child is going to be that same index and now it's time to mutate. So for mutation, here's what it looks like for mutation. So, so basically for this mutation step, we're introducing new genetic material into the population by replacing one parameter in the genome by this random value within the allowed range. And then once we have that, then we can go ahead and return. We can go ahead and add the children to the store. So offspring dot append and then the children gene. And then finally we'll return all of the children, paternal offspring.

Speaker 1:          30:57          And this goes right here. Okay, great. Right? So that's for a crossover and mutation. That's how we were crossing over. Parents, uh, were saying we're taking these values from both parents and using those values for those genes to help compute this child gene. And then we're mutating the child, Jane, right? Using this a random normal distribution. So that's crossover and mutation, and then their selection. So all of these children who gets to reproduce, so for all the members of the population will sum up all of their fitness scores. And then we'll say, okay, so we'll randomly generate a distribution. And then for each invader, we'll subtract its value. That's fitness value from the randomly generated number. And if it's less than zero, then that invader gets to breed. So here's why. Here's why we're doing this. So you might be thinking, okay, so why couldn't we just compute the fitness for each individual and then say, whichever you know, however long it's alive, we'll just keep incrementing that fitness value.

Speaker 1:          31:54          That's scale, scalar, single value, and then the ones that have the highest fitness scaler, why don't we just choose those? Why do we have to add this random value? The reason we're adding a random value here is because, um, the ones with the best jeans and the immediate term doesn't necessarily mean it has the best jeans in the longterm. So if we add some kind of variational or probabilistic aspect to it, then that allows for, um, different possibilities, right? It means that these jeans right now where the best ones, but let's add some variation to it just in case there's other possibilities out there. Do you see what I'm saying? So by adding a variational aspect to selection, it's, it just improves how we evaluate the fitness for each individual. And so that's, that's it really for this. And then we had this meeting Paul and tournament, but that's just for, that's just for printing out to terminal.

Speaker 1:          32:42          So that's it for this code. Uh, if you liked it, please check out the get hub repository. I've got all the instructions in the details in there. Definitely try out a genetic algorithm on your own. They're very simple, very easy to understand. You don't need to know backpropagation or calculus or linear Algebra. Very simple stuff. You can easily implement them in pie game and open AI's Jim and open AI's universe. There's a bunch of possibilities and if you do this, then it's just going to increase your confidence as a developer, as a machine learning engineer, as a data scientist, whatever it is. So thank you for watching. I love you guys. Seriously, I do it for you and if you made it this far, I'm very proud of you. Thank you. And I'll tell you a little secret. Something big is coming up and only you get to know that because you made it to the end. I can't say what it is, but something big is coming up before the year ends. For this channel is going to be amazing. All right, so that's it. Please subscribe for more programming videos, and for now, I've got to evolve my hair, so thanks for watching.