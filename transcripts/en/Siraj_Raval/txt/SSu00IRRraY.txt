Speaker 1:          00:00          Oh world. It's the Raj. In this episode, we're going to build a stock price prediction graph using [inaudible] in 40 lines of python. Have you ever wanted to get rich quick, sir? My models are very profitable. I always retrain them to prevent over fitting three times a week. Those are rookie numbers in this ragged. Really? How often do you retrain? I'm going to have to work workout and then once, right if your lunch. Oh, the stock market allows you to buy and sell units. The ownership in a company which we call stocks. If the company's profits go up, you own some of those profits. If they go down, you lose profits with them. It's as simple as that. So if you were to buy stocks and the right company at the right time, you can become rich overnight. Is there something we could do to predict future stock prices given a Dataset of past prices?

Speaker 1:          00:48          Machine learning. This sounds like a data science problems, but according to the efficient market hypothesis, the stock market is random and unpredictable, but major financial firms like JP Morgan and Goldman Sachs having been hiring quantitative traders for years to build predictive models on past market data and you can be sure that if these firms do have profitable models for trading, they are not going to share it with us. Come at me Wall Street, they have no incentive to think about all the features we could incorporate into a financial model. Sentiment analysis on company opinions, past stock prices, sales growth, dividends, all the profits. Warren be missed for hating on bitcoin. Changes in stock prices are not completely random but very close to it. Good traders will use predictive models as a tool when deciding where to invest and we're going to build three different predictive models that predict the prices of apple stock.

Speaker 1:          01:41          Then plot them all on a graph to compare their results are steps we'll be doing staller dependencies, collect our Dataset, right our script and analyze our graph. These are our four dependencies. CSB will allow us to read data from the CSV file of stock prices that we later download. Num Py will let us perform calculations on our data side, can't learn. We'll let us build a predictive model and map talk live. We'll let us plot our data points with our models on a graph for us to analyze. Let's collect our data set. We want to list of stock prices from the past 30 days and we can get this data easily from Google finance. As you can see, it'd be much higher if they didn't miss the boat on Ai. Next step, write our script. Our for dependencies are here at the top and we'll use the given names to reference them throughout our code.

Speaker 1:          02:23          One thing to note about map plot line is that since it's a graphical library, it'll depend on a graphical backend and there are several options. If it doesn't want apply to graph on your machine for some reason, just use the switch backend option and try out a few different possible backends. All right, let's start hacking on our script. First, let's initialize to empty lists, dates and prices will then write a function called get data that will fill them both with the relevant data. We'll call it get data and its argument will be the name of our stock prices CSB file. We'll use the width as blocked to open our file and assign it to the CSV file variable. The open statement. We'll extract the contents of our CSV fall to read it, hence the our parameter. Next we'll want to create a file reader variable, which the CSV module will create for us using the reader method with our CSV file as the perimeter.

Speaker 1:          03:09          This will allow us to iterate over every row in our CSV file and we can return a string for each line. Using the next method. We'll call the next method first to skip the first row, since it's just column names. Now for each row in our CSV file reader, we'll add both the date and price values to our respective lists. The upenn function will allow us to add an item to the end of our list. We only want the day of the month, so we'll say get that first column in our row, which is that the index zero and use the split function to remove the dashes between each of those three values. Then get that first value in the list, which is the day. We'll wrap that using the into keyword to convert the day to an integer for prices will append that list as well with the opening price, which is in the next column of our row and convert that to a float to be more precise in our later calculations.

Speaker 1:          03:53          Okay. Not that precise. Well place the return statement at the end to finish our with block. Let's move on to our second and last helper function called predict price. To build our predictive model and graphic, well first use num Pi to format our list into an end by one matrix. The three parameters will be the list we want to reshape the new shape, which will be a one dimensional array. The size of our dates list, and finally the order of elements. Let's create three models. Each of them will be a type of support vector machine. A support vector machine is a linear separator. It takes data that's already classified and tries to predict a set of unclassified data, so if we only had two data classes, it would look like this. It would be the line such that the distances from the closest points in each of the two groups would be farthest away.

Speaker 1:          04:35          When we add a new data point to our graph, depending on which side of the line it is, we could classify it accordingly with the label. The right now we're not predicting a class label, so we don't need to classify. Instead we're predicting the next value in a series, which means we want to use regression. SVMS can be used for regression as well. The support vector regression is a type of Svm that uses this space between data points as a margin of error and predicts the most likely. Next point in a Dataset, let's create our first model, a linear support vector regression. We'll use the spr module we imported from psychic learn to create it and it's going to take three parameters. The kernel, which is a type of Svm. Then our penalty parameter. See of the error term we want to things when using an SVR aligned with the largest minimum margin and align that correctly separates as many instances as possible, but we can't always have boats.

Speaker 1:          05:23          See determines how much we want the ladder. Our next SVR is Paula. No meal in math folklore. The no free lunch theorem states that there are no guarantees for one optimization to work better than the other, so we'll try both. Also, if you work at Google, you actually do get free lunch, so take that. Finally, we'll create one more SVR using a radial basis function. RBF defined similarity to be the Euclidean distance between two inputs. If both are right on top of each other, then that similarity is one. If too far it's a zero. Our gamma defines how far too far it is and let's fit or train each of our models on our date and price. Using the fit method, it's time to create. Our graft will plot the initial data points as black dots with the data label and plot each of our models as well.

Speaker 1:          06:05          We'll use the predict method of the SVR object in psychic. Learn using the dates matrix as our parameter. Each will be a different color and we'll give them a distinct label. We can set the x axis and the y axis accordingly and we'll add a title and a legend. The show function. We'll display it on the screen and want to return the predictions from each of our models. Now we can call our get data method on our CSV and create a variable to store our predicted price given our dates and prices for this date. Well printout results for each of our models to command line. Let's analyze our graph. We can see that each of our models shows up in our graph and that the RBF model seems to fit our data the best so we can use its prediction in command line to stack dead presidents.

Speaker 1:          06:43          So to break it down, the efficient market hypothesis states that the data needed to set the prices for tomorrow. Stocks only come from tomorrow, but well tuned machine learning models can give us predictions that are slightly better than random if we use the right data and support. Vector machines are a type of ml model that can be used for both classification and regression to predict novel data points. Intergraph graph. The winner of the coding challenge from last week's video is victor. See Ronna Vic, you're created a system that recommends artists to users using the last dot. Fm Music Dataset that asks of the week, and the runner up is Kevin Nelson. He demoed his own recommender algorithm. The challenge for this video is to create a financial model to predict stock prices with a neural network using both price history and sentiment analysis. As features details are in the code, read me, post your, get humbling in the comments, and I'll announce the winner. In the next video, please subscribe for more programming videos. And for now, I've got to predict snapchat's IPO price, so thanks for watching.