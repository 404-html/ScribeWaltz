Speaker 1:          00:00          Go check out my friend Ryan. Shirley's youtube channel has some cool magic videos. Hello world, it's Saroj. In this video we're going to talk about perhaps the biggest unsolved mystery in all of computer science. What are those? Couldn't resist. Does p equals NP, PA and NP both represent a class of decision problems? Do these two line segments have an intersection or can we beat the game of Pong and under three minutes or given a Rubik's cube? Can we always solve it in 20 moves or less? So let's start to define our terms. We'll start with the first class of decision problems labeled. P P stands for polynomial, which comes from the Greek phrase meaning many terms. A polynomial is a math expression that consists of is some of many terms like two x plus three or x cubed plus four x. And we can create strategies to solve any polynomial reasonably fast.

Speaker 1:          00:46          So p is the class of decision problems that we can solve in polynomial time, which means reasonably fast. An example of a p problem would be sorting, like can we sort of set of numbers and increasing order? Yes, and there are several known strategies to do this. Another set of examples are any of the basic math operations like addition or subtraction. We can solve these problems reasonably fast or searching given a set of numbers does it number five exist in it. We can solve that pretty easily by checking each number in the set, so that's the set of decision problems that we call p, but there's another group of decision problems that we call NP. NP stands for non deterministic polynomial, which Hazmat terminology for problems that we can check the solution too easily but not solve easily on NP. Problem example would be can a traveling salesman drive across a given set of cities and return back to his home city without running out of gas?

Speaker 1:          01:36          If someone proposes a possible solution, we could verify it instantly by calculating the amount of gas that will let him travel the given path in miles. But to find the absolute best solution, we would have to try every single combination of routes to find the shortest one, which would take forever to calculate. Let's look at what this looks like in code. Let's start by defining an empty list of routes. Then we'll define a list of paths between cities as a dictionary of dictionaries for each key, which is defined by a city initial. We'll have a set of key value pairs which defined the distances between one city and another as an integer. Now that we have our two variables defined, let's write our function to find the shortest path. This is what our function will look like when we call it our starting city is RV.

Speaker 1:          02:17          No, it stands for river city. Okay, so let's add that to our empty list. Now we can calculate the path length from the current city to the last city. By looking up the distance in our dictionary, we'll check if our path contains all the cities and isn't a dead end with our if statement, and if that's the case, we'll add the total distance and path to our routes list. We've done this for one possible path. Now let's do it for all possible paths. Using this for loop, we'll call this function inside of itself to find paths for all possible cities. Not yet used. This technique of calling a function inside of itself is called recursion. It'll show us the shortest route in terminal when it's done in no time since the list of cities with small, but for larger numbers of cities, this would take way too long to calculate it.

Speaker 1:          03:00          So instead of trying to find the absolute best solution routing apps like Google maps instead estimate the best path using different techniques, which is way faster. Another example of an NP problem is scheduling. Let's say we have a set of courses at a school and we want to schedule a final exams during finals week so that no student has to take two different exams on the same day. Calculating all the possible schedules for say a thousand students would be a huge number that would take years to solve, but if we were given a possible schedule, we could check it easily by seeing if it gave any student more than one exam on a given day or what. If we wanted to find all the prime factors of a number, we could verify a solution easily if it was handed to us, but there isn't a way to solve it in a reasonable amount of time for huge number.

Speaker 1:          03:43          Any problem that can be solved easily. It can also be checked easily. All p problems are always NP, but can any problem that can be checked easily like scheduling or prime factorization also be solved easily. Meaning are all NP problems always pee? That is the question. Does p equal NP and the answer is we don't know. There's also a set of problems called NP hard that are really hard to solve at least as hard as the hardest NP problems. I mean some of them can be verified easily, but others can't even be verified easily. They can't be solved or verified easily. An example would be the halting problem, which says, given some computer program and an input, will that program finished running at some point or will it just continue running forever? We can't solve that or verify solution to that easily. The only known way to check a possible solution like it'll just continue running forever is to wait forever.

Speaker 1:          04:34          That intersection though of problems that are both NP hard and NP are called NP complete. These are problems we can't solve easily but can check even though they're pretty difficult to check. An example of an NP complete problem is finding the longest common subset between two sets, so given two different sets of numbers. What is the longest common subset of numbers? Can't solve it easily, but we can't check the solution with some effort and p complete problems are the hardest NP problems to check. If we were to find a strategy to solve any MP complete problem in reasonable time, then we could use that same strategy to solve any NP problem in reasonable time. It would prove that p equals NP, that means there would be a single strategy that could solve any problem. One Algorithm to rule them all. Proving p equals NP is the million dollar question.

Speaker 1:          05:18          Seriously, the clay institute is offering a million bucks. Whoever can solve it. If p equals NP were true, it would have profound effects on society. It would mean online security systems would all be vulnerable to attack because our current inability to efficiently factor huge numbers, an NP problem forms the basis of modern cryptography, which everything from national security to banking depends on. It would also mean that we could make everything more efficient. Transportation Schedules, production cycles for manufacturers, protein folding simulations, which would effectively solve cancer. All of it would be optimized to be faster and cheaper. It would mean Harami and would come back to life.

Speaker 1:          05:57          Oh, it doesn't hush. On the flip side, if someone were to prove that p doesn't equal NP, it would be proof that there are some problems that no amount of data expertise or intuition could solve. But unlike the other sciences, computer science is only 60 years old and because of that, I believe there is still a possibility that p equals NP. We just haven't found the right algorithm. Anything is possible. So to break it down, but p equals NP problem asks if, because we can easily check an answer to a problem, does that also mean we could solve it easily approximating an answer to NP problems? Let's avoid the huge computing requirements to find the optimal solution like in the traveling salesman problem and if someone were to solve p equals NP, it would mean we could solve any problem in a reasonable amount of time, which would be awesome.

Speaker 1:          06:40          The winner of the genetic algorithm coding challenge from the last video is Nicole Rigby. She asked what the average global temperature would be in five years using the given climate data. She found an optimal solution estimate using genetic programming and documented her process in the read me with really cool visualizations that ass of the week and the runner up is nick van holes. He thought of a bunch of interesting questions to ask about the data and documented them in to read me. The coding challenge for this video is to prove that p equals NP. No, I'm just kidding. The challenge is to write a script that estimates a solution to the traveling salesman problem. Instead of trying every possible path details are in the read me posts or get help link in the comments and I'll announce the winner and my video a week from now. Please subscribe and share this video. And for now, I've got to find the limits of computation in our universe. So thanks for watching.