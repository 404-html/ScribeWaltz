Speaker 1:          00:00          Yo check out my friend Daniel hocked ones youtube channel for some cool virus videos and coming to you straight from San Francisco. It's a world, it's a Raj, and in this episode we're gonna Learn how machines can learn to detect viruses. Then we're going to build our own simple antivirus script in python since 2010 the amount of malware that exists on the web has skyrocketed. Reputable antivirus programs like Norton, I'm sorry, I can't even say that with a straight face. Norton sucks. I have to constantly upgrade their systems to defend against new threats and it's not just the security systems that are getting smarter. It's the viruses as well. For example, polymorphic viruses encrypt themselves in a different way every time they infect a host machine, making them harder to detect a worm self so it can spread to other computers as well. Using a bandwidth and computing of every host machine and in facts along the way.

Speaker 1:          00:51          Right under your mouse, I mean knows maybe I should make a warm too. In fact a bunch of computers and use them as bitcoin miners. At its core, buyers detection is a classification problem. If we can train a program to recognize whether a piece of software either is malware or is not malware, we can delete it in a paper released. Last year, a group of researchers in Nigeria trained the cane nearest neighbor classifier to detect viruses on an android phone. TheK nearest neighbor or an algorithm pups solve a simple problem. Cancer? No, you haven't set a point in n dimensions given a new point, let's call it a query. You need to find the k closest points to that query. Canon finds those closest points, so it's great for finding similarities between say a set of documents and because it can find similarities, it can also help find anomalies.

Speaker 1:          01:34          In the case of this paper, the anomaly would be a virus. In order to train the classifier to detect anomalies and needed a set of feature vectors, representations of a clean machine, they ended up using for features, SMS texts, calls, device statuses, and running processes. As in they took a set of ds, labeled them as clean, so it was a supervised problem and train their classifier on them and model ended up having a 94% accuracy, pretty good results. A more fresh approach from three months ago was aimed specifically at detecting botnets on android phones botnets form a distributed network of inducted machines and utilize their computing power for things like sending spam without the owner's knowledge. There are two approaches when it comes to malware analysis, static or code based and dynamic or runtime based. The static approach, it looks at software as it is on the machine at dynamic approach.

Speaker 1:          02:23          It looks at ongoing processes on the system. These guys decided to go for the dynamic approach. They use a neural net to train on a labeled Bot net dataset. Then it labeled an unlabeled data set as either bought net or not VOD net. They didn't took that labeled dataset and trained six different classification algorithms on it like logistic regression or random forest and a support vector machine. They found that a simple logistic regression got the best results. Who would have thought and they called this framework of mining features training a classifier and performing dynamic analysis, smart bond, extremely original. But let's talk about a super fresh approach. A paper released two years in the future. Just kidding. I can't literally see into the future yet, which release just a week ago that used BZ and classification to detect android malware. The first reverse engineered a set of clean android apps to map them into feature vectors like API calls, Linux system commands and permissions contained in the manifest file.

Speaker 1:          03:16          They didn't train their Basie and classifier on those features. These IAN classification uses Bayes theorem to measure the likelihood that an object is of a certain class using feature vectors as inputs. And the results in the paper showed way better detection rates than traditional signature based antivirus software. So there are many different ways to approach virus detection and as software eats the world, malware tries to as well. Viruses can use machine learning as well to avoid detection. So only one way to fight fire with fire. That analogy doesn't actually make sense, does it? So let's build a script in python that you just psychic learn to train a classifier to detect if a file is legitimate or malicious in learning that pie will import the necessary libraries. Pandas is for data analysis, not actual pandas. Sadly none. Pious for math pickle will help us save our learning features as a byte stream and psychic learn will help us build, train and test a machine learning model.

Speaker 1:          04:06          The first thing we want to do is load a data source. We have a CSV file on our local machine called data dot CSV that contains a labeled Dataset of PE files labeled as either a legit or malicious and their associated properties will then print out the total number of features per row. Then it's time for us to identify which features from our Dataset we will identify as important for our classifier. In order to do this, we use an extra trees classifier. This fits a number of randomized decision trees on sub samples of the data. Once we have our important features or print them out and sort them accordingly, then we'll want to create an array of models. We're going to test. Each model on our dataset using are extracted features as inputs and compare their prediction results. Whichever model has the best results is the one we will use to detect malware in our for loop.

Speaker 1:          04:50          We'll test each algorithm out, fitting it on our feature set. Then scoring the prediction accuracy or print out each score. Then calculate a winner by finding the highest prediction accuracy or print out the winner. Then save the algorithm weights and features to the classifier folder as a series of pickle files, so that's how we train our classifier. Let's see what it takes to write the main script. In our main method. We'll initialize a command line parts too. When we type in the name of this file, the argument will be to target file we went to classify as either malicious or legit. Then we'll load our classifier, the one we trained from our classifier folder as well as our features. Well then extract the byte stream from our input file and extract a set of features from it. We'll feed those features to our trained model and it will output a classification that we then print it to command line. Let's try this baby out on the command line by feeding at first a legitimate PE file, and now a known malicious pdf file. Malicious links through the codes in the description, and please hit that subscribe button if you want to see more machine learning videos. For now, I've got to go code up a girlfriend, so thanks for watching.