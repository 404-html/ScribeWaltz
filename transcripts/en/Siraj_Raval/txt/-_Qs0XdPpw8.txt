Speaker 1:          00:00          Hello world, it's a Raj and today I'm going to go over etherium. That is the second biggest cryptocurrency behind bitcoin that lets us do incredible things. The demo that I'm going to build in this episode is a decentralized conference ticket purchasing web APP. Let me show you what it looks like. It's very simple. You can buy a ticket, you can refund a ticket, you can create a wallet, but the only functionality that we really care about is buying a ticket. So if we have some ticket price, I can input some address. So that is my address and I can buy a ticket with the money that I have. And then the amount of registrants increases by one. It's a very simple web app that lets you buy tickets for a conference, but it's decentralized. What benefits is decentralized offer in this case? Very few benefits.

Speaker 1:          00:48          One, you don't have to worry about a third party taking a fee, so it's cheaper for both parties. And two, it's censorship resistant, which isn't that big a deal for a conference ticket web APP. But the point is to talk about etherium and learn how contracts and the model view controller architecture of Web apps all play together. Okay. So first of all, what is a theory them? So if [inaudible] is a platform to easily build decentralized applications using blockchain technology. So we know that bitcoin was the first blockchain application and etherium does two applications. What bitcoin did for money that is removes the need for a trusted third party. So for the Bitcoin blockchain, we had blocks and these blocks are just are just objects, right? That store data, it's basically the blockchain is basically a glorified the linked list. Okay. That store on everybody's computer and the etherium blockchain is very similar, except it's different in that what's stored in those blocks are not just transactions.

Speaker 1:          01:51          You can also store code snippets in those blocks, smart contracts. That's really the key bit here. Etherium is a programmable blockchain. While bitcoin isn't, well, bitcoin does have its own scripting language, but it's not as awesome or complete or capable as Ethereum's. And that's for security reasons. But anyways, you can build decentralized applications and you might be asking you a decentralized what a decentralized application looks. Kind of like this. It's a different stack entirely. So at the bottom we have a blockchain and a blockchain allows for a decentralized consensus over application level constructs. There are so many things in an APP that different parties need to agree upon. Is this a valid username? Is this a valid identity? Is this a valid address? Is this a valid reputation score? Is this a valid tweet? Is this a valid owner? Is this a valid owner of this data that you need consensus, right?

Speaker 1:          02:44          If we had a server, there's no need for consensus, right? There's no democracy, it's a dictatorship and the server controls everything. But in a decentralized application, we need consensus. And the blockchain was really that missing ingredient to reach consensus in a distributed decentralized way. So at the bottom of the stack is the blockchain in 2.0 means the theory on blockchain or any blockchain that allows for smart contracts. On top of that, we have a storage layer, right? Normally we use AWS, we use Google cloud. There are a bunch of service providers for storing your data in the cloud that are controlled by one entity, but in this case we would want a decentralized version of storage that is peer to peer owned by no entities and IPFS. The interplanetary file system is one great example of that. On top of the storage provider comes the smart contracts, so the smart contracts are code snippets that live on the blockchain.

Speaker 1:          03:39          They are decentralized computation while storage and content delivery is decentralized by IPFS computation is decentralized by the theory and blockchain smart contracts. On top of that, then we could start adding application level constructs, identity, reputation, attention, a eyes and on using all of this we can create ADAP or a decentralized application. It doesn't depend on any specific party existing and it's not about one party selling it's services. It's more about a network, a community of people who all share in ownership of some piece of software and so everybody profits and everybody contributes in some way. It's a more communal, more progressive way of building software that is emerging and will soon be the mainstream way to build software. What are some examples of Dapps? I'm sure there are a lot. There are, there are quite a few. Check check this one out. So way fund is one.

Speaker 1:          04:32          So way fund is a decentralized Kickstarter, right? We know how Kickstarter works. It's all about crowdfunding and way fund. Use a smart contract technology to let people crowd fund certain applications or projects or really anything like that. Uh, that's one example. Another one is all girl, which is pretty interesting because it's all about uh, forecasting, right about getting rewarded for your predictions and it's controlled by no party and it's, it's all publicly verifiable. All the bets, all the amount of funds, it's all publicly verifiable. There is no trust involved, which is a great use case. Providence is another one to providence is all about making supply chains transparent. If you're a business and you're getting some kind of uh, ingredient or some kind of tool from some third party company and you want to know what's in that and you want to know where it's been and who created it, instead of having to trust that company, you can verify all of that publicly.

Speaker 1:          05:28          On a blockchain because every product has a story. What a great tagline, right? That's some, that's some good marketing right there. But empowering the whole supply chain for everybody. It's a win, win, win, win situation. So great use case here, but there are lots, those were just three that I just kind of randomly picked. There's a lot and there's a lot more to come. So let's get to the architecture of etherium, right? So if theory them, uh, is it, it provides the consensus layer. Okay. So it provides both the consensus layer, the economic layer, and the blockchain services layer. So the bottom three layers, etherium kind of, Eh, it solves, right? So for consensus, like I said, we need some way to agree upon all of these application level constructs on top of the consensus mechanisms. We need some kind of economic token to incentivize all of these nodes to do the computation or do the storage or to do whatever is necessary, right?

Speaker 1:          06:22          And so that's where the crypto tokens come into play it. On top of that, we can start offering services, right? These are, these are, these are code snippet that actually do things, name registries, smart contracts, messaging, Oracle's distributed hash table for storing data. Right? On top of that we have interoperability. So in this decentralized world where we are just imagining all of these different apps and they all have their own tokens, how are you supposed to exchange value between all of these tokens silos? Well, the answer is to have a universal wrapper around all cryptocurrencies such that there is one currency that you have to deal with and you don't have to think about any other currency, whether that's your state currency or whether that's bitcoin or whatever it is. And under the hood, this protocol, this exchange protocol would transfer value or transmit value between all of these different tokens as you use different services, right?

Speaker 1:          07:19          So you can think of kind of a lay, a stack of decentralized API APIs that all use their own token. You pay this, you pay the top Api with whatever token you want, and it pays all the other Api APIs and the tokens that they require using this kind of decentralized exchange protocol, which you can just use in your app. And there's a lot of them. A stellar is a great one, the stellar protocol. But there are a lot. And on top of all of this, we have the browser, right? This is how we access the decentralized applications. Now, ideally the mainstream browsers that we know and love chrome, Firefox, Internet explorer, no, I'm just kidding. That one really sucks a opera. They would accept these decentralized protocols natively so we wouldn't have to create another browser and hopefully, and I think they will very soon.

Speaker 1:          08:05          But in the meantime, we have browsers that are made for decentralized applications like mist and Maelstrom and all of these other ones. And once we have all of that, then we can build dapps on using all of this technology. Uh, just scratch out store j though, because those guys had been vaporware forever, but everything else looks good. Open bazaar is dope and Dallas. And all of this stuff. But store Jay, come on, show, show, show us what you got, right? So like I said, we want to store the data in Ipfs, right? You don't want to store data directly in the blockchain because it's too big, right? Every miner has to download a copy of this blockchain, all of the transactions, and that includes code and whatever else is in those transactions. But if we're storing movies and really big files in the blockchain, that thing's going to get way too huge.

Speaker 1:          08:52          So no one's going to be able to download all of it, right? So the way to fix that is to store it in some distributed hash table like IPFS. What what IPF has gives back is a hash a content address for all of that content. And that is what we store in the blockchain, right? So we store it in a distributed hash table, get back to hash and store that Hash in the blockchain, which then points to the data storage, right? So in terms of the architecture, the etherium white paper is quite, is quite extensive and there's a lot happening here in this huge diarrhea. But let's go over it a little bit, right? So w the ethereum blockchain, you have blocks and these blocks are all linked together and inside each block is a list of transactions and all of those transactions contain state and other programmable parameters.

Speaker 1:          09:44          So what the ethereum blockchain does it store it on every miner's computer. It currently uses the proof of work algorithm to verify all to verify the entire network. And inside each of these blocks they run the computation that smart contract contained in each block. And then once that computation has been successfully, uh, done on each miner's computer, the whole network, we'll do the same thing. And then the majority of the network, if they can agree on the computation of that code snippet, it is then added to the blockchain as an immutable construct. So let's, so I mean there is so much that we could talk about when it comes to blockchains and, and all this stuff and in particular the theory and blockchain. But next week I'm starting this reinforcement learning course. So I, this is really the last week of blockchain stuff. Before we get into some reinforcement learning stuff, I'm going to keep my lips closed on that one.

Speaker 1:          10:40          But there is one thing that I do want to talk about and that is the Merkle tree data structure. So notice that inside of each block there is a, there is a tree, right? There is a Merkle tree. So it looks kind of like this. This is the Bitcoin blockchain, right? Like I said, it's a glorified singly linked list. It's got a pointer to the previous hash, uh, of the, of the previous block. It's got a nonce to ensure a novelty, right? A number only used once. It's got a timestamp and then it's got a Merkle route. So the Merkle root is the head note of a tree, a Merkle tree. So you might be thinking, wait a second, why can't a block just store a bunch of transactions as a list into one big block header? Why does it have to store it as a tree?

Speaker 1:          11:24          Well, the answer is if we just started all as one big list that would provide some, that would, that would cost them huge scalability issues. So to get around this, the Merkle tree data structure is used, which is a way to hash a large number of chunks of data together, which relies on splitting the chunks into buckets. And each bucket only contains a few, a few chunks. So it's Hash is all the way down the chain. And you could think of this kind of like a file directory, right? You have the root directory, you have child directories, and it just keeps going. And the reason we use a Merkle tree is because it allows for Merkle proofs, which consists of a chunk, the root hash of the tree and the branch consisting of all the Hash is going up along the path from the chunk to the root.

Speaker 1:          12:07          And so anyone reading that proof can verify that the hashing is consistent going all the way up to up the tree. So, uh, the Bitcoin, so the Bitcoin blockchain uses a very simple Merkle tree, right? And it's got these parameters, but the limitation of that Merkle tree is that it can't prove anything about the current state. That means who's holding some digital asset name registrations, the status of some financial contract. And so with the etherium blockchain does is it modifies that Merkle tree to store and store is not in stores, not just one Merkle tree, but three trees for three kinds of objects, transactions, receipts, which are essentially a piece of data is showing the effect of each transaction and state, which is the state of your code, right? It's a decentralized computer that can store state and they call this instead a Patricia tree, not a Merkle tree because it's modified to store state, which then allows clients to easily make and get verifiable, verifiable answers to queries.

Speaker 1:          13:12          Like tell me all the instances of an event of type x like that. An x could be a crowdfunding contract reaching its goal, et cetera. Right? So the Patricia tree allows for s two store allows a blockchain historic state. So there's a lot, right? So if we look at the ethereum get hub, there are so many repositories there, but really there are three key bits here, right? You have the etherium virtual machine, which calculates elements that run contract logic. Now this is kind of encapsulated by the etherium client. Then you have swarm, which is the storage layer, which we can just use IPFS for. And then whisper is for all the nodes to be able to message each other. And for that we can actually also use IPFS. So really all you need are etherium and IPFS. And so to run it theory and you can just download the client yourself, just like you would bid torrent or bitcoin.

Speaker 1:          14:03          And then with that client you can connect to the etherium network. You can explore it. The urine is blockchain runs, smart contracts, mine new blocks, the whole deal, right? So the, so the client is our gateway into the theory of network, whoever you are. And so if we, if we think about all of the pieces here, you have eith or ether, which is the inbuilt currency, it's the cryptocurrency itself. You have the ethereum virtual machine, which allows for decentralized computation like Heroku, IPFS and IPFS for storage and for communication. You have smart contract programming language and the really the, the one that we should care about his solidity, which is very similar to Java script and it's currently the most popular of them. And then you have the client of course, uh, uh, guests, which is in go, you have eith which is in c plus plus, and you have pie.

Speaker 1:          14:53          Each app which is written in Python, but the best one is go. So go was a language created by Google to handle distributed computing. They in fact upgraded from c plus plus to go. So because it was, it was more efficient for the sea, it was more efficient for computing on Google's huge distributed computing stack. So if Google uses it, you know, it's a good language and go is just a beautiful language. If you, if you've never looked at it before, I would highly recommend checking out go. It's really a beautiful language that it's, it's pretty new. Uh, it was designed with a lot of the elements of distributed computing. And even the centralized computing in minds, it's currently the ethereum client that is getting the most activity and it's just, it's just great practice practice because I think we're going to start saying a lot more artificial intelligence is and a lot more, uh, fundamental architectures being built with go right.

Speaker 1:          15:47          So death is the one to, to, to look at. And then you've got the smart contract languages. Uh, you've got lll which is kind of like lisp, which no one uses a serpent, which used to be similar, which is similar to python. And then solidity, solidity, which is the most popular and it's very similar to javascript and it's the one that we'll use. So there's a workflow for deploying smart contracts. The first step is to download your ethereum node and then you will write your solidity code and then compile it, usually using a framework like truffle, and then you can deploy your contract to the network. And then once you've deployed your contract to the network, then you can call that contract using web three dot. Js, which is the front end client that speaks to the ethereum blockchain. Right? So the idea is that, you know, when you're writing these web apps, you have this model view controller architecture, right model view controller, we're all familiar with that.

Speaker 1:          16:42          It's like ruby on rails uses it and angular and all of these apps. So in all these software stacks, so in, in, in the case of decentralized applications, the controller is instead of speaking to a server it speaking cube blockchains and to distributed hash tables in terms of a model that kind of stays very similar, but you also have this other type of model and that model is the smart contract. You can kind of think of smart contracts like models that the controller will speak to. And the same kind of logic applies when building here. We need smart models, thin controllers and dumb views. And your views are your html and CSS and javascript files, right? So all of the storage is happening in IPFS does distributed storage network and the application level constructs, those are usernames. Anything that you need two people to agree upon, right?

Speaker 1:          17:32          Game scores, all of that is stored on the blockchain. And, uh, we can use smart contracts to, to help facilitate that. So let's just get started with building this APP, right? So in order to, uh, run this code that I'm going to show you, there's very, very few steps. All right. So our first step is to use NPM, the node package manager and using it, we can install the test RPC chain, which is the test block chain rights. This is a blockchain we can use for development purposes that we can spend fake money on and no real money is used. So it's super useful for us.

Speaker 1:          18:09          And once that ends that's installed, we can install truffle. So truffle is a smart contract framework that offers templates for smart contract building so you don't have to start from scratch right there, scaffolds that you can use to build software faster. And once I've installed truffle and then we can go ahead and run the test RPC chain directly in terminal in its own console window. Once test RPC is running, then we can go ahead and run truffle compile on our code and then truffled migrate troubled test and then truffle surf. But there's, there's one thing that I want to do first. If we look at our APP, we can see the in html, all of the constructs that we created right here, right? So buy a ticket, refunded ticket, create a wallet. We can see them in all of these sections and they are calling javascript, right?

Speaker 1:          18:55          So javascript would be the buttons here and Javascript. The javascript is identified by the IDS. If we look in the javascript, we can see the application, the APP dot Js, which contains all of the code, right? So w we initialize a conference, we are calling these functions on these objects, right? So these functions from my conference instance are from the smart contract directly, right? So these are functions that we embed in the smart contract that my conference instance, think of it like a class, right? So the smart contract as a class, and we can call all the functions that we ride right inside the contract directly from APP dot js because we're using web three dot js. The framework for talking to the ethereum blockchain. So it's pretty simple. So we would just have to write out our smart contract, like so, right? So let's write out our smart contract for the conference and then we can run it. It's just like a class, right? So we'll say, all right, what are our, what are our global values here? Right? We have an address for the public, for the organizer of the contract. We have some sort of mapping, right? Because we want unaddressed to map directly to an integer value. It's because that integer value represents the,

Speaker 1:          20:06          a number of registration registering that we're paid, right? We want to keep track of this stuff. And then under that we want to more variables, one for the number of registered registrants, and then one for the,

Speaker 1:          20:24          and then one for the, and then one for the quota. Like how much, what is our maximum limit of, uh, tickets that we will let people buy? Then we'll have a function for the deposit so we can log the event, right? So we've got a log, how much is being deposited into this smart contract? And we have those parameters in place for that. One more, uh, event is for, uh, refunds, right? We're going to log how many refunds are being processed here, right? From what address are they coming from the amount, and then the type, which is an Integer, we can then construct our function using this constructor function. We can then construct our conference using the constructor function. So it's a function conference and then we can go ahead and initialize those variables that we defined beforehand. We're getting some message from whoever sends the transaction to the smart contract.

Speaker 1:          21:16          We have a set quota that initially is initializes euro, and then we have a number of registrants that starts off at zero is a quota, is a hundred, and then number of registrants is zero. Under that, we can go ahead and finally write our by ticket function, right? This, this function is going to let anybody buy a ticket. And like I said, we can call this function directly from our APP dot js. So we will say initialized conference and then we can run conference.buy ticket. And so whenever someone clicks on buy ticket, it would then call this contract directly. Just like that, right? So then we can say, well, if the number of [inaudible], so we'll start off the a function by saying, if the number of registrants is greater than the quota that we have in place, then okay, then we need to, we need to go ahead and write a thorough statement, which will ensure that the funds will be returned.

Speaker 1:          22:04          All right? So that's it for our contract. Very simple stuff, right? And then like I said, we can call this contract from APP dot js and it's going to run the contract just like normal. Okay. So, uh, that's a demo. I hope you liked learning about ethereum. There's so much more I could talk about. There's some great links in the video description and hope you like watching this video. If you find this stuff interesting and you want to see more, go ahead and hit the subscribe button for now. I've got to go invest in myself and not any other cryptocurrency for the moment. So thanks for watching.