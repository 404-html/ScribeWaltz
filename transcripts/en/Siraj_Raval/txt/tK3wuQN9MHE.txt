Speaker 1:          00:00          Hello world. It's a Raj and who's ready to go into the mathematics of cryptography? I know I am. That's what this video is about. The mathematics of cryptography. Cryptography is used all over the place in our day to day lives in places we don't even think about it. Everything from our telephones to ATM machines to https, the one of the protocols that are fundamental to the web blockchain technology and of course artificial intelligence. Okay, so what we're gonna do is we're going to go into the math of cryptography and I'm going to show you a demo. First of all, this is running on local host right now. I've see right here. What this is is it is a collaborative text editor that is zero knowledge. What that means is we can collaborate on this text editor, like I can type something in like you know, hey, what's up and notice how I'm anonymous.

Speaker 1:          00:48          Other users can join this. It's peer to peer and no server can can know what we are typing. Even if we were to put this app on a server, no one would be able to tell what that data is unless they had our key signature or digital signature for the, for this, uh, editor. So that's, that's the really cool part. I'm going to go into the code for this at the very end. Uh, but before we get into that, we have to talk about the mathematics that that's used in it, right? The mathematics of cryptography. Now what I'm gonna do is I'm going to go into the details of cryptography and then I'm going to go into some of the use cases, particularly artificial intelligence, and then we're going to eventually go into the code for this. Okay. So first of all, and also the thing I'm most excited to talk about is the concept of Zika.

Speaker 1:          01:34          Snarks you might be thinking, what are you, yeah, I know we're going to get into that, but we have some building blocks to get into before we can talk about Zika. Snarks so what is cryptography? So check out this, uh, image I've got here of, uh, this beautiful text. I love apples. I do love apples. I don't like apple juice. I like apples. So we take this text, I love apples and we have a key. This key could be anything. It's it's some sort of algorithm. It's some sort of series of steps to in cipher or encrypt some, some plain text. So we say I love apples. The key is to replace every letter with the third successive letter. So I love apples would be I, we start off with ISO. What's the third successive letter in the alphabet? I J k. So then I becomes k.

Speaker 1:          02:19          Okay, so a, what's the third success of letter in the alphabet, a, B, c. So then a becomes C and we do that for every single letter. And once we do that we're going to end up with this random looking unreadable, what's called cipher. Now this is the essence of cryptography. Cryptography is a set of techniques to scramble data, disguise data. It's used all over the place in computer science. And it's a really important topic to understand because no matter what you're doing, no matter what field you go into in computer science, whether it's Ai, web, APP development, mobile APP development, cryptography is paramount to security, to privacy and to an anonymity. Okay? So this is a really important concept. And so in cryptography the scrambled data is available only to someone who can restore the data to its original form. So what that means is this data is kept secret from unauthorized people, but easily decipherable by authorized people.

Speaker 1:          03:12          Someone who has the key for that, for that cipher text. Cryptography deals with encryption, decryption, hashing and digital signatures mainly. Let's go into each of these. So encryption first of all is one of the most critical tools used in cryptography. It means converting intelligible, plain text into cipher text, which is not intelligible. And there are three forms of encryption that are widely used, symmetric, asymmetric and hashing. So check out this image here we have a sender and we have a recipient to different nodes in a network. And if I'm the sender and I want to send you some plain text message that only you can read and no matter if this message is intercepted, if it goes to the wrong person only you will be able to read this message. I will use encryption to secure that message and so I'll have some plain text like hello world, the strength, I'll encrypt it using some encryption algorithm.

Speaker 1:          04:06          Let's say a public key for example. Let's say I receive a public key from that encryption algorithm that that message becomes a cipher text and if you, once you receive that cipher text, it looks random. It's just a bunch of letters. That knee nonsense. If you have the private key, you can decrypt that a cipher and get the plain text, the original plain text, hello world and that's public private key cryptography. That's one type of cryptography, but symmetric encryption is the one of the oldest forms of cryptographic methods known to mankind. Okay. The concept is very, very simple and if we were to break it down to steps, it would look like this. I have some message m that I want to send over to you. Okay. I encrypt the message with a key and I get a cipher text. See, okay, this is a cipher text.

Speaker 1:          04:51          Now you get that cipher text. See if you had that same key that I have. You can now retrieve that original message m so it's one key to both encrypt and decrypt. And because it's one key on both sides, it's called symmetric. So that's the oldest form of encryption. Now another form of encryption that uses a public private key pair is called asymmetric encryption. No, you know, notice from Bitcoin, it uses this and all of these blockchains they use public private key cryptography. But the idea is similar but different. The idea is that utilizes two keys, not one, a public key and a private key. And the use of one key cancels out the use of the other. So I'll encrypt something with the public key and then you can use the private key or the secret key to then decrypt it and it's asymmetric.

Speaker 1:          05:36          Now hashing is another example. So recall from you know, data structures and algorithms. One O one. Hopefully you've taken that. Uh, if not, uh, don't worry about it. We always go over it a bit right now. But hashing is a way to take some, uh, plain text key and convert it into a hash that you're putting into a bucket or a hash table, which is easily retrievable. So Hash tables are great because they have constant time retrieval, which is awesome. And storage as well, I believe, don't quote me on that one, I'm just saying that from memory, but hash tables are really fast for both storage and retrieval compared to other data structures. But the idea is that you have some hash function. It's a, it's a static hash function. It could be dynamic, but you know, standard, the standard is a static hash function and you put in a list of keys, right, names, passwords, whatever.

Speaker 1:          06:24          And it's going to convert that key into a hash. Like John Smith will become Otu using this hash function. Lisa Smith will become, oh one Sam doe will become, oh for Sandra Dee will become Otu. So notice that both John Smith and Sandra Dee Dee become Otu. And this is a problem, right? We want unique, we want unique Hashes for these keys. And so this is considered a collision, right? We want to prevent collisions from happening. Uh, and in the context of Bitcoin, the transactions are taking as input and run through a hashing algorithm. So bitcoin uses what's called the Sha two five six algorithm, which gives an output of a fixed length. So there's a specific type of hash function that these blockchains use. And this is called a cryptographic hash function. It's a special class of Hash functions that has various properties that make it ideal for cryptography. So the first property is that it's deterministic, that that means that no matter how many times you parse through a particular input through a hash function, you're always gonna get the same results.

Speaker 1:          07:21          And this is important because if you get different hashes every single time, it's impossible to keep track of the original input. The second property is quick computation. This hash functions gotta be fast. You've got to be able to hash to think fast. And if not, it's not gonna be able to scale. Your system's not going to be able to scale. It's got to be pre image resistance, meaning that given a hash, it's infeasible to determine the original, uh, plain text. And notice that, that I said the word infeasible, not impossible. We already know that it's not impossible to determine the original input, but it should be really, really hard. Small changes to the input should make huge changes to the Hash, right? So if I change this, a single letter in a 25 character input is there should be huge changes in what that hash would be if we were to hash that.

Speaker 1:          08:07          It's gotta be collision resistant. We've already talked about that. And lastly, it should be puzzled. Friendly meaning given part of the input and the output, it's very difficult for us to find the rest of the input. And this is central to bitcoin mining, which is essentially a race to solve a cryptographic puzzle by essentially trying out many, many solutions uniformly, randomly. Now, the last part that is a key to cryptography, no pun intended, or the concept of digital signatures. Okay. So imagine that a paper that I've signed with my signature, what should this, what should a good signature do? That is a question, right? So a good signature should provide verification, meaning that someone should be able to verify that it was me who signed it, right? My handwritten signature. It should be non forageable meaning no one else should be able to forge my signature.

Speaker 1:          08:55          It should have non repudiation. Meaning if I've signed something with my signature, I shouldn't be able to take it back or claim that someone else did it right? So in the real world, no matter how good my signature is, no matter how unique it is going to be easily forageable by somebody, right? But cryptography gives us a solution by means of what's called a digital signature, which is done via the use of keys, right? And generating and verifying digital signatures involves encrypting a message digest with a private key to create the electronic equivalent of a handwritten signature. Both a handwritten signature and a digital signature. Verify the identity of the signer and cannot be forged. And they serve to ensure that nothing has altered the signed document since it was signed. So I've got this uh, diagram here of using digital signatures. I've got a signer and my data, I'll encrypt it using my private key, and that's going to create a digitally signed document.

Speaker 1:          09:45          We put that through a hash algorithm and use the decryption public key to then match if the signature is valid, if two of the hash values have matched, and then the receiver can then read that document and then know that it was me who was the originator of that document. Here's another diagram. So we have a sender and we have a receiver, right? So I've got some message, let's say it's Crypto, compare.com and some strength. I can use a public private key pair to then input to assigning how rhythm and that's going to output a public key, my signature and the original message. The receiver can use that public key to verify that it was indeed me who signed that message and read that message. So it's proof of ownership. Digital signatures are great for proof of ownership and they're used in bitcoin for that exact purpose.

Speaker 1:          10:29          Okay. So, uh, now what are some examples of cryptography? Right? Like I said, they're used everywhere and in day to day life they're using smart cards and electronic commerce, any sort of online banking or anytime you need to make a payment online, computer, passwords, ATM, anything that is critical. Anything that is very important. We want to use cryptography as a way to ensure that that data cannot be, uh, forged or stolen by an unauthorized third party. Okay. So cryptography keeps data confidential and helps verify data integrity. So one great example for this is http. S right? So HDP is the protocol for the Web, right? You know this probably, but it's how we communicate on the Internet. It's fundamental. It's stateless. And since the server forgets the client, once the transaction is over, most of our day to day transactions are done online these days. Bill payments, online shopping, right?

Speaker 1:          11:25          So it's, it's absolutely necessary that the communication between the server and the client is secure. So https was invented to help with this. It is http. But running on top of SSL. I know acronym hell right now, but SSL stands for secure sockets layer and that's what htps runs on as I sell insurance, the secure channel of communication using cryptography. So here's how it works. We have the client and the server and it's a seven step process. So we have an initial hello message that and we agree on encryption algorithms and key sizes. The client requests a public key. The server sends a digital certificate, the client encrypt or random number, uh, with the public he extracted from the digital signature. Both sides generates symmetric keys based on that random number. The server proves the identity by replying with, with a finished handshake message. And both sides encrypt data in both directions using their symmetric key.

Speaker 1:          12:22          So it's a seven step process, right? You know about the digital certificate and that lock sign in your web browser, that is https and it uses cryptography to secure the data between both the client and the server. What's another example of cryptography? WHATSAPP, right? So whatsapp is one of his, is the most popular mobile messaging software in the world right now. And conversations are are end to end encrypted. What do I mean? What that means is only the data is encrypted. The headers, the trailers and the routing information are not encrypted and it makes sure that a message that is sent is received only by the intended recipient and no one else. WHATSAPP has ensured that even it as a server, as a third party cannot read the messages bolstering a very strong messaging platform. So on the client side, the user is encrypting their message using a public key, sends it off to the server, the server cannot read that message and the message then goes to the client B or user B. And then using a private key, they can then decrypt that message client side and read it and the server could not read what was happening between those two parties.

Speaker 1:          13:26          Now artificial intelligence, so I know some of you might be thinking, why are you talking about cryptography so much? It's, it's not related to Ai. While I'm here to tell you that it is very, very much related to Ai. And now here's, here's one example. Open mind. Open mind is a community. It's an online community that has a single mission and that mission is to democratize data. They want to democratize data and what, what, what it means specifically is they want to make deep learning technology accessible to consumers who supply the data and machine learning practitioners who train models on that data. Okay. So basically if I had got some data right on my computer locally, and you're a machine learning practitioner and you want to train your model on that data, how do I give you access to my data without you knowing exactly what data is in there?

Speaker 1:          14:12          Right? How do I let you train your AI on my personal data without you as a person knowing what my data is about? Right? So all of this is using encryption all over the place, right? How do we do this in a decentralized way without using a third party server? Right? How do you train an AI on data that you don't know what is, uh, the details of it, right? So like, let's say for example, hospital records, I want to train my AI model on some really sensitive patient data. But knowing the patient's name and all their details, that's, that should be private, right? They don't want to give that away. However they want to let me train my AI on data so that I can then solve some disease in the future. Right? So this would be a perfect use case for open mind, which heavily uses encryption.

Speaker 1:          14:59          Now another use case, and this is the future of Ai, which is where we're going, is the idea of distributed autonomous organizations. So recall that corporations are actually a rough initial form of artificial intelligences, right? Corporations are, consists of humans right there, they consist of humans, but really a corporation is, is, is an entity in and of itself, but they're there. They're the second stage and getting to real AI. So what I mean is corporations are humans at the center and humans at the edges. While we're moving to where we will actually, where we are right now is having, is having humans at the center and AI at the edges, right? So Uber for example, once they have this self driving car network is going to be humans at the center. And Ai at the edges. So the cars are going to be, uh, Ais, right?

Speaker 1:          15:47          So that's the second step. Eventually we'll have AI at the center and humans at the edges. So the AI is making the decisions, the main decisions and humans are going to be, uh, completing tasks that the AI needs. But eventually, eventually we'll have AI at the center and AI at the edges. So that's a completely autonomous system that doesn't need humans at all. That can flourish, that can learn for itself, that can get the data it needs, it can pay for what it needs. All of this requires encryption end to end encryption in order to make sure that it's a system that can be trustable, that we can trust this system, right? It doesn't become something bad that we don't know what it's doing. It needs to be able to prove what it's doing. Right? Approvable trustful system that is verifiable by third parties, humans, the in that, the work that it's doing is valid.

Speaker 1:          16:37          So all over the place, right? We can have ais at the edges, we can have ais at the centers and we can have swarms of Ais, right? These are all simple AI agents that together make up this higher level complexity and encryption is kind of like the glue. It's kind of like the tape that makes sure all the systems are able to work together seamlessly. Encryption and cryptography, all of this is important stuff, but you might be wondering what math do I need to know in order to do this? Well, for cryptography in general, there are four topics that are supremely important to know. Well, the first is mathematic notation. The second is abstract Algebra, the third is discrete math, and the fourth is calculus. Now if you want a refresher on all of these, I highly recommend Khan Academy. That is the, that is the best source I think out there for learning.

Speaker 1:          17:23          Just basic math and also a brilliant.org brilliant.org check it out. Some great interactive games to learn math. Okay, so that's a primer on cryptography. Now let's get into a type of cryptography called zero knowledge proofs. I mean there's so many directions we can take this. I mean we could just go in depth on a single topic like forever, but I'm just going at a high level right now because I want to get to Zika snarks at the end. Okay, so now I want to talk about zero knowledge proofs. Zero knowledge proofs are a type of cryptography that our supreme, we useful, uh, in both blockchain technology and an AI. So the idea is that how can I prove that I know something without having to tell you what it is that I know? That's the idea behind zero knowledge proofs. How do I prove that I know something?

Speaker 1:          18:11          It could be anything without having to reveal what it is that I know. Here's some examples. Treasure hunts, PR. How do I prove that I know the location of a hidden object without revealing what it's location, it's and Sudoku. How do I prove that I know the solution to the puzzle without revealing what that solution is? Sealed bid auctions. How do I prove who won without revealing any bid? Are you beginning to see the idea here is zero knowledge proofs, account balances. How do I prove that my account has enough without revealing what that amount is? Zero knowledge proofs are super useful for all of these use cases. So the idea came in the 1980s to a group of MIT researchers. Zero knowledge states that approver can prove to the verifier that they possess certain knowledge without telling them what that knowledge actually is. A zero knowledge proof has three properties, completeness, soundness, and zero knowledge for completeness.

Speaker 1:          19:05          If the statement is true than an honest verifier can be convinced of it by an honest prover soundness. If the prover is dishonest, they can't convince the verifier of the soundness of the statement by line and zero knowledge. If the statement is true, the verifier will have no idea what the statement actually is. So let's go into two examples here. The first case is this scenario called Alibaba's cave, right? So in this example, the prover p is saying to the Verifier v that they know the password of the secret door at the back of the cave and they want to prove it to the verifier without actually telling them the password to the prover goes down any of the paths a and B. And suppose they initially decided to go down the path a, there are two paths here. When they do so the verifier comes in at the entrance with no knowledge of which path the prover actually took and declares that they want to see that the prover appears on path B. The prover does indeed appear in path B. But what if it was dumb luck?

Speaker 1:          20:01          What if it's not that they knew it? What was path B they had to take? What if they just guessed? How do we prove that? Right? So to test the validity, we just do that experiment multiple times. If the approver can appear at the correct path every single time, it proves to the verifier that indeed the prover knows the password, even though the verifier doesn't know what that password actually is. And so this, this satisfied the zero knowledge properties, right? It's completeness. Because since the statement was true, the honest prover convinced the honest verifier, it satisfies soundness. If the prover was dishonest, they couldn't have fooled the verifier because the test was done multiple times and zero knowledge. The pro, the verifier never knew what the password was, but was convinced that the prover had the possession of it. One more case finding Waldo. So who played a where's Waldo?

Speaker 1:          20:51          Cause I used to play that right? Remember that book shout out to the 90s all those kids out there. So finding Waldo is this game where you have to find this Guy Waldo in a sea of people. So imagine you and me are playing where's Waldo and I solve this puzzle before you and I want to prove to you that I've solved that puzzle without giving any hints as to where, where Waldo is, right? Like I could tell you, hey, I found Waldo and you might say, well where is he? And I want to, I just want to prove to you that I found him without telling you where he is. Cause I want you to solve it to, how do I do that? So one way to do this is to take a sheet of paper with identical dimensions to the picture and mark the spot on it in the exact position where Waldo is.

Speaker 1:          21:31          And then I fold a sheet of paper into some kind of origami or something and give it to you. So once you solve that puzzle, you can open up that folding, put it back on top of Waldo, like an overlay, and then see, oh, that point is exactly where Waldo was. And that's a way of having a zero knowledge proof. Just to give you some concrete examples of what I mean, right? To really drive this point home. Okay. So there are two types of zero knowledge proofs. The first is proof of statement, and the second is proof of knowledge. So proof of statement means that this is some intrinsic truth about the universe, like the number x belong to the group. Why or this star is brighter than the other stars? Proof of knowledges. I want to prove that I have knowledge of a particular idea.

Speaker 1:          22:15          Without revealing what that knowledge is that's as can be seen in those two examples I just gave. Cryptocurrency is mostly focused on proof of knowledge. Okay, so now let's get into Z K snarks a bit. So this stands for zero knowledge succint non-interactive arguments of knowledge. Okay. Zika snarks so it's used in it's use in modern blockchain technology is immense. And to understand its application, we have to understand a bit about how smart contracts work. Basically it's an escrow of funds which gets activated once a particular function is done. So let's say I've entered into a smart contract with you, for example, Ben, um, and I'm only going to get the payment if I do a, B, and c a, B and c are tasks. What if I don't want to reveal the details of what a, B and c are because they are confidential to my company and I don't want any competitors to know what I have to do.

Speaker 1:          23:05          What Z K snarks does is it proves that those steps have been taken into smart contract without revealing what those steps actually are. And this is very useful in protecting privacy. It can just reveal part of the process without showing the whole process itself and prove that I'm being honest with my claims. So how does this work? So it consists of three algorithms, g, P and V gs. The key generator, p is the prover and v is the verifier. G is going to take an input lambda and this is a, this should be kept confidential, right? It shouldn't be revealed under any circumstances and a program see it then proceeds to generate to publicly available keys, a proven key PK and a verification key VK. These keys are both public. Anybody can look at them and available to any concerned parties. Lambda is that part that has to be kept secret.

Speaker 1:          23:56          So P is approver. Who's going to use those three items as input, the proving key, the random input x, which is publicly available and a private statement that they want to prove the knowledge of without revealing what it actually is, which is we're going to call that private statement w. So p is going to generate a proof such had the proof equals p of the private key, a random input x. And then the private statement that we want to keep private w that's our, that's really what we want to use. Everything for. How do we encrypt this thing? Right? So the verifier Algorithm v has basically returned a boolean value. The boolean variable only has two choices. It can be true or it can be false. So the verifier takes into verifying key public input x and proof PRF as inputs such as the, the of fee k x PRF and returns true if the prover is correct and false.

Speaker 1:          24:47          Otherwise the value of lambda must be kept confidential. We've talked about this and here's what an example looks like. A function c with parameters x NW returns the Sha two five, six of the original, you know, private statement equal, equal, equal x. All right? It takes two volumes as input a public hash value x and the secret statement that needs to be verified. W if the Sha two five six hash value of w equals x, then the function returns true. Otherwise it returns false. Okay? Now, uh, the proving Algorithm we talked about, it looks like this proof equals p of PK XW. And now that someone has generated the proof PRF, they're going to give that value to the second person who's going to finally run the verification algorithm of Zika snarks, which is this, the of the k x Prf here. Vk is a verifying key and x is the known hash value and Prf is the proof that they've gotten from the first person.

Speaker 1:          25:44          If the algorithm returns true, that means the first person was honest and they did indeed have the secret value. W if it returns false, it means that that person was lying about knowing what w is. So lastly, I want to go over this code for this repository called crypt pad that I found is a really cool repository. Basically it's a zero knowledge real time collaborative editor and there's a lot of code involved, but it's really easy to install. Like it's like just three lines that I just, you know, Bauer install, npm install, and then node app dot js and it's running on local host. But there were some parts of this that I wanted to talk about really quickly. So one part is the, uh, common hash. So if we opened that, this is where the hashing is happening here, right? So they're using different hashing algorithms here to get the keys from the server.

Speaker 1:          26:44          Right? But the idea is that only the clients that have that key can decrypt the messages. So if there's a server that is why that is hosted on, then the people who control that server can't see what the data is that these people are collaborating on in real time. Okay. And they're using javascript to do this with the common hash function. I mean there's a lot of code here, but uh, I think in main dot js we can see the high level of what's going on here. If we go to examples, right, where we go into examples and then pin and then main dot js. So this is, this is what's happening on, on APP start, right? So we synchronize the channels, right? So we get the Hash Channel List, we get the file size, we get to server hash and then once that's ready we get the network, the store and then we create a pin path of a pin pad by synchronizing the Hashes from all of these different clients and all of its being encrypted and decrypted client's side.

Speaker 1:          27:45          So the server never has any knowledge of what these people are talking about in real time. So Google docs for example, Google knows what you're typing in real time, but if there was a zero knowledge proof involve like Zika snarks are, you know, et Cetera, then they could not know what you guys are collaborating on. So it's really useful to keep your data private, to keep it anonymous and to create systems that are trust less or you could say more trustful in a way. But z cash is a great example that uses Zika snarks. It aims to provide completely safe and shielded transaction spaces for its users without revealing their details and etherium as well once to integrate Zika snarks as it enters its next phase of development. Please subscribe for more programming videos. And for now, I'm going to research some crypto map, so thanks for watching.