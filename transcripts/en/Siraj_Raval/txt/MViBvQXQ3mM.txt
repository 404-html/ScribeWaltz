Speaker 1:          00:00          Hello world, it's Saroj and today we're going to build a blockchain in five minutes using python. Ready? Let's get started. A block is a data structure that contains data and some attributes. Blocks can be linked together to form a chain of blocks. This is called a blockchain. The bitcoin protocol uses of blockchain data structure to store transaction data, but we can store any kind of data in a blockchain to understand how it works. Let's code our own in the browser together using Google's colab environment. We'll also periodically view a blockchain demo in the browser as well. While we code for better comprehension, this will be a four step process in port our dependencies. Create a blog, create a blockchain, then print out the blog chain. First we'll want to import daytime so that we can generate timestamps for each block will also import hash lives.

Speaker 1:          00:52          Since it contains an important algorithm will use to define our block. We can define our block as a python class. Then define its attributes. Each block has seven attributes and we can list each as a distinct variable. First the number of the block so we can index each of them. Next, the data we'll store in this block. Bitcoin's blockchain stores transactions in here, but we'll just store text strings in here. For simplicity, we'll define a pointer to the next block as well as the hash of this block. A Hash is a function that converts data into a number within a certain range. The Hash serves as both a unique identifier for a block and verifies its integrity. More on that in a second we'll define a nonce or number only used once. We'll later use it to help compute a unique hash for our block.

Speaker 1:          01:43          Then we'll define a previous hash which will store the hash of the previous block in the blockchain when we actually build a blockchain. And lastly, we'll define a timestamp for a block using the daytime library. Now that we've defined our attributes, we can write the in it function for our class. It defines how we initialize a block using some provided data as the only parameter will also need to define a hash function for a block. The Hash Library contains the Popular Sha two five six algorithm, which generates a unique 256 bit signature that represents some piece of text. The input to our algorithm will be a concatenated string that consists of five of our block attributes. See how a hash is created using the unique attributes of a block. This means that if someone tries to change the hash of a block in a chain of blocks every block after it is changed since each blocks hash is generated in part using the hash of the previous block.

Speaker 1:          02:42          And before we finish our block class, let's write a small print function that will print out the value of a block. Now that we've defined our block class, we can define our blockchain class. We'll define two key attributes of our chain of blocks or blockchain. First, the genesis block and the head. The genesis block is what we call the first block and a block chain and we'll store this string genesis inside of it. The head will be the newest addition to our block as we add more blocks to our chain, this head will be updated. Speaking of adding blocks, let's write our ad function. This will add a given block to the chain of blocks. The block to be added is the only parameter will need blockchains are just glorified linked lists. We can set the hash of a given block as our new blocks previous hash and set the block number of our new block as a given blocks number plus one since it's next in the chain.

Speaker 1:          03:33          Then we'll set the next block equal to itself. This is the new head of the blockchain. We now have one more function to write the mining function. This is what let's nodes in a network that don't necessarily know each other. Come to consensus on what the one true chain of blocks looks like. A chain that is immutable. It requires computing power to mine a block. This is a defense mechanism and bitcoin's blockchain. An attacker would need the majority of the computing power in the network to modify a block and give themselves money they don't rightfully have. In the bitcoin network. 51% of the computing power is more computing power than the 500 fastest supercomputers in the world. Combined and since no one has anything close to that much computing power, the network has survived for almost a decade. Now we'll need to define three additional attributes in our blockchain class, the Max nonce, which is two to the 32nd it's the biggest number.

Speaker 1:          04:27          We can store it in a 32 bit number. Then a mining difficulty. We use the mining difficulty value to compute our target hash. It's going to be two to the 256 minus. Our difficulty in our mining function will determine if a given block, which will input as a parameter can be added to the blockchain for a range of numbers from zero to two to the 32nd or Max nones value. We'll check to see if the value of the given blocks hash is less than our target value. This is exactly what bitcoins mining function does as well. If it's less, we'll add that block to the blockchain and break out of the loop else will increment the nones and repeat the process until we reached the end of the loop. The mining difficulty sets how computationally expensive it is to mine a block. The higher the number, the longer it will take to mine, and the value of the nones after mining reflects that. Now that we've defined both classes, we can initialize a blockchain. Then we'll write a loop to mind. 10 blocks. Each of them will be initialized by a unique string. Finally, we'll print out each block in the blockchain. If we compile this code, we'll see each block and our blockchain with its associated attributes, including the unique hash, the data, and the timestamp. I hope you found this tutorial useful. Please subscribe for more programming videos, and for now, I've got to break the great firewall, so thanks for watching.