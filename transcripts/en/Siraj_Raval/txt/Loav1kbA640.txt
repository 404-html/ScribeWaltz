Speaker 1:          00:00          Microsoft bucket and everything will be fine. Hello world. It's Sir Raj and in this video I'll show you how to use get hub, the safe space for developers across the world. I'll describe how the good protocol works, show you how to make your own repository and give you some tips on how to promote your get hub code via social media. Over a decade ago, the legendary programmer, Linus Torvalds was working on an operating system that had been his pet project for a couple of years. He was constantly making changes to his code and there were other developers who weren't interested in contributing to the project as well. He needed a way to track how the code changed over time, so if he messed up, he could easily go back to a previous version. The simple way would be to continuously rename every new version of his source code, but this was cumbersome.

Speaker 1:          01:01          A better way would be to use some kind of lightweight protocol to track those changes over time. This would also help him work with other developers as it would give them a collection of notes on the most recently worked on project files as well as a nice chronological history of what had changed. There were existing tools out there, but Linus was not happy with any of them as in his hilariously strong opinion. They didn't work well enough for that reason. He wrote the get protocol to solve his problem and he used it to help him work on his operating system. Linux, even though there are other version control systems out there get has since exploded in popularity becoming the most used. It's now@theheartofprettymucheverymoderndevelopmentworkflowandthepopularwebsitegethub.com uses the get protocol to host code bases and allow developers to work together with a single shared interface. Get has a lot of different commands and its architecture can be confusing if it's your first time trying to understand it to make a get more intuitive.

Speaker 1:          02:14          Let's use the analogy of an auto company like Tesla. Let's say Tesla has to release a new version of its model s every year with slightly updated features. The different teams of car designers at Tesla have a year long plan to execute those features for the latest version and along the way each team has to make sure there changes support the changes from other teams, so if we're on the body design team we need to create a body design that doesn't just look good. It has to work in tandem with the new features that say the interiors team is putting in the car like flame throwers, how do we best organize our workflow such that we can accommodate all of the teams as we are developing the body for the 2019 virgin, there are actually four versions of the design that exists at any given time.

Speaker 1:          03:10          There's the live version that's the current version that's already on the market that customers know about. There's the currently planned version for the next year that will eventually go live once all the teams agree. This represents the remote repository. There's our own latest improved body designed version that takes into account suggestions from other teams, but that's yet to be presented to the rest of the team for approval. This represents the local repository and finally there's a design we are developing and excited about but still needs to be tested and reviewed by the team. This is the staging area. Each stage represents a different level of commitment to the body design and similarly in a code base, our code must pass through four stages before it goes live. Just like in the car design process, this is a great thing. We wouldn't want to just draft up a car design and immediately decide that, hey, this is the final 2019 design.

Speaker 1:          04:16          The whole team has to agree upon whether our design works in harmony with the other changes that are being made. It's a democratic process. Unlike apple get has a set of commands that we can find via a simple cheat sheet. Each has its own use case. We can use three commands in particular to highlight the different stages of review that our design must go through before it goes live. Each stage further lowers the risk that we'll make a decision that conflicts with features built by another team, get pad eclairs that we've finished a full design and that we feel good about it. It still needs to be tested and reviewed though as this design enters the staging area and get commit means we feel fully confident in the design. We've put it through all our standard tests and our features like revolving side mirrors to Olin place.

Speaker 1:          05:13          This design is now copied it from the staging area into the local repository ready to present to the other teams. Once we're ready to present our car to the other teams, we can copy our designed from the local repository to the remote repository. Viet that get pushed command through remote repository is hosted in the cloud while our local one is hosted on our machine and once all the teams are happy with the new features, we can deploy it to our website or mobile app in production. This isn't actually a gift to command, it just represents the process of going live to production. So far, we've assumed that we're all building just one new version of our car at a time, but the reality is that our car actually has three variations each with slightly different body designs. They have pretty much all their features in common except for the body design.

Speaker 1:          06:09          We could just make new repositories for each, but since they share so many in common, we can just create branches for each branch's. Let us maintain multiple versions of the same code base. Each branch will have a few slight differences and if the marketing team learns that, hey, there isn't a demand for a certain version of our car, but it would be nice to have a certain feature of that car. In our main version, we can use the merge command to integrate two branches. This eliminates one branch but brings the features of that branch into a single new branch. Let's say a team pushes a new feature like a car dashboard to the remote to repository. We can update our local repository with get pull, pulling the new changes, but if those changes conflict with our repository, we have what's called a merge conflict. We have two options to resolve this.

Speaker 1:          07:06          We can either tell that team to revert their changes to what they were previously or we can change our own body design so that it fits the new dashboard. Then push an updated version too remote to resolve the conflict and get helps us track all of these conflicts and quickly points out the exact lines that are in conflict. So let's go ahead and create our own repository then put it on, get up. We can sign up for get hub pretty easily on the website. After entering a few credentials, we'll want to add a picture and a description since it's essentially a social network for developers. Once we do that, we can download the latest version of the good protocol and install it. After that's done in command line, we can set up get so it links up with get hub will define our get hub username and email using the get to config command, the same ones we used on github.com then we can create our first local get repository via command line using the get in it to command.

Speaker 1:          08:11          We can check the status and see that we have absolutely nothing to commit right now, so we'll just create a new file and add some code to it. Now we went to push these changes to get hub so we can add it to get straight to the staging area. This is our initial design. Then if we're satisfied, we can commit our changes to our local repository via the commit command. Before we push our code to the remote repository. Let's create another branch for fun. Then switch to it via the checkout command. We can modify the code a bit here. Then committed. Now if we switch back to our main branch, also called master, we can make change just for fun and committed. Now if we want to merge the changes from our new branch onto master, we can via the merge command, but alas there will be a merge conflict.

Speaker 1:          09:07          This happens when we work with teams. Each developer working on their own branch, luckily get lets us resolve these conflicts by seeing the exact line of code in question. We can resolve it locally to match, then commit the resolution. This is why get resembles a tree. Different branches each with different commits can all represent nodes in a tree all leading up to the master node. Now we can push our code to get hub, but first let's create an empty repository on our new get hub account. We'll copy the link it gives us and add a new remote. Then we can push to that remote via the push command and if we go to that repository on Github, we can see our code there. How dope is that? Get hub is a social network and you can follow other developers to keep up to date with their latest code.

Speaker 1:          09:59          The more developers that follow you, the more likely developers will contribute to your open source project. Currently, Linus Torvalds is the most followed developer out of 28 million on get up and right now I'm number 15 so watch out Linus. I found a lot of success promoting my get hub profile by using my social media accounts as a distribution channel to get up and good documentation goes a long way to getting developers to follow your code. Promoting code directly leaves a very niche audience to view, but if you wrap, it would say a video or blog post or podcast, some kind of explainer content in general, then you'll be more likely to get people to actually view the code, get and get hub are both a lot of fun and I've listed some great learning resources for you in the video description, so definitely check them out. Ready to come.

Speaker 2:          10:55          More pushes, subscribe button, and my art will merge with yours. For now. I've got to resolve a conflict, so thanks for watching.