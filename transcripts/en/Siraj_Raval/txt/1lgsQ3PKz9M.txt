Speaker 1:          00:00          What are stigma? 80 most Netties, which means orders. I'm ready. My home has been in ancient Greek. Hello world. It's Saroj and Coobernetti's is an open source project that enables developers to automates the process of deploying, scaling, and managing containerized apps. That's right. Not just any kind of apps specifically containerized that by the way, if you want to be notified when my weekly tutorial videos are released, hit the subscribe button. I'll of course explain what containerized means. In fact, we'll go through the three steps necessary to make this happen. We'll create a cloud environment for our application. Using Google cloud will build and containerize an image classifier APP. Then we'll deploy our app to the cloud using the power of Kubernetes, and this same process works for any kind of APP, email services, social networks on APP that raises $1 million just to send Yoda people literally anything is possible.

Speaker 1:          01:03          Really any kind of APP. A container is a lightweight, standalone executable package of a piece of software that has everything necessary to run it. Code runtime system tools, system libraries and settings. It wraps up everything on APP needs, not just the code, but all the dependencies, libraries, and configurations. It abstracts away from any of the environments, physical or virtual needs, which it will run on. That means containerized apps run consistently across environments from Dev to test, to prod from a local machine to a cloud instance without the need for retooling. Nowadays, users expect Apps to be available 24 seven and developers expect to deploy new versions of these apps several times a day. Containerization helps package software to reach these goals, enabling apps to be released an updated in an easy and fast way without downtime. Over the past few years, developers have come to rely on container technology to increase the portability of their code and ensure that their apps run consistently across a variety of platforms.

Speaker 1:          02:12          They enable a much shorter deployment time and improved APP or liability for 51 research predicts the APP container market will approach two point $7 billion in 2020 up from a projected 1.5 billion in 2018 not bad. Considering that containers only started to become popular five years ago with the release of a popular open source project called docker. Docker was the first to package Linux kernel features together in a way that allowed teams to create artifacts easily. They could run on different servers and it's now become a household name. Docker containers made it so much easier for developers to enjoy parody between each of their environments. They could run the same exact container image across all them. Instead of building out an entire server to run a service or an APP, just run a docker container image on a host and it will use a smaller amounts of that host's resources to run the APP.

Speaker 1:          03:11          Compared to traditional virtual machine images, containers are lightweight and ephemeral. They can be spun up and spun down as resources increased or decreased or as the APP scales in the age of cloud architectures and increasingly distributed computing environments, docker has seen very rapid adoption these days. Docker has become synonymous with the container technology at its core. In fact, you might even hear a developer say docker when they're really just referring to containers. In general. I dockerized that using mezzos you, you did what a problem arose though early adopters of docker found that they were soon running hundreds or even thousands of workloads inside these containers. This quickly became an operational challenge. If you have a few containers and a few apps, orchestrating them isn't too complicated, but with thousands of containers and services, it definitely gets complicated. Enter Coobernetti's Kubernetes is one of the highest velocity projects in open source history.

Speaker 1:          04:18          It was first developed as an internal tool in the go programming language at Google. Then later made open source as a tool for any developer to use for container orchestration. Kubernetes is a tool for automating the deployment management and scaling of containerized apps. It makes the ongoing orchestration of potentially thousands of containers manageable and helps ensure your app is always running. Coubernetties is becoming to orchestration as docker has become to containers, as Microsoft has become to open source somehow pretty much synonymous. Think of docker and Kubernetes as two significant pieces of a larger system. Docker will containerize your APP. COOBERNETTI's. We'll automate it's pipeline. Let's go over some of the fee concepts in Coobernetti's. First, a container is the smallest unit it has. The whole point of Kubernetes is to manage, deploy, and monitor containers. These could be docker containers, but any kind of containers work.

Speaker 1:          05:19          A node is the host that the container runs on. A pod is a management unit in Coobernetti's comprise of one or more containers. Each pod has a unique IP address in storage namespace. All containers share these networking and storage resources. We use a Yammel file to define a pod Yammel, by the way, since for yet another markup language. I love that. The file extension is literally a mean. This Yammel file contains pod attributes like any med at metadata or the API version. Then there's deployment. When a pod is deleted, it's gone for good, but with deployment, Kubernetes ensures that number of pods that are user specifies is always up and running in the system. A deployment, we'll specify how many instances of a pod we'll run. We again use a Yammel file to define this deployment with instructions. Oh, and there's one more Yammel file that's used.

Speaker 1:          06:14          It helps define a service. A service is an abstraction that defines a local set of pods and a policy by which to access them. Sometimes called a microservice. A service is connected to a deployment via the label attributes. In this case, the label is Ngi and ECS. Kubernetes depends on these Yamille files to check if the desired pod deployment or service is running as defined. The overall architecture of Kubernetes has three main components, master nodes, worker nodes in a distributed key value store. The master node is the entry point for all administrative tasks related to managing the Kubernetes cluster. The master node has an API server, a scheduler that schedules casks to worker nodes. It controller manager that watches the desired state of the objects. It manages and watches their current state throughout the API server. If the current state of an object doesn't meet the desired states, then the control loop takes corrective steps to ensure the current state is the same as the desired states and one more a key value store.

Speaker 1:          07:18          It stores the cluster state and configuration details. It also uses a special consensus mechanism to let multiple servers agree on these values. There's more to Coopernetti's, but that's it for a high level overview. Now let's use Kubernetes to help deploy an image classifier web API that anyone can use. Three steps here. We'll create our environment on Google cloud. Then we'll use the care os library to build a deep neural network for image classification. Package it inside of a web app using flask and containerize it with docker. Lastly, we'll deploy this container using Coobernetti's. We'll first start a virtual machine on Google cloud. We just need to select compute engine. Then create an instance. Let's keep it small for this demo. Once we set some details, we'll click create to launch an instance to set up our environment. Now for step two, building an image classifier.

Speaker 1:          08:14          If we open up a terminal and the browser, we can connect to our newly created virtual machine in the cloud. We can go ahead and install docker, then start it up. Once docker is running will containerize an existing deep convolutional neural network built in chaos. I have a very detailed video on how convolutional networks work to help classify images, see the link in the video description, but in order for our code to run inside of a docker container, we'll need to create a requirement's dot txt file, which will contain all the packages are code needs to run. That way, no matter where we ship our docker container, the server will be able to install our codes dependencies. Then we'll create a docker file so docker will know how to build and run our project. We can build our docker container in a single line, then run it with our model running.

Speaker 1:          09:07          We can easily test it. Let's give it an input, a photo of a dog, and it will classify it by returning. It's breed. Boom, Shakalaka homie instance. Api builtin python served with flask and wrapped in docker. Now we can deploy this container to Coobernetti's. First we'll create a docker hub account. We're going to instruct Coobernetti's to install our container from a centrally host server docker hub. We'll log into docker hub from command line, tag our container, then push our container to docker hub. Now in Google cloud will select Coobernetti's engine, create a new Coubernetties cluster and then connect to the cluster using the cloud shell. We can now run our docker container in Coobernetti's the image tag points to our hosted docker image on docker hub. Lastly, we'll expose our pod on port 80 to the outside world once it's running and test out our APP by running a rest command pointing to our Coubernetties cluster success, we just created a scalable image classifier API that anyone can access on the web. Moving forward, we can explore all the different scaling and management features that Kubernetes has, but that's too much for this one video. Three things to remember. Coobernetti's is an open source project that enables developers to automate the process of deploying, scaling, and managing containerized apps on a cluster of machines. Containers enable a much shorter deployment time and improved APP reliability by including required runtime resources along with app code, and we can use a combination of python, docker, and Kubernetes to create a reliable and scalable web app pretty easily.

Speaker 2:          10:52          What's currently your favorite devops tool? Share it with me in the comments section if you want to stay updated on my weekly programming tutorials, it subscribed, and for now I've got to look into Cuba flow, so thanks for watching.