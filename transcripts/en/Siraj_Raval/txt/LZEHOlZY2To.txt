Speaker 1:          00:00          Hello world. It's Saroj and we're going to talk about something a little different. This episode called the blockchain and how it can be used to improve AI. The worldwide web has only been around for a couple of decades and it's grown by orders of magnitude. In that time, billions of machines are coming online as Internet connected devices, mainly phones are distributed globally. We've collectively define a standard for how they should communicate called the internet protocol suite. At the lowest level. The link layer puts data on a wire than the internet layer routes. This data, the transport layer persists it and the application layer delivers abstractions of it in the form of the apps that we all know and love. This has worked pretty well for our machines, but there's a missing layer, a layer of smooth, the refreshing manatees, no. Where's the protocol to let them exchange, not just data, but value. The main way it's done right now was invented pre-internet and it requires using a centralized clearing house, so machines have to sometimes wait four days for a payment to transfer from one to the other, but in all other aspects they communicate with each other at a mind boggling rates. What if they could send each other micropayments in the same way to meet a resources like electricity and storage space and computation all without having to wait for a middleman for a payment. He's still my painting, didn't he?

Speaker 1:          01:22          No. Bitcoin and other cryptocurrencies solve this problem. They act as a fifth protocol layer for value transfer and their underlying technology called the blockchain. It makes this all possible. The blockchain for the first time allows machines to agree on value transfer without having to trust a central authority. In the real world. If I create a painting, I and only I own it, but on the Internet, if I created a digital painting, you could just copy it and then we both own it. There's no way of proving who owns it without using a central server that records that ownership. We have to trust the server, the middlemen, but the blockchain lets us reach consensus in a decentralized way that prevents a bad actor from falsely claiming ownership, not just for paintings but for any asset like bitcoin. But how can this be used to improve AI?

Speaker 1:          02:13          Well, one use case is giving both datasets and machine learning models a reputation. How do you know that the data or the pretrained model that you're using is quality, that they haven't been tampered with? You? Basically you have to trust a single source unless you use a blockchain. Deep mind is using a blockchain to create a publicly verifiable auditing system for healthcare data. It records every interaction they have with sensitive patient data. So patients know if a piece of their data has been used and a reason why it's right only. So once a record of data use is added, it can't be erased. That means patients can verify that no one has tampered with any of the entries.

Speaker 1:          02:52          Another is a peer to peer network for training models. Instead of training your AI using services like AWS, Google cloud, imagine a system where people could just rent out their spare computing power to help train models and get paid in tenser coin, or even a company that is run entirely by AI. Blockchains are decentralized databases, so if an AI lives on a blockchain, no one could control it. It could leave as an independent entity on the web paying for whatever services it needs just to find an initial set of rules and set it free. One example would be a self driving car network run and maintained completely by Ai. Yeah. Oh, let's build our own simple blockchain in python to understand more about how this incredible Beta structure. Yeah.

Speaker 2:          03:35          Well, at first he lives, he lives in me only. You get access with your private key. First,

Speaker 1:          03:49          let's define what eight block is. For simplicity's sake, let's say that each block represents a single transaction, a value transfer between two machines. We'll define the blocked object and its own class. What they set up, important attributes the index represents. It's ordering in the chain of blocks. It's timestamp shows when it was created. It will store some data that is defined by the sender as well as two hash values, one for the previous hash and the chain of blocks and one for its own hash. The reason a block means a hash is dual purpose. It gives it a unique id and it verifies the integrity of the data. We use the popular crypto hashing algorithm called shot to five six to help generate a two 56 bit signature from the other attributes for each block in the hashing function. So how has a block generated?

Speaker 1:          04:34          Well, the user provides some data in their transaction, so we use that as the only parameter in the generate function. And since each block is ordered we've got to fetch the last block. We'll use the last block to help define this blocks index as well as its hash. We'll also give it a timestamp so we know when it was generated. So each generated block points back to the previous block by storing its hash, it's a chain of blocks. If blockchain, the first generated block is called the genesis block and we'll hardcoded in by predefining its attributes and its own function. Then we'll use it to initialize the blockchain and we'll store it as an in memory list. So remember how I said that a blocks hash serves as both its identity and verifies its integrity. We can use the hash to determine if a newly generated block is indeed valid given a new block and the previous block, which is the last block in the chain, we can first check to see that it's got the right ordering via its index.

Speaker 1:          05:31          Then we can check if it's previous hash attribute matches the already verified previous blocks hash. Lastly, we'll calculate the hash for the new block and make sure it matches the hash site. His stores, if it passes these checks, it's verified. Assuming all nodes store a copy of the blockchain. We need a way of choosing which blockchain to use in case there are conflicts. Let's say two nodes generate the same block number. Our solution will be to choose the chain that has the longest number of blocks. Since it's been around longer. It's more likely to be the true blockchain given a new blockchain will check if it's valid programmatically and if it has more blogs or replace our blockchain with a new one else, we can just reject it as invalid. Since each node stores a copy of the blockchain in blocks are constantly being generated.

Speaker 1:          06:14          As transactions occur, we need a method of keeping each node blockchain in sync. To do this, each node broadcast to all the others whenever it generates a new block. When a node connects to a new node, it queries for the latest block and when a note encounters a block with an index larger than its current known block, it can either add the blog to its current chain or query for the full blockchain. And so the way we can encapsulate a node so that both the user can query it as well as other nodes would be to create an http server, we could create end points for a couple of actions that a user could take. One would be to list all the current blocks in the blockchain. Another would be to create a new block, given some data as a parameter by the user and another it could be to list all the other nodes in the network or even add new ones.

Speaker 1:          07:00          So the user would control the note via http requests and he would communicate with other nodes via peer to peer web sockets. So that's our simple blockchain. It's very minimal and doesn't include all the features that bitcoin's blockchain has. But Hey, it's an example. However, crucially, there is one key feature that I left out that we should talk about called the proof of work algorithm are naive. Blockchain is vulnerable to what's called a civil attack. This is when a bad actor creates a bunch of notes to get this report finitely large influence over the network. Once he has control of at least 51% of the network, he can validate his own transactions. It can spend the same money more than once or double spend to prevent this bitcoin mining nodes complete a series of really computationally expensive calculations to approve each transaction and get paid in bitcoin for their computational work.

Speaker 1:          07:52          In order for a newly generated block to be accepted by the network, minors must complete a proof of work, which covers all of the data in the block. At least 51% of nodes must reach consensus that a new block is valid for to be added to the blockchain. And so a bad actor has to have more computing power than half the network for bitcoin. This amounts and more computing power than the 500 fastest supercomputers in the world combined. No one has that much computing Palette, not even you. Mark Zuckerberg. Jarvis also helps me get it ready in the morning. Hell yeah. And that's why the bitcoin network is still secure. Even with a $50 billion market cap every week. New blockchains are being created with different use cases. There is so, so much to talk about when it comes to the blockchain and we've barely begun to explore what happens when we use the blockchain as a way to improve our AI.

Speaker 1:          08:44          It can help us verify the quality of our data and models create peer to peer exchanges where we trade them with each other, create never before possible businesses where we monetize aspects of Ai Development and even create independent organizations run entirely by AI. Last week's coding challenge winner is Charles David blocked. He used an earthquake dataset to predict the magnitude of future earthquakes given features like latitude and longitude. He built several optimizers from scratch for his neural network including Adam momentum and stochastic gradient descent. All three are viewable in his graph. Awesome work. Charles David Wizard of the week and the runner up is Parmender Singh who also implemented all three optimizers from scratch to find the local minima of a function. This week's coding challenge is to write a simple scheme to encrypt a dataset so only someone with its private key can access it. Check out the, read me for all the details and I'll announce a winner next week. Please subscribe to become a programming wizard. Check out this video right here and for now, I've got to invest in it theory. Um, so thanks for watching.