Speaker 1:          00:00          Hello world, it's to Raj and don't go anywhere. This is going to be one of the most important videos you've ever seen in your life. So sit down and enjoy the ride. What I'm going to do in this video is I'm going to build a voting APP, okay? And let me demo it first. Okay. This is my hello world voting APP. It's got three candidates and I'm going to vote for one. I'm going to pick one Rama and then click vote and the vote shows up. Okay? There are three candidates in this app. I voted and then the vote shows up and anybody who uses this app can vote and then that vote is going to show up in the web app. So you might be thinking, wait a second, it's so easy. Why are you demoing this? Because the difference between this voting app and a normal voting app is that this voting APP is unhackable.

Speaker 1:          00:44          That means that no one can modify the votes, the w, okay, so it is hackable, but it's hackable in that you wouldn't have to have access to the 500 fastest supercomputers in the world combined. That's how much computing power you would have to have in order to hack this. So it's basically unhackable unless you have that much computing power, which no one does. And this is called a decentralized application. Now you are probably used to building a centralized application. So am I right? That's what we do. We all have a web development, all of mobile development, all of it is centered around building centralized software. And we're going to talk about what centralized and decentralized are in a second. But that's the, that's the voting app we're going to do. That's the demo we're going to build today. I'm going to go through setting up the environment and all the tools you need to build it and then we'll build it ourselves.

Speaker 1:          01:36          But first let's talk a little bit about the worldwide web. Okay. So the web started off decentralized. What does that mean? If you are around in the early nineties and I was a little baby, but you know, I was still there. Uh, then if you want it to make a website, you would just buy a server, right? You buy a server that has a computer, you put it in your room and then you would put your webpage or your blog, they weren't even called blogs back then, but you're, you know, whenever you want it on your server or on your computer and then you, you owned that server because no one was offering to host your data for you. What that meant was the web consisted of a series of nodes that were all linked together, a very neutral playing field where everybody owned their data or the data that they contributed to the worldwide web.

Speaker 1:          02:23          That's how the web started off. But what happened was during the.com bubble, entrepreneurs realized that if you want it to provide value on top of this neutral playing field, then you would create some service, right? You create some service and that service would collect data and monetize it. And this per proved, extremely, extremely useful, right? We started hosting our data on Geo cities. If you remember, shout out to Geo cities or any of the old, you know, web hosting services. We started using, you know, a whole host of services that were centralized and what this meant was you didn't have to buy your own server. You could just use these services and have a very thin client. But what's happened is these services have become so massive that the web is now a scent. A set is, it's, it's basically a handful of huge nodes.

Speaker 1:          03:18          It's become centralized around a handful of of huge notes and these notes are Amazon, Google, Facebook, snapchat, Instagram. All data is routed through these all data requests, all queries data is routed through the central nodes and this is bad, really bad. And here's why we of course, the services provided great value to our lives. We use them every day, right? We, I use Google and all the services every day, they make our lives easier, but it's bad for four reasons. The first reason is that it shrinking our economy. What I mean by that is that in a good economy we monetize more and more, but in a bad economy we monetize less and less. And that's what's happening because data is the natural resource of our time. And because data is so centralized, that means the ownership of data is so centralized, there are less opportunities for people to generate value to generate capital because all the data is being collected, right?

Speaker 1:          04:19          Data is how you make money, right? As a society, we are starting to value more and more data and less and less labor. Right? Before we valued labor. Now not so much. It's all about the data and as this uh, economic trend progresses, it's going to only, the value of data is only going to increase over time. And because that data is so siloed right now, it's hard for normal people to make money off of it. You would have to be a part of one of these big corporations to do so. And that's not the future that we want. Right? Uh, so that's, that's a problem. The other problem is that, that this is just too much concentrated power, right? Knowledge is power, right? And knowledge is data, information is power. Information is data. And it's, it's just too much of an overhead God view of what everybody is doing for any of these companies to have Uber.

Speaker 1:          05:11          For example, I had a friend who will remain nameless who worked at Uber, who showed me God mode. And if you don't know God mode is what they are able to view all Uber rides that are happening obviously at the same time. So they can, they can basically predict, you know, who's having a one night stand or who is, you know, anything really personal details they can glean from this. And that's just one of many, many, many examples and that that is just too much power for any, any one entity to have. And that's just not good because it doesn't matter what our intentions were. This is a problem and we have no say in how our data is used, right? Once, once we exchange our data control of our data for access to a free service. And what this means is they can do anything with our data.

Speaker 1:          05:57          They can sell it to advertisers, they can use it to manipulate us, they can learn our personal details, they can sell it to the u s government or any governments really. And we just have no say in how this goes in the end. The last point is that we should be paid for our data. We need to, we are generating this valuable resource, this natural resource, and we should be paid for it. So a great book on this is called who owns the future by Jerome Linear. The dude looks really wild. He's got these long dreadlocks and he, you know, big Dude in Berkeley and he plays all these instruments. He's a really cool guy, but I mean, no one can talk about this in the way that your own linear can. He's one of the pioneers of the Internet. He now works at Microsoft research as a virtual reality, uh, researcher and a, yeah, so that's a great book.

Speaker 1:          06:42          And also, I mean, I wrote the book on decentralized applications. I don't really talk about it that much because the code is deprecated at this point. But, um, yeah, if you want to see a great book on decentralized applications, then check out my book. It's an O'Reilly book as well, but the code is deprecated, but the idea is remain. I just don't have time to keep maintain that code. I'm making videos like a madman. Anyway, back to this. So let's, let's talk about this decentralized versus centralized versus distributed. What is the difference? So a centralized application is what we're used to Google, Facebook, Amazon. What happens with the centralized application is we create a server and then we have a bunch of clients connect to that server. So everybody connects to these, this central point of authority that defines the rules of how the network works.

Speaker 1:          07:31          An example is Facebook, right? We, whenever we go to facebook.com we're, our browsers are acting as clients that in our browsers are requesting data from Facebook and posting data to Facebook. It's a central server and that's how pretty much all of the web works right now. It's easy. It was just easy to do. That's why we did it. And, but it's difficult to scale and it has a single point of failure, right? If someone takes down that data center, all of our data is lost. So that's centralized. Let me talk about distributed next, which is this right here, this image right here. So a distributed system is one worse computation is spread out across the network. So, um, actually all of the services that we use are distributed. So a service can be both centralized. That means there is a central point of authority and distributed as in the computation is spread across multiple nodes.

Speaker 1:          08:23          Because if you think about it, Facebook doesn't just have one giant server. They have several data centers that are scattered across the web and data is routed through the servers depending on where you are. And uh, so the services are both centralized and they're distributed. And so this having a distributed architecture speeds of computing, and it's just data latency, it increases bandwidth. There's a, there's a bunch of pros to having a distributed architecture. It's a little harder, but the pros are worth it. And that's why these big companies do that. Now, the last one I'm going to talk about are decentralized systems, like the middle picture right here. So for a decentralized system in a decentralized system, uh, you can take away one of those nodes and the network will still run. That means that no note is telling any other node what to do.

Speaker 1:          09:13          There is no central point of authority. All nodes are equal and the network in terms of their authority. Uh, so bitcoin is a, is an example of an, of a system of a network that is both distributed because it's a timestamp to public ledger. It's a, it's a database where everybody owns a copy of the data, right? They resides on multiple computers. So it's distributed and it's decentralized because if one node goes down, the network is still able to operate, right? You could take down, you know, 20 bitcoin miners, but bitcoin would still run. It's a, it's, it's a, it's a more resilient way of building software. It's faster software. The demand and failures are better handled. So examples of decentralized software are all of these crypto currencies that we look at. Bitcoin, ethereum lite coin, these are all decentralized systems. And when it comes to decentralized applications, um, there's really only one that satisfies my criteria, at least right now.

Speaker 1:          10:14          And that's called Steemit. And I'll talk about that in a second. But a steam at is one, what does a profitable decentralized application look like? So if we look at the web 2.0 stack, okay, let's look at the the web 2.0 stack. So anytime you want to build software and any kind of web APP or mobile app, you are using these tools right there. There are certain parts of a website or an APP that you need to use tools for, right? So four payments, you're going to use credit cards and paypal, stripe, some kind of API for monetization. You know, you'll, you'll develop some strategy like selling ads, pay wall and your content selling some good, uh, some goods, external data. You use a third party Api from some service, right? Like, um, clarify or any of these APIs for file storage, you use Amazon s three or Google cloud or you know, what have you.

Speaker 1:          11:04          And lastly for computation, you use Amazon [inaudible] or Heroku or you know, there's a lot of services out there because web 2.0 has been around for so long, but now we are moving into web 3.0 and that means that because of the invention of a certain set of technologies in order a bit torrent which maximize bandwidth, bitcoin, which allowed for decentralized consensus amongst a set of nodes in a system for the first time, uh, several of these technologies, we are now able to make decentralized apps. So the web is kind of like a pendulum and it started off as centralized and it start off as decentralized. It moved to centralized and now it's moving back to decentralized. And that is the mission of the many of many developers right now it's to breed, decentralize the web. And so there are tools out there that will let us do that.

Speaker 1:          11:57          A theory on Bitcoin, all these cryptocurrencies are for payments. That token model for monetization. Now this is a really interesting bit and I'll talk about the token model in a second. Oracle's for external data. Oracle's our third party data sources that you don't have to trust a human for, like you have to trust, um, stripe or any of these APIs to provide valid data. But an oracle is essentially a smart contract that has some data that you can trust, but it's run by machines for file storage. You would use a network like the interplanetary file system, which I'll talk about, which is essentially a big distributed hash table. And lastly, for a computation you would use etherium for example, which is a, which is a decentralized virtual machine. It's kind of like a decentralized Heroku that you could push code to, but it doesn't leave on one central server.

Speaker 1:          12:47          It's, it's, it's decentralized. And so I put rep, you know, ready for these bottom tube and these are in progress. But really like if you think about it, you can use all of these. It's, it's just not going to be at the, um, these tools aren't as evolved as, you know, the web 2.0 tools, but you can use all of them for sure. So what does, what does it look like? Well, there are four features that make up a profitable decentralized application. The first feature is that it's open source. So you might be asking, wait a second, if I open source my code, couldn't someone just steal it then? And now if you're using a traditional business model, yes. If a competitor can see your code, a lot of the times that he's your competitive advantage, they could then just use that code and then fork it and then profit off of your coat.

Speaker 1:          13:32          But in a decentralized application, if you're using a token business model, an APP coin model, then they could not take away from your network, right? Because it depends on the community of users. It depends on, um, it depends on the trust of your users and that you're, you're, you're users are profiting from your model as well. So people want to join the network that has the most trust, that's built the most trust over time. Trust is a moving concept. It's not just established once. You have to continually prove and reprove that trust. And so people want to go with the longest, a chain of trust, so to speak. The second feature is the use of cryptocurrency. So this is a, this is an image of, of uh, some random, uh, companies, uh, timeline for, for ICO or initial coin offering. But basically, um, the use of cryptocurrency is this.

Speaker 1:          14:27          So you know, their traditional models for monetization, right? The transaction fees, advertising revenues, but the cryptocurrency way is to do this. Okay? So you would allocate some scarce resource in your network using a scarce token, right? That's scarce resource could be storage space, it could be images, it could be videos, some scarce resources and scarce data. That's people are contributing to the network that, and you monetize that with an app coin, some kind of token. And what happens is users need this app co op coin to access the scarce resource. And because of that, you're creating a supply and a demand, right? You're, you're drinking, posing this artificial scarcity. And what that does is owners, all the scarce resource get paid in APP coins. So they get paid for their tweets and their images and the whatever data that they contribute. And what this does is it makes the value of the APP coin arise, right?

Speaker 1:          15:20          So this app coin is kind of like a hybrid asset. It's both a stock but it's also a currency. And so it's both. It's not right. So you can make, you can own it and you can just keep it as investment or you can use it and you or you could just use, do both, keep it, keep a part of it as an investment. And the other part has, has use of that, of that, of that APP. So that's one way in bitcoin does as well. File coin does as well, like in the fall coin network, miners of the scarce resorts storage space get paid in file coin and then people who want to store their data on the file coin network pay have to pay file coin to access it. And so there is this market that's been created and this can apply to any kind of decentralized application and a scarce resource could be anything, right? So steam, it is a great example of a decentralized application, right? Because, uh, there is

Speaker 1:          16:20          because there is a digital point system and people are getting paid for their scarce resource, which, which are their posts. As you can see here, they're the most valuable posts are the most paid posts and uh, it's open source. It uses cryptocurrency under the hood, but it's got a dollar rapper here, but anyone can pay and cryptocurrency. So Steven is a great example of a, of a working decentralized application. The third feature is decentralized consensus. So what I mean by that is the ability for a network to all agree upon everything that's happening in the APP. And only until very recently, this was not possible. Bitcoin proved that we could reach decentralized consensus using the proof of work algorithm. 51% of the nodes in the bitcoin network have to approve a transaction before it's made valid and added to the chain of blocks, the block chain.

Speaker 1:          17:13          And not just an, as they vote on the validity of a transaction, they also have to offer a proof of their computational work. And so what this means is they have to have, you have to have more computing power than 51% of the bitcoin network in order to fake a transaction. And that's where the 500 fastest supercomputers phrase I talked about comes from. And so that's, that was one very popular way of reaching decentralized consensus. And so another thing is the blockchain alone isn't enough. It's not just like you just take an application, sprinkle some blockchain on it, and you're good. No, blockchain is a, is a big part of it is a data structure that you would use, but it's only a part of the stack. So for big files, you're not going to store big files on a blockchain, right? For big files, you're going to store that on some kind of distributed hash table.

Speaker 1:          18:03          And one that I really like is called IPFS, which I'll talk about for feature for, but right, so you use a distributed hash table to store the data and then you, you'd use a blockchain for APP level constructs. These are timestamped constructs, like usernames and status updates and high scores. Anything that you need the network to agree on, agree upon. And so the reason you use a DHT and a blockchain is because the blockchain solves the major security issue of the HTS, which is not forcing nodes to trust each other on the validity of the data. So the DHT is more of like a dumb data store that no one controls and the block chain helps to DHT reach consensus on the data, which lets you create applications on top of it. Lastly, there's the idea of smart contracts, which are crypto economically secured bits of code, right?

Speaker 1:          18:56          So in a normal piece of code. Now here's an example. In a normal piece of code, you would upload it to some central computation engine like Heroku and then you would trust Heroku to compile that code and keep that code, uh, an unmodified just like you pushed. But in a smart contract, you don't have to trust any central source. You push it directly to a blockchain. Ideally the ethereum blockchain, because they have a touring complete block chain, which allows for loops and all sorts of application level constructs. But you would push some code to the ethereum blockchain and then it would run on that blockchain. And so everybody, every miner has a piece of that code and it's Crypto, economically secured. So it's that. What that means is it is a pre agreed upon snippet of code that wants deployed is unchangeable. It is immutable.

Speaker 1:          19:47          Okay, so that's a smart contract. And lastly, for a profitable decentralized application, there is no central point of failure. That means that you just could not take this application down if you want it to. So, right. So all of these big countries that try to block access like China to applications like Facebook, they could not do that for, for a decentralized application. Why? Well, one way is again, to use IPFS as your data store. So IPFS and I, I won the creator of, this was my roommate when, when he was writing the paper, and there's a lot, there's a lot. I could do an entire video series on IPFS. There's a lot here, but basically it is a replay. It is meant to be a replacement for http, which isn't the normal way in which we access websites on the Internet right now. So for IPFS there are certain technologies and you can see them here that that makeup it's stack.

Speaker 1:          20:42          But the idea for IPFS is that instead of Ip addressing our web, instead of Ip addressing our content, meaning we location address where some data is let's content address it and access it that way. So instead of going to a website by using its Ip address, we would use its content address, kind of like get right, like get has those, these hashes that represent data. So IPFS is essentially like a giant get tree, a miracle Dag as, as they call it in IPFS. We're all data is linked together and there's resiliency happening in the network as well. Bits and shards of data or replicated across multiple nodes. So you couldn't just take down some content address because there are multiple copies of it. They're constantly being replicated inside of the network. Uh, so you could take down a website by just ddosing it, right? But you could not DDoSs and IPFS node because the data is replicated.

Speaker 1:          21:42          It's not location addressed, it's content addressed. And there's a lot of reasons for creating IPFS that I could go into. But basically it helps us create a permanent web where links never die. So it's more resilient web then http. Okay. So, and it's, it's decentralized. So in, in general, these technologies are all away for us to build more autonomous software that is software that is independent of its creators. It's, it's, it's almost like where, you know, with AI and with blockchain and all of these very interesting new technologies, we are creating ways of removing the human from the loop. Because with humans there is always some kind of trust involved, right? Whether it's a taxi and you know, having to trust the taxi driver to give you a fair price or using some kind of meter, right? So you offload that trust onto the machine and so you don't have to trust a human and it just makes the whole process, the whole system better.

Speaker 1:          22:38          So with artificial intelligence and with blockchain, it's our way of making more autonomous software. It's almost like entities that live and exist independently on the Internet. And this was very exciting. So I have this image right here. So just we'll get the one on the box on the left. Let me just talk about that. So the, the, the old way of creating organizations companies was that humans at the edges and humans at the center, just humans. And those are boring old organizations. The next step is to have automation at the edges and humans at the center. So the assembly line is a great example. Robots are doing all the grunt work, but humans are overhead watching it now where we're heading towards our distributed autonomous organizations, which is what adapt is another word for it. And that means automation is at the center, the trust is in the blockchain.

Speaker 1:          23:25          It's in these distributed, decentralized technologies and humans are at the edges. So the community kind of supports this autonomous network. So like a decentralized Uber, the drivers would be at the edges of the network, but they would have more of a say in how the network operates than in a model like Uber, which is centralized. And lastly, you would have automation at the edge. It's an automation at the center and that is just the holy grail, right? Just pure Ai. So in the end, these technologies are all really related. Lastly, before we, before I go into the code, this blockchain and the ICO model is just a way for us to more closely approximate the, uh, the value generation and capital generation, right? That's what we're trying to do because a lot of times capital generation and value generation are just not aligned. What that, what I mean is people do things that are not providing a lot of value, but they get paid a lot of money like football players or Kim Kardashians or right.

Speaker 1:          24:26          All these people who are making millions of dollars but not really providing real value to society. Whereas the social impact causes that are fighting climate change and trying to solve cancer, they have to raise money. They're considered nonprofits. But with the blockchain model, we can more closely approximates this so we can, we can give these people more money. They can earn as much money as they deserve. And so it's a really exciting time if you want to monetize more social impact causes like volunteering or scientific research, like the people who were working on a theory, them are extremely wealthy. And some of the original scientists that worked on it, independent scientists who were doing research that was worthy of turning awards, they were, they were, they were incentivized with the ether coin, which is skyrocketed in value, right? So it's a way to more closely, you know, give value or capital to the people at generating real value for the world.

Speaker 1:          25:22          Let's get into our voting APP. So this is the first step is for us to set up our environment. So what we're gonna do is we're going through, just use etherium and I know I talked about IPFS. That's, that's where maybe a later tutorial right now, just a very, very simple application. We don't really need a distributed hash table for this because it's so simple. It's essentially just a smart contract that we deployed to a blockchain. And then we have a thin client that can access that smart contract on the blockchain, which is just html and Java script. So this is what it looks like, right? So we have the etherium blockchain, which is a blockchain like bitcoin, except it's a Turing complete. So that means we can, there is a scripting language associated with this that we can deploy to not just transactions but code.

Speaker 1:          26:08          We can have code run on the blockchain and then we can access that code just like we would have server. And so this is called the etherium virtual machine. And then we would have, we have some thin client, which is called web three js, which we're going to access this from. And we can do all of this from a web browser. So that's, that's, that's what it's gonna look like. So let's go ahead and set up our environment. Okay. So the first step is for us to download, um, the theory, I'm test RPC. Well this is a, this is an in memory blockchain and it's great for testing out a blockchain, having to download the actual blockchain. Okay. So we're going to go ahead and install that by running npm install ethereum js test RPC and web three in row. Now remember web three is our thin client that lets us access the blockchain, but basically test RPC is gonna let us create 10 test accounts that we can play with automatically.

Speaker 1:          27:03          And these accounts are going to be, are going to come preloaded with a hundred ethers. These are fake ethers. It's you also call them gas in etherium like this is how the network runs, like you make transactions and these transactions or how you deploy contracts to the blockchain, right? And so because it's happening on a test network, we don't have to pay anything at all, right? It's all free. But this is on the test network. So it's going to take a, it's going to, you know, download all this stuff and when it's done we're going to go to step two, which is creating a voting smart contract. Okay, now it's done. All right, so, so that was our first step. And so now we're going to create our voting smart contract. We're going to use [inaudible] language, which is called solidity for programmings are smart contract.

Speaker 1:          27:46          We're going to deploy that contract to the ethereum blockchain and it's going to consist of two functions. One is going to return the total votes a candidate has received and the other two increment the vote count of four candidate. And these deployed contracts are immutable. If we have any changes we want to make, we would just deploy a new contract unlike in irregular web app where you could just modify the existing code. You can't do that. These are, these are, these are immutable pieces of code. So we would just upload a new contract if we wanted to make any changes, uh, and, and we can link them back to each other. I'll get if we want it to. But to do this, we're going to first install the solidity compiler, which is also an Mpm, a node package. So we can run NPM install Sol, see the solidity compiler. And when we're done with that, we'll go ahead and code this thing, right? So let's write some solidity here, shall we? So we're going to start off by saying, uh, we're going to specify, we're going to start up by specifying the version of the compiler that we want to use.

Speaker 1:          28:51          Whole 0.41. Now we're going to create our contracts. So we could think of this as kind of like a, a class in whatever your favorite object oriented language is. Okay? So, so this is our voting contract. Our first bit is to create a mapping fuel, which is the equivalent of creating an associative array or hash. And what this is going to do is we're going to say, uh, we're going to say you can't Tate. And this is a public, this is the number of votes we've received. It's a key of the map in the key of the mapping is the candidate name is Stuart has the type bytes, 32 in the value is an unsigned integer to store the vote count. Okay? So that is our, uh, number of votes received that we're going to store here now. So literally, so solidity doesn't let us pass in an array of strings in the constructor yet. So we're going to use an array of bytes, 32 bytes, 32,

Speaker 2:          29:53          okay.

Speaker 1:          29:54          Uh, to store the list of candidates, right? And we want to have three candidates. So I'm going to say candidate list. Then we're going to create our constructure, our con, our constructor, which is going to be called once when we deploy the contract, right? So this is our voting constructor, right? For our class it's going to be uptight, block 32, and the parameter is going to be the candidate names. And inside of the constructor we can set our variable candidate list candidate list to the parameter candidate names, which is how we initialize it. Okay? So then when we deploy the contract, when a pass an array of candidates, we will be contesting in the, in the election. And so once we have that, we can return, it will create a function that's going to return the total votes for the candidate that candidate has received so far. And the, again, the parameter is going to be the candidate and then it's going to return the total votes as a, uh, integer k as an integer. And so yes, we can go ahead and return it. Votes received candidates. Now we're going to, we're going to create, wait, so, so now we have two more functions. So the next function is going to be to vote for the candidate, right? So this is the function that increments the vote count for the specified candidate. And it's equivalent to casting about, so for voting for a candidate, so voting for candidate, that's going to be bytes 32 for a given candidate, we want to say if it's a valid candidate. So if the candidate is valid and we'll write that, that function last. So if this candidate is valid,

Speaker 1:          32:04          votes received four candidate plus equals one.

Speaker 1:          32:15          So if, if, if it is a valid candidate, then and only then do we increment the vote count. If not, then we, then we don't. So this last function is going to help us decide if a candidate is valid or not. So we'll say bytes 32 candidate returns. Bull. Okay. So we're going to say, okay, we're going to create a loop. And now here is the completeness coming out, right? Cause because we can do loops. We couldn't do loops in a Bitcoin scripting language as Toshi did this for security reasons. But, um, overall we need this if we're going to be able to build robust, capable, uh, applications on top of it. So we're going to say go through the list of candidates and if the given candidate is inside of the list of candidates, then and only then do we know that it is a, in fact a valid candidate because we pass in a candidate name from our thin web client. Okay. So that's it for our, uh, code. Let me return false at the end. Return. False. Okay. That's it for, that's it for our solidity code. And then for our client, our client is going to be simple html, right? So we have some table that's going to show this, the three candidates, Roma, nick and Jose. And then we have um, uh, this, this on click code. That's going to say once you type in a name like Rama, and then you hit boat, it's going to execute this function, vote for candidate. And then it's going to update that. So in the javascript section, we can see what this code looks like.

Speaker 2:          33:48          Okay.

Speaker 1:          33:49          Right here. But what happens is, uh, we say we create a new web three object. We then retrieve that that contract that we've deployed to the blockchain. And then we vote for the candidate or we, we retrieve the content that we deployed to the blockchain. And then we use that. We then we then update the, we then send the vote from the string, the string vote that we did in the web app to the blockchain to update the candidate. And then we can retrieve it from the blockchain and then display it in the html web app. So, uh, so then we can say, okay, so after riding our smart contract, we're going to use web three js to deploy our APP and interact with it. So our first step, Lee makes us bigger, is to open up the node console. And then we're going to say, okay, so web three, we're going to initialize our web three object require web three. Oh Shit. Okay, hold on. Web three equals require web three. Okay. And so that,

Speaker 1:          35:02          okay, so we did that. And so now we're going to say web three equals new web three and we'll create a, an instance, a local host instance for this to let us access the ethereum blockchain, the test chain from http. So it's kind of like an interface between http and the etherium test. HARPC chain clothes. Okay, we did that and now we can ensure that web three a. Dot. JS initialized by querying the accounts on the blockchain. All right, we've, we've, we've queried those accounts. And lastly, we're going to compile this contract by reading it.

Speaker 2:          35:49          Hold on.

Speaker 1:          35:53          We're going to compile this contract by reading it directly. So I called it voting, got solidity, converting it into a string. Got It. Then we'll say require the solidity compiler

Speaker 1:          36:14          and then finally we can then compile the contract and deploy it by saying compile code equals solidity dot compile code. Okay. And so once I've done that, then I can interact with the contract via that, uh, no job via that node. Dot. Js Console, or we could just interact with it directly from our, um, html interface, which I already have here. So let's go ahead and interact with it from our html interface. So let's see. I'll just say, um, you know, Rama, again, to see if it up increments and it increments. Okay. So that is, that is my simple voting app demo. All the code for this is in the description. Check it out on get hub. If you have any comments, uh, please feel free to comment. I love Saint Comments, uh, for, for my videos. And, uh, I hope you found this useful. Hey, I hope you really liked this video and if you did, please hit that subscribe button for now. I've got to go read, decentralize the web. So thanks for watching.