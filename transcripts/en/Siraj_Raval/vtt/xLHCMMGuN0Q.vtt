WEBVTT

1
00:00:00.090 --> 00:00:01.620
Hello world,
it's Saroj.

2
00:00:01.650 --> 00:00:05.880
And today we're going to be talking about evolutionary algorithms in the context

3
00:00:06.060 --> 00:00:07.980
of building a tetris AI.

4
00:00:08.190 --> 00:00:12.960
So I've only made one video on evolutionary algorithms ever and it was like

5
00:00:12.990 --> 00:00:15.540
three months ago.
So I'm really excited to make this video.

6
00:00:15.990 --> 00:00:17.040
We're going to use evolution,

7
00:00:17.070 --> 00:00:20.490
we're going to use an evolutionary approach to build a tetris AI.

8
00:00:20.760 --> 00:00:25.230
And this is going to be using javascript.
I know javascript for once.

9
00:00:25.290 --> 00:00:29.060
So,
uh,
let's get started.
And you might be asking why javascript?
Well,

10
00:00:29.100 --> 00:00:33.180
the reason is,
well,
two reasons.
One,
javascript is the language of the web.

11
00:00:33.210 --> 00:00:36.900
It's not going anywhere.
It is a very messy language.
It's a beast.

12
00:00:37.110 --> 00:00:40.860
People are always tacking on different components to it.
Uh,
but regardless,

13
00:00:40.861 --> 00:00:44.910
it is the language of the web.
And second of all,
why not?
Because we,

14
00:00:44.940 --> 00:00:48.060
I want to see more machine learning happening in the browser.
And yes,

15
00:00:48.061 --> 00:00:51.930
we could make a python shell and then call it from some front end,
you know,
like,

16
00:00:52.110 --> 00:00:56.970
uh,
angular or something.
But to do it all in Java script just seems cleaner.

17
00:00:57.120 --> 00:01:01.920
And even Andre Car Pafi has made a javascript library called called comnet dot.

18
00:01:01.921 --> 00:01:05.430
Js.
So let's just do some javascript and just see what it's like.

19
00:01:05.520 --> 00:01:09.480
If you've never done javascript before,
that's okay.
The code is totally readable.

20
00:01:09.481 --> 00:01:10.530
It's in the description.

21
00:01:10.680 --> 00:01:15.300
And I've made sure to comment every single line of code so it's very readable.

22
00:01:15.330 --> 00:01:18.100
So don't even worry if you've never done javascript before cause this is going

23
00:01:18.101 --> 00:01:20.310
to be awesome.
And plus it's more visual.

24
00:01:20.311 --> 00:01:22.290
See like we could see it in the browser right now.

25
00:01:22.950 --> 00:01:26.610
We can compile it as we go and see the changes we make.
Uh,
but yeah,
anyway,

26
00:01:26.611 --> 00:01:27.840
so that's what we're going to build.

27
00:01:27.990 --> 00:01:31.680
And this is the little demo that you see here of what we're going to build.
Okay.

28
00:01:31.681 --> 00:01:33.210
So,
um,

29
00:01:33.420 --> 00:01:36.490
so I'm going to start off with a presentation and the presentation is in an Ip

30
00:01:36.491 --> 00:01:38.430
phone notebook,
not that we're using python.
I just,

31
00:01:38.610 --> 00:01:42.680
I think it's a good format to talk about what we're going to do.
Okay.
So,
uh,

32
00:01:42.780 --> 00:01:46.020
we're gonna be building an evolutionary algorithm for tetris.

33
00:01:46.260 --> 00:01:50.010
So the code in total is like a thousand lines of Java script.

34
00:01:50.011 --> 00:01:51.330
So it's like a lot of javascript.

35
00:01:51.570 --> 00:01:53.610
We're not going to be coding at all in this video.

36
00:01:53.730 --> 00:01:58.730
What we will do is we'll code the first 100 lines and the first 100 lines

37
00:01:59.340 --> 00:02:02.880
constitute the highest level approach.
So the initialization function,

38
00:02:02.881 --> 00:02:04.350
and we're going to call all the help,

39
00:02:04.530 --> 00:02:08.660
all the helper methods inside of that initial 100 lines.
So you'll be,

40
00:02:08.700 --> 00:02:12.780
you'll get to see exactly what the structure of the high level architecture is

41
00:02:12.930 --> 00:02:16.380
and a very dense amount of code.
And then we'll talk about the helper functions.

42
00:02:16.410 --> 00:02:21.060
Okay?
So get ready for this.
Uh,
but we're going to go over all one,
1000 lines.

43
00:02:21.330 --> 00:02:24.300
So what is,
what are evolutionary algorithms?

44
00:02:24.330 --> 00:02:28.700
So one thing I want to clarify is that evolutionary,
it means genetic.

45
00:02:28.710 --> 00:02:31.290
They're the same thing.
Evolutionary Algorithms,
genetic algorithms,

46
00:02:31.410 --> 00:02:35.460
they're the same thing.
And there are three parts to an evolutionary algorithm.

47
00:02:35.700 --> 00:02:38.610
There's selection,
crossover,
and mutation.

48
00:02:38.970 --> 00:02:42.150
So the idea is to replicate Darwinian evolution,

49
00:02:42.600 --> 00:02:44.280
evolutionary algorithms,
right?

50
00:02:44.610 --> 00:02:47.370
Evolutionary Algorithms are based on Darwinian evolution.

51
00:02:47.700 --> 00:02:49.740
And just like in Darwinian evolution,

52
00:02:49.890 --> 00:02:54.890
we have a population and the population breeds and only the fittest survive.

53
00:02:55.680 --> 00:02:57.690
So let's talk about that a little more in detail.

54
00:02:58.590 --> 00:03:01.450
So for one step one is called selection.

55
00:03:01.451 --> 00:03:05.830
So what happens is we create a population of genomes and genomes,

56
00:03:05.950 --> 00:03:09.490
they're also called chromosomes sometimes,
but I like to call them genomes.

57
00:03:09.760 --> 00:03:10.930
Genomes can be anything.

58
00:03:10.930 --> 00:03:14.620
There are some entity that you want to improve over time.

59
00:03:14.830 --> 00:03:19.040
So let's say we were creating some kind of like three d simulation,
uh,

60
00:03:19.060 --> 00:03:21.970
and we wanted to create a bipedal robot.
Let's,

61
00:03:21.971 --> 00:03:26.350
we would probably have a bunch of like bipedal spiders or you know,

62
00:03:27.040 --> 00:03:29.290
quadro Quadro peds or whatever they're called.

63
00:03:29.530 --> 00:03:32.080
But we would have a lot of them and they would be our genomes because we want

64
00:03:32.081 --> 00:03:35.410
them to improve,
to breed and improve over time.
And the,

65
00:03:35.650 --> 00:03:40.630
the idea is that each genome has multiple genes and the genes are akin to

66
00:03:40.631 --> 00:03:42.040
parameters.
They mean the same thing.

67
00:03:42.370 --> 00:03:45.100
Each genome has a set of genes or parameters.

68
00:03:45.460 --> 00:03:50.230
And what happens is we use a fitness function to select what the best ones are.

69
00:03:50.470 --> 00:03:52.990
And so the fitness function can be whatever we decide,
you know,

70
00:03:52.991 --> 00:03:57.070
it could be like whoever is able to walk for a certain threshold,

71
00:03:57.071 --> 00:04:00.340
like let's let's say two meters,
if you,
if you can walk past two meters,

72
00:04:00.810 --> 00:04:04.480
you get to breed.
Congrats.
Congratulations.
So something like that,
right?

73
00:04:04.720 --> 00:04:07.390
And that's the selection part.

74
00:04:07.391 --> 00:04:11.770
We select through a fitness function who is fit to breathe.

75
00:04:12.220 --> 00:04:15.790
And once we get done with selection and we move on to step two and step two is

76
00:04:15.791 --> 00:04:19.700
crossover.
It's a crossover means reproduction.
So the fittest,
uh,

77
00:04:19.810 --> 00:04:23.830
genomes get to reproduce and reproduction can mean different things.

78
00:04:23.831 --> 00:04:27.940
But we have some sort of a merging computation that mean that is a kin to

79
00:04:27.941 --> 00:04:28.774
reproduction.

80
00:04:28.840 --> 00:04:32.590
So it could be like we take both of those winning spiders or the ones that are

81
00:04:32.591 --> 00:04:36.220
fittest and then we,
we vectorize them or turn them,

82
00:04:36.580 --> 00:04:39.940
find some way to convert them into a scaler and then take those two scalers and

83
00:04:39.941 --> 00:04:43.960
multiply them together.
And then we get some output scaler and an output scaler.

84
00:04:43.961 --> 00:04:47.710
And then from that scalar we reverted back into a,

85
00:04:47.830 --> 00:04:50.740
like a three d spider.
You know what I mean?
So it's,
it's,

86
00:04:51.070 --> 00:04:55.660
it's breeding and we'll,
we'll talk about what this crossover function is,

87
00:04:55.661 --> 00:05:00.661
but it's entirely application dependence and that's going to create a set of

88
00:05:00.701 --> 00:05:03.580
offspring and the offspring are the next generation there.

89
00:05:03.660 --> 00:05:08.660
There are a new population and once we have these set of offspring,

90
00:05:08.800 --> 00:05:11.020
when the fittest genomes breed,

91
00:05:11.140 --> 00:05:15.160
then we performed the last step and the last step is mutation and mutation is

92
00:05:15.161 --> 00:05:19.330
just randomly editing the genes or parameters in some way in the hope of

93
00:05:19.331 --> 00:05:23.350
creating more beneficial features in the future.
So we have a set of genomes,

94
00:05:23.530 --> 00:05:26.380
they try out whatever the task is,

95
00:05:26.381 --> 00:05:31.381
the objective and the fittest ones that are defined by a fitness function get to

96
00:05:31.571 --> 00:05:32.170
breed.

97
00:05:32.170 --> 00:05:36.410
And then which just crossover and then we take that new population and we mutate

98
00:05:36.411 --> 00:05:39.070
it using some mutation function,
which could just be,

99
00:05:39.460 --> 00:05:44.460
it could just be like multiplying the scaler by a random value or something.

100
00:05:45.160 --> 00:05:49.360
And then we just continue that process.
So this is a map of what it looks like,

101
00:05:49.361 --> 00:05:54.100
right?
We initialize a population and then of genomes we performed selection,

102
00:05:54.250 --> 00:05:55.090
crossover,

103
00:05:55.390 --> 00:05:59.210
and then you mutate them and then we repeat the process for as many generations

104
00:05:59.211 --> 00:06:03.740
as we want or as many generations as it takes to reach the objective,

105
00:06:03.950 --> 00:06:06.380
whatever that objective is.
And so you might be asking,

106
00:06:06.381 --> 00:06:10.970
well why haven't we been using this?
Right?
Evolution is all its nature.

107
00:06:10.971 --> 00:06:13.370
We should be using this more often.
Well,

108
00:06:13.430 --> 00:06:15.560
let me talk about why we don't use this more often.

109
00:06:16.490 --> 00:06:20.240
So one use case is neuro evolution,
right?

110
00:06:20.241 --> 00:06:23.470
So neuro evolution is this really cool idea.
And this,

111
00:06:23.471 --> 00:06:25.070
this game is a great example of it.

112
00:06:25.370 --> 00:06:28.580
But the idea is that we have a neural network,
right?
Like always,

113
00:06:28.581 --> 00:06:30.530
we have a neural network and it's,
it's up to,

114
00:06:30.531 --> 00:06:32.870
it's optimizing for an objective function.
And in this case,

115
00:06:32.871 --> 00:06:36.650
in the case of Super Mario,
this is an example of neural evolution.
The,

116
00:06:36.680 --> 00:06:38.090
the idea is to,

117
00:06:38.091 --> 00:06:41.000
the objective is to beat the game and the shortest amount of time,

118
00:06:41.001 --> 00:06:44.990
like minimizing the time spent for a lap is the objective function.

119
00:06:45.530 --> 00:06:47.780
And we use an a neural network to do that.

120
00:06:47.870 --> 00:06:52.870
And so normally we would use backpropagation to find the optimal weight values,

121
00:06:53.361 --> 00:06:54.194
right?

122
00:06:54.860 --> 00:06:59.840
But we could also use neural evolution so we could think of the weight values as

123
00:06:59.841 --> 00:07:00.530
genomes.

124
00:07:00.530 --> 00:07:04.880
And then we performed the whole evolutionary process instead of back propagating

125
00:07:04.881 --> 00:07:09.140
where we take some input data,
we propagate it through each layer,

126
00:07:09.380 --> 00:07:10.910
and then we have an output value,

127
00:07:10.940 --> 00:07:14.540
and then we take that output value and then we have our expected value.

128
00:07:14.570 --> 00:07:15.770
Hopefully it's labeled data,

129
00:07:16.040 --> 00:07:18.500
and then we find a difference between the two to get an error value.

130
00:07:18.650 --> 00:07:21.860
And then we use that error value to calculate the partial derivative with

131
00:07:21.861 --> 00:07:25.790
respect to each layer going backwards and then multiply it by the weights to

132
00:07:25.791 --> 00:07:28.250
update our network instead of doing that.
That's the,

133
00:07:28.251 --> 00:07:31.220
that's the normal way with backpropagation.
Instead of doing that,

134
00:07:31.640 --> 00:07:36.640
we use an evolutionary algorithm so that we evolve the weights through crossover

135
00:07:37.671 --> 00:07:39.740
and mutation.
And so

136
00:07:41.760 --> 00:07:46.280
why you might be asking which one is better.
So in most cases,
in most cases,

137
00:07:46.430 --> 00:07:50.270
backpropagation is still the most popular.
It's still given the best results,

138
00:07:50.420 --> 00:07:53.810
but evolutionary algorithms are promising.
I mean,

139
00:07:53.811 --> 00:07:56.240
they've been around since the 80s right?
It's not like,

140
00:07:56.270 --> 00:07:59.120
it's not like there's something new.
They,
I mean it's a very intuitive idea,

141
00:07:59.300 --> 00:08:04.300
but they can give really good results intuitively speaking.

142
00:08:04.341 --> 00:08:09.150
Like I feel like they can,
and open AI released a paper recently,
um,

143
00:08:09.410 --> 00:08:10.161
what was it called?

144
00:08:10.161 --> 00:08:15.161
But it was about like evolutionary algorithms for open AI evolutionary

145
00:08:16.580 --> 00:08:17.060
algorithms.

146
00:08:17.060 --> 00:08:21.290
But it was a cool paper evolution strategies as a scalable alternative to

147
00:08:21.440 --> 00:08:23.090
reinforcement learning.
That is the one.

148
00:08:23.270 --> 00:08:25.910
So definitely check out that blog post if you want to learn more about a

149
00:08:25.911 --> 00:08:28.670
evolutionary algorithms.
I mean,
I'm going to be talking about it in this video,

150
00:08:28.671 --> 00:08:32.330
but that's another,
that's another resource to check out.
Um,
but anyway,

151
00:08:33.420 --> 00:08:37.940
the thing is gradient descent is great at optimizing a neural networks,

152
00:08:37.941 --> 00:08:41.210
but sometimes grading dissent doesn't converge to the global minimum.

153
00:08:41.240 --> 00:08:44.000
It converges to the local Minima,
which is like,
if,

154
00:08:44.010 --> 00:08:49.010
if we consider like the optimization options as a,
uh,
you know,

155
00:08:49.070 --> 00:08:50.450
like a very bendy curve,

156
00:08:50.570 --> 00:08:52.760
it will find the local minimum instead of the global minimum,

157
00:08:52.761 --> 00:08:57.120
which means the actual lowest points.
And so as a search strategy,

158
00:08:57.150 --> 00:09:01.800
it could sometimes be beat by evolutionary algorithms.

159
00:09:01.920 --> 00:09:04.650
But we,
I just haven't seen it very compelling use case for it.

160
00:09:04.830 --> 00:09:08.280
But there is promise.
I think it's a great technique and I think as we

161
00:09:09.780 --> 00:09:12.360
not,
I think as we improve our algorithms,

162
00:09:12.660 --> 00:09:17.460
we will see evolutionary algorithms play more into machine learning in general.

163
00:09:17.580 --> 00:09:21.990
That's what,
that's what,
that's what I believe will happen.
So and,
and also like,

164
00:09:22.050 --> 00:09:25.410
uh,
there,
there are also able to discover entire neural networks.

165
00:09:25.530 --> 00:09:27.750
So instead of just discovering the hyper parameters,

166
00:09:27.930 --> 00:09:30.450
it would discover the entire neural network.
What do I mean?

167
00:09:30.600 --> 00:09:34.410
So you know how we have like multiple neural networks like neural networks,
zoos,

168
00:09:34.920 --> 00:09:38.160
and each of these networks is optimized for a different use case,
right?

169
00:09:38.190 --> 00:09:42.660
Some networks are used for feet up for time series data and then some networks

170
00:09:42.661 --> 00:09:44.250
are used for scalar data.

171
00:09:44.340 --> 00:09:48.000
Some networks are used for binary data and we have so many different types of

172
00:09:48.001 --> 00:09:48.720
networks.

173
00:09:48.720 --> 00:09:53.370
What if we could learn what the optimal neural network architecture is for a use

174
00:09:53.371 --> 00:09:53.970
case?

175
00:09:53.970 --> 00:09:58.710
And so this is a great example of when evolutionary algorithms would be great.

176
00:09:58.950 --> 00:10:02.520
And this is what something that backpack,
verdict backpropagation can't do.

177
00:10:02.760 --> 00:10:05.280
Backpropagation is about optimizing a single neural network.

178
00:10:05.460 --> 00:10:06.960
But evolutionary algorithms can,

179
00:10:07.020 --> 00:10:11.400
can optimize for the entire type of neural networks.
So a lot of promise there.

180
00:10:11.760 --> 00:10:14.850
Okay,
so enough about that.
So what is it in the context of Tetris?

181
00:10:15.700 --> 00:10:17.700
Because then the contents of Tetris,
this is how it works.

182
00:10:18.030 --> 00:10:22.410
We initialize a population of 50 genomes.
Okay?
So what our genomes in our case,

183
00:10:22.500 --> 00:10:24.330
so notice right here,
let me make this bigger.

184
00:10:25.230 --> 00:10:29.070
So 50 genomes in our case are these,

185
00:10:30.150 --> 00:10:33.030
hold on.
These values right here,
not all.

186
00:10:33.031 --> 00:10:36.150
They see like these seven values right here in these brackets.

187
00:10:36.540 --> 00:10:39.930
So these are weights values,
okay?
And we'll talk about what each of them mean.

188
00:10:40.050 --> 00:10:44.700
But these,
this set of weights is our single genome.

189
00:10:44.970 --> 00:10:48.720
That's what we consider a genome.
A genome isn't an AI like a Bot.

190
00:10:48.870 --> 00:10:51.630
A genome isn't a block that's falling.

191
00:10:51.690 --> 00:10:56.210
A genome is this set of weight values that we improve over time,
that the,

192
00:10:56.370 --> 00:10:59.730
that the agent that the AI uses to decide how to play the game.

193
00:11:00.060 --> 00:11:05.060
So the agent makes decisions based on these values based on this genome value.

194
00:11:05.400 --> 00:11:07.200
And if we can improve that genome value,

195
00:11:07.201 --> 00:11:12.201
these wait values of and over time and these values tell the AI where to move,

196
00:11:12.510 --> 00:11:14.880
then we're going to have some interesting results,
right?

197
00:11:15.000 --> 00:11:19.020
So we initialize a population of 50 of these,
right?
50 of these sets of values,

198
00:11:19.050 --> 00:11:22.590
these seven parameter values,
and it was right.
So each of them,

199
00:11:22.620 --> 00:11:24.540
each genome has seven parameter values.

200
00:11:25.530 --> 00:11:29.490
Our Ai will make a move based on them and so it's going to try out all the

201
00:11:29.491 --> 00:11:33.750
possible moves based on each genome and the current population to make a single

202
00:11:33.751 --> 00:11:34.260
move.

203
00:11:34.260 --> 00:11:39.260
So each genome is going to help the AI make a bunch of possible moves and it's

204
00:11:39.680 --> 00:11:43.900
going to pick the absolute best one for that genome using some,
uh,

205
00:11:43.990 --> 00:11:46.650
value or measure that we decide that I'll show you.

206
00:11:46.950 --> 00:11:49.890
And then it'll keep doing that and then the best genomes will evolve.

207
00:11:49.891 --> 00:11:53.530
So we'll take both sets of parameters and we'll combine them through some

208
00:11:53.531 --> 00:11:57.340
processed crossover that we'll talk about and we'll create a new set of genomes

209
00:11:57.341 --> 00:12:02.341
and we'll keep going until we get our AI to get to the high score of 500.

210
00:12:02.710 --> 00:12:04.360
Okay.
And this,
this has been running for a while,

211
00:12:04.361 --> 00:12:07.930
so we're already up there and we could speed this up as well.
But,
um,

212
00:12:08.860 --> 00:12:10.960
that's the idea.
And so in terms of Tetris,

213
00:12:10.970 --> 00:12:13.570
I'm hoping you know how to play Tetris.
You probably do,

214
00:12:13.750 --> 00:12:15.160
but each time a block moves down,

215
00:12:15.161 --> 00:12:19.510
the is incremented by one and when a row is cleared,
what do I mean by cleared?

216
00:12:20.170 --> 00:12:24.460
Like when all of the values like going across from left to right are filled,

217
00:12:24.520 --> 00:12:27.010
then that row disappears.
And then we get,

218
00:12:27.011 --> 00:12:30.730
we gain a certain amount right to the score.
So there's two ways to gain points.

219
00:12:30.731 --> 00:12:35.230
One is to,
uh,
make the block move down without reaching the ceiling.

220
00:12:35.380 --> 00:12:39.280
And the second is to have a row clear and the goal is to get to 500 without the

221
00:12:39.281 --> 00:12:42.610
blocks stacking up over the ceiling.
And the ceiling is this top row up here.

222
00:12:42.970 --> 00:12:46.420
Okay?
So that's the basic idea.
So let's go ahead and,
uh,

223
00:12:47.110 --> 00:12:48.760
right out the first part of this code.
Okay.

224
00:12:48.761 --> 00:12:51.190
So we're going to write out the high level code and then I'm going to talk about

225
00:12:51.191 --> 00:12:51.971
the helper functions.

226
00:12:51.971 --> 00:12:54.790
Because we've got about a thousand lines of Java script to get through.

227
00:12:54.791 --> 00:12:57.270
So let's get started.
Okay.
So,
um,

228
00:12:58.270 --> 00:13:00.970
the first step is for us to create a 10 by 20 grid,
right?

229
00:13:01.090 --> 00:13:04.330
That grid that you saw right here,
we want to create decorative,
so right,

230
00:13:04.331 --> 00:13:08.560
it's just a,
it's just a matrix.
Create a 10 by 20 grid,
create the game grid,

231
00:13:08.980 --> 00:13:13.210
which is 10 by 20.
And let me make this bigger.
Uh,
there we go.

232
00:13:14.080 --> 00:13:18.580
All right.
And so let me pay status cause it's quite a lot.
Okay.

233
00:13:18.581 --> 00:13:23.230
So here we have our grid and our grid is that 10 by 20 matrix that we just saw.

234
00:13:23.260 --> 00:13:24.250
That's our game grid.

235
00:13:24.580 --> 00:13:27.910
And then we're going to define what our block shapes look like.
There's,

236
00:13:28.090 --> 00:13:31.960
there's an eye shaped block,
there's a j shape,
there's an l shaped block,
right?

237
00:13:32.260 --> 00:13:36.550
What are these blockchain is going to be and we define them as a set of,
um,

238
00:13:36.880 --> 00:13:39.610
nested arrays,
right?
And these are basically,

239
00:13:39.790 --> 00:13:44.500
these are coordinates on the grid that we want to fill and notice how this is

240
00:13:44.501 --> 00:13:47.440
how it looks like.
Right?
Right.
So one is like a,
you know,

241
00:13:47.740 --> 00:13:51.610
like just straight across.
And then one is like a z.
One is like an l,

242
00:13:51.640 --> 00:13:55.360
but it's rotated,
right?
So these are,
these are our block shapes that we defined.

243
00:13:55.510 --> 00:13:58.390
So we defined our grid,
then we define our block shapes,

244
00:13:58.600 --> 00:14:02.410
and then we define our block colors.
So,
and these are just a hex values,

245
00:14:02.500 --> 00:14:06.430
hexadecimal values that define the color code,
right?
Good old javascript.

246
00:14:06.640 --> 00:14:09.890
So those are our initial function.
So let's keep on writing them.
We have,

247
00:14:09.940 --> 00:14:14.030
we have quite a few,
uh,
global variables here to it to write out.
But,
uh,

248
00:14:14.050 --> 00:14:16.720
we want to seed our,
um,

249
00:14:17.530 --> 00:14:21.550
we want to seed our code so that it's reproducible.
And this is four d.

250
00:14:21.730 --> 00:14:23.860
This makes our code deterministic.
What does this mean?

251
00:14:24.100 --> 00:14:26.650
This means that we're going to have a lot of randomness in our code,

252
00:14:26.651 --> 00:14:28.900
like we're going to call the random function,
uh,
quite a bit.

253
00:14:29.140 --> 00:14:34.140
And what this means is that whenever we compile the game over and over again,

254
00:14:34.690 --> 00:14:38.200
it's going to start off from the same point.
So the generated values,

255
00:14:38.201 --> 00:14:41.140
the randomly generated values are going to be the same every time.

256
00:14:41.380 --> 00:14:44.620
And that's good because we want to debug our code and we want to make sure that

257
00:14:44.800 --> 00:14:46.600
we have certain values.
So it's good for debugging.

258
00:14:46.920 --> 00:14:49.690
That's what we see at our code.
We do that a lot in machine learning in general.

259
00:14:49.930 --> 00:14:53.690
So now we're going to define a set of parameters and these perimeters are going

260
00:14:53.691 --> 00:14:57.500
to be the block shapes.
Let me just write that out in all caps.
Block shapes,

261
00:14:57.920 --> 00:15:02.500
block shapes.
Okay,
so
what are these block shapes?

262
00:15:02.540 --> 00:15:03.920
So we want our current shape,

263
00:15:03.921 --> 00:15:06.170
we want to keep track of the current block that we're on.

264
00:15:06.171 --> 00:15:11.171
So we'll say well for its x value is going to be zero and then it's why value is

265
00:15:11.301 --> 00:15:11.900
going to be zero.

266
00:15:11.900 --> 00:15:15.470
So these are its initial coordinates that we're going to update over time and

267
00:15:15.471 --> 00:15:16.550
then we have its shape,

268
00:15:16.551 --> 00:15:19.490
which is going to be undefined that we're going to update as well.
Right?

269
00:15:19.760 --> 00:15:22.610
Like which,
which of these,
you know,
Ij l is,
is it going to be,

270
00:15:22.970 --> 00:15:25.140
and then we have our upcoming shape.

271
00:15:25.141 --> 00:15:27.410
So we have our current shape and then we want our upcoming shape.

272
00:15:27.411 --> 00:15:30.530
We want our AI to know what's coming up.
Okay.

273
00:15:30.531 --> 00:15:33.050
And so where are we going to store all of these blocks?

274
00:15:33.051 --> 00:15:35.600
What we're going to create what's called a bag.
We'll just call it a bag,

275
00:15:35.601 --> 00:15:40.400
but it's going to store all of the upcoming shapes or blocks,

276
00:15:40.401 --> 00:15:42.770
whatever you want to call it,
shapes,
block,
same thing.
Uh,

277
00:15:42.771 --> 00:15:46.170
we'll store both of them.
So we have that.
And then,
uh,

278
00:15:47.210 --> 00:15:49.400
once we have that will define an index.

279
00:15:49.430 --> 00:15:52.720
So this is going to define where we are in the bag.
Like what,

280
00:15:52.730 --> 00:15:57.560
what position block are we or shape are we using?
And then,
yeah,

281
00:15:57.561 --> 00:15:58.970
that's it for our block shapes.

282
00:15:59.150 --> 00:16:02.590
And now we can define our next set of parameters,

283
00:16:02.600 --> 00:16:05.990
which are the game values and the game values are going to be,

284
00:16:06.700 --> 00:16:08.890
are going to our more global there.

285
00:16:08.900 --> 00:16:12.200
They're going to be used throughout the code they're going to use throughout the

286
00:16:12.201 --> 00:16:14.300
code.
Uh,
we're going to use him quite frequently.

287
00:16:14.301 --> 00:16:17.120
So that's why I called him gain values.
Okay.
So,
uh,

288
00:16:17.540 --> 00:16:19.580
we'll start off with the score.
That's the most obvious one.

289
00:16:19.581 --> 00:16:21.410
What is the score that we want to keep?

290
00:16:21.480 --> 00:16:25.070
Remember we want to reach 500 and then we're going to start off with a speed for

291
00:16:25.071 --> 00:16:29.060
the game so we can actually change the speed of the game through.

292
00:16:29.630 --> 00:16:31.970
Like by doing this,
like check this out.

293
00:16:31.971 --> 00:16:34.400
I can toggle the speed by saying speed up.
Is He?

294
00:16:34.401 --> 00:16:37.400
So he see how it speeds up and like it slowed down again.

295
00:16:39.120 --> 00:16:43.130
That was my sound effect for speed.
Okay.
So then we slid back down again.
But um,

296
00:16:43.970 --> 00:16:46.610
yeah,
that's the idea for the speed.
We can increase it or decrease it.

297
00:16:46.850 --> 00:16:50.750
And then we have our,
a boolean like do we want to even change the speed?

298
00:16:50.751 --> 00:16:53.090
Like what's the deal here?
And I'm going to say,
well let's,

299
00:16:53.240 --> 00:16:54.830
let's keep it false at first.

300
00:16:54.831 --> 00:16:58.310
We don't want to change the speed right now and then we want us to save the

301
00:16:58.311 --> 00:17:00.820
state of the game,
right?
So what is the,
this,

302
00:17:00.890 --> 00:17:04.970
the state of the game and the state of the game.
We're gonna use that.
So as a,

303
00:17:05.030 --> 00:17:09.220
as a way to save it and then reload it later.
If we want to our genomes,

304
00:17:09.240 --> 00:17:11.990
wherever we are.
In a way it's kind of like model checkpoints,
right?

305
00:17:11.990 --> 00:17:12.823
In tensorflow.

306
00:17:13.370 --> 00:17:17.150
So we want to save the state of the game and then we want to store the current

307
00:17:17.151 --> 00:17:18.110
state of the game.
Right?

308
00:17:18.111 --> 00:17:20.600
So we have a safe state and then a current state which we'll call the round

309
00:17:20.601 --> 00:17:22.730
states.
Okay.
And then

310
00:17:24.980 --> 00:17:28.550
what else do we got here?
So we have our speed index.

311
00:17:28.580 --> 00:17:32.550
So we have a speed array of of values.
Like,

312
00:17:32.580 --> 00:17:34.850
cause we're going to have several speeds like preset speeds.

313
00:17:34.851 --> 00:17:37.340
It's not like it's some kind of like counter where we can just like,
you know,

314
00:17:37.341 --> 00:17:42.140
like increment by like intervals of one.
It's going to be like 400,

315
00:17:42.141 --> 00:17:44.930
500,
1,015 hundred like force feed values.

316
00:17:45.140 --> 00:17:49.100
So we have an index and the speed value array that we're just going to sit here

317
00:17:49.320 --> 00:17:53.640
and we'll set it to zero.
And then we have our,
uh,
what else,

318
00:17:53.641 --> 00:17:58.340
what else do we have here?
We have our speeds,
we have our stuff

319
00:18:00.570 --> 00:18:03.210
right?
And so this should be an array.
What am I,
what am I thinking?

320
00:18:03.211 --> 00:18:07.680
This should be a set of values.
It'd be 500,
one and zero.
Okay.

321
00:18:07.950 --> 00:18:08.940
And then we have those.

322
00:18:08.941 --> 00:18:13.941
And so now it's took time to define our AI as in do we want an AI or not?

323
00:18:15.240 --> 00:18:15.931
So we'll say yes,

324
00:18:15.931 --> 00:18:18.870
we want an AI because we could turn the AI off and then we could just play like

325
00:18:18.871 --> 00:18:21.420
that.
See,
like,
check this out.
Hold on.

326
00:18:23.940 --> 00:18:27.360
Uh,
where was I?
Toggle.
AIA,

327
00:18:29.660 --> 00:18:31.680
right?
And then I could just play instead of the Ai,

328
00:18:31.710 --> 00:18:35.070
but I'm not going to do that anyway.
All right,
so it's going crazy.
Okay.

329
00:18:35.190 --> 00:18:38.880
So then we have our AI and then we have a draw.
A boolean was,
which says,

330
00:18:38.881 --> 00:18:41.280
do we want to draw the game or do we want to update the algorithm?

331
00:18:41.460 --> 00:18:43.690
We can do one or the other.
And so this,

332
00:18:43.691 --> 00:18:46.530
this is a boolean for like letting our algorithm know when to do that.

333
00:18:46.920 --> 00:18:50.340
And then how many moves do we want to take?
Uh,
like do we want to take,

334
00:18:50.640 --> 00:18:53.940
we want to keep track of how many moves we've taken so far so that we can take

335
00:18:53.941 --> 00:18:58.530
our next set of moves.
Okay.
And then what we want to limit of moves.

336
00:18:58.531 --> 00:19:03.070
So we don't write the,
the limit that we're going to set is 500,
just because,
uh,

337
00:19:03.090 --> 00:19:07.800
more than that is going to definitely,
uh,
don't over the ceiling.

338
00:19:08.460 --> 00:19:13.140
Okay.
Or ideally for efficiency's sake,
we can limit it like officially like this,

339
00:19:13.290 --> 00:19:15.990
so that it's going to optimize for that 500 number.

340
00:19:15.991 --> 00:19:19.830
Like that score by doing 500 moves or less,
which would be ideal,
right?

341
00:19:19.831 --> 00:19:22.740
You don't want to do be having do it in like a thousand moves or less.

342
00:19:23.010 --> 00:19:27.270
You want it to do it in a 500 or less.
So we have that and then we have our,
uh,

343
00:19:28.440 --> 00:19:33.390
move algorithm and our move algorithm is going to say it's going to consist of

344
00:19:33.391 --> 00:19:36.930
the seven move parameters,
which are those values in the genome,
right?

345
00:19:36.931 --> 00:19:38.850
Those seven parameters that we're going to talk about,
what,

346
00:19:38.851 --> 00:19:43.470
like what each of those are.
So,
uh,
so we have that.
And then,
uh,

347
00:19:43.860 --> 00:19:48.810
we're going to inspect,
move selection.
Uh,
so this is just,

348
00:19:48.960 --> 00:19:49.610
you know,

349
00:19:49.610 --> 00:19:54.610
a Boolean for whether or not we want to inspect which moves we're going to play

350
00:19:55.261 --> 00:19:59.460
next.
So this is going to be set to true pretty much all the time.
And in fact,

351
00:19:59.461 --> 00:20:02.160
we don't actually even need this value.
We could just have the true always.

352
00:20:02.161 --> 00:20:06.840
But anyway,
uh,
yeah,
so that's it for that.
And so we have one more set of values,

353
00:20:06.900 --> 00:20:08.550
which are the genetic algorithm values.

354
00:20:08.760 --> 00:20:11.820
These are the actual like evolutionary value.
Let me just say,

355
00:20:11.821 --> 00:20:16.140
it's evolutionary to keep it,
uh,
keep the terms straight.
Okay.

356
00:20:16.141 --> 00:20:20.100
So w so in terms of,
in terms of evolutionary algorithms,

357
00:20:20.101 --> 00:20:22.620
we have a population which we're going to say 50,

358
00:20:22.650 --> 00:20:26.010
let's just say 50 genomes to start off with.
And once we have that,
we'll say,

359
00:20:26.040 --> 00:20:28.200
well,
let's store our genomes in and right then,
right?
So we'll,

360
00:20:28.201 --> 00:20:32.430
we'll initialize that array that we want to store our genomes in and then we'll

361
00:20:32.431 --> 00:20:34.170
get,
we'll keep track of where we are currently.

362
00:20:34.170 --> 00:20:36.540
What is the current genome that we're focusing on?

363
00:20:36.541 --> 00:20:40.860
And we're going to say a one which is the first index or you know,
not one,

364
00:20:40.861 --> 00:20:41.760
but negative one,

365
00:20:41.761 --> 00:20:44.250
which is the index we want to start off with and we're going to,

366
00:20:44.280 --> 00:20:47.830
we're going to iterate through that genome array as we try out different things.

367
00:20:48.130 --> 00:20:50.110
So,
right.
What else?

368
00:20:50.111 --> 00:20:52.870
We've got a generation and what's the first generation called?

369
00:20:52.900 --> 00:20:56.230
It's the Zeroth generation,
right?
It's the zero with generation.

370
00:20:56.740 --> 00:21:01.480
And then we want an archive.
So this is,
uh,
this is for us to store.

371
00:21:01.870 --> 00:21:04.600
What are values are for each generation.

372
00:21:04.601 --> 00:21:08.290
And what we're going to do is we're going to use JavaScript's built in local

373
00:21:08.291 --> 00:21:10.030
storage function,
which is supreme.

374
00:21:10.031 --> 00:21:14.080
What useful and what local storage does is it allows us to

375
00:21:16.300 --> 00:21:18.900
store some set of values in

376
00:21:20.570 --> 00:21:23.130
a short term memory and Ram,
right?

377
00:21:23.160 --> 00:21:26.430
Which is amazing because it's just super useful.

378
00:21:26.431 --> 00:21:28.860
Like we don't have to use a database,
we can just store it in memory.

379
00:21:29.130 --> 00:21:32.940
And that's super useful.
Not computationally expensive.

380
00:21:33.150 --> 00:21:36.720
We'll have a set of elites,
which are the,
uh,
which are the

381
00:21:39.560 --> 00:21:42.710
genomes that we selected to reproduce.
And then we have all of our genome.

382
00:21:42.711 --> 00:21:43.850
So we want to keep track of boats.

383
00:21:44.090 --> 00:21:47.930
So what are the elite genomes like the fittest ones that we define and then what

384
00:21:47.931 --> 00:21:48.880
are the,
um,

385
00:21:53.320 --> 00:21:54.130
<v 1>what</v>

386
00:21:54.130 --> 00:21:54.963
<v 0>are the</v>

387
00:21:58.390 --> 00:22:02.080
general genomes like all of them.
Okay.
So we have that and then two more,

388
00:22:02.290 --> 00:22:05.200
two more parameters and then we're good to go.
So we have our genomes,

389
00:22:05.230 --> 00:22:07.930
we have our population digital to make sure I typed that.
All right.

390
00:22:08.140 --> 00:22:09.760
And so then we have our mutation rates.

391
00:22:09.761 --> 00:22:13.120
So this is going to be our value that we use to mutate the children.

392
00:22:13.150 --> 00:22:16.720
And we're going to say 0.05 and we can tune this just like we would hyper

393
00:22:16.721 --> 00:22:19.600
parameters in a neural network.
We can tune this to make it better,

394
00:22:19.690 --> 00:22:22.630
but we'll start off with 0.05,
right?
It's kind of like the learning rate,
right?

395
00:22:22.840 --> 00:22:26.110
When it comes to backpropagation.
Uh,
but this is the mutation rate.
The,

396
00:22:26.120 --> 00:22:29.230
the similarity is definitely there.
And then we have a mutation step,

397
00:22:29.440 --> 00:22:33.550
which is going to also,
it's kind of like,
um,
momentum in this case,

398
00:22:33.551 --> 00:22:38.260
but what is the race that we want to mutate?
And then the step is,

399
00:22:38.710 --> 00:22:43.150
uh,
what is the interval that we want to apply that mutation rate too.

400
00:22:43.180 --> 00:22:46.150
You'll see what I mean when I,
when we look at the code for this.
But okay,

401
00:22:46.151 --> 00:22:50.320
that's it.
That's it for our global variables.
That's a lot.
I know,
right?
It's a,

402
00:22:50.321 --> 00:22:52.150
it's quite a lot of global variables,
but hey,

403
00:22:52.420 --> 00:22:55.180
it's javascript and a welcome to js world.

404
00:22:55.720 --> 00:22:57.760
So let's go ahead and write out our first function.

405
00:22:57.761 --> 00:22:59.130
So this is the highest level function.

406
00:22:59.210 --> 00:23:01.930
So this is what I was talking about when I was saying that we're going to write

407
00:23:01.931 --> 00:23:05.140
out the highest level part and then we'll talk about the helper functions,
right?

408
00:23:05.141 --> 00:23:08.460
So it's all going to happen in this initialized function.
All the,
all the,
uh,

409
00:23:08.470 --> 00:23:09.281
high level magic.

410
00:23:09.281 --> 00:23:14.281
So the first part is for us to initialize our population size.

411
00:23:14.441 --> 00:23:18.280
So assuming that we have it in our archive,
like in local memory,
which we do,

412
00:23:18.430 --> 00:23:21.670
we'll say like,
okay,
let's start,
let's,
well,

413
00:23:21.730 --> 00:23:23.140
we're going to store it in the archive.

414
00:23:23.140 --> 00:23:26.590
We're going to store the population size 50 in our local memory,

415
00:23:26.591 --> 00:23:28.600
which is the archive that we defined here.

416
00:23:28.840 --> 00:23:32.140
So that's our first part is initializes the population size.

417
00:23:32.440 --> 00:23:34.970
And then we want to get a shape,
right?
So we'll say next shape.

418
00:23:34.971 --> 00:23:38.500
So this function is going to give us the next shape from the bag that we have of

419
00:23:38.680 --> 00:23:41.230
what is the next shape that we want the AI to play.

420
00:23:41.500 --> 00:23:44.800
So we have our next shape and then we want to apply that shape to the grid.

421
00:23:44.920 --> 00:23:47.870
So we have that shape,
which is an l or oh or whatever.

422
00:23:48.050 --> 00:23:50.960
And we want to apply it to the grave.
But,
and what do I,
what do I mean by apply?

423
00:23:50.990 --> 00:23:54.170
We want to,
we want to stick it in the grid so it stays in one place,
right?

424
00:23:54.171 --> 00:23:58.190
When it falls down and then it,
it becomes a part of the grid,
right?

425
00:23:58.340 --> 00:24:00.530
So we have that and that's what applies shape does.

426
00:24:00.540 --> 00:24:04.100
So we've initialize our population goddess shape,
applied into the grid,

427
00:24:04.340 --> 00:24:07.850
and then we want to save where we are.
So we'll say,

428
00:24:08.420 --> 00:24:12.530
let's save where we are by using the gets state function to get our,

429
00:24:12.540 --> 00:24:16.640
our safe state,
which are those values,
those,
uh,
those genome values.

430
00:24:16.850 --> 00:24:19.190
And then we want our current state as well.

431
00:24:19.191 --> 00:24:22.340
So we'll get both using these getter functions,
get state.

432
00:24:23.030 --> 00:24:27.590
And so we'll have to uh,
clones.
These are clones in the same state.

433
00:24:27.770 --> 00:24:30.020
One we'll save and then one we'll set to our current state.

434
00:24:30.410 --> 00:24:33.020
And then we'll go ahead and create the initial population.

435
00:24:33.021 --> 00:24:35.120
We've defined our initial parameters.

436
00:24:35.121 --> 00:24:37.970
So now we can just create what that initial population will be.

437
00:24:38.390 --> 00:24:39.950
And then we can define the game loop.

438
00:24:39.951 --> 00:24:43.250
So we created our initial population of genomes,
50 genomes,

439
00:24:43.251 --> 00:24:47.150
which are randomly generated values for these seven weights.

440
00:24:48.830 --> 00:24:53.360
And then we can,
uh,
start up,
go ahead and start the game loop.

441
00:24:53.361 --> 00:24:57.170
So the game loop,
we'll,
we'll call it loop is going to be a nested function.

442
00:24:57.680 --> 00:25:02.450
And this is where the,
this is where the actual,
you know,
the,
the logic happens.

443
00:25:02.630 --> 00:25:05.570
So then for the logic will say,
okay,
so let's say,

444
00:25:05.930 --> 00:25:08.960
let's see if someone said changed speed,
that which of the bullying,

445
00:25:08.990 --> 00:25:11.870
if someone wanted to change the speed,
we'll go ahead and do that for them.

446
00:25:11.900 --> 00:25:15.980
And the way we'll do that is to use JavaScript's built in functions.

447
00:25:16.190 --> 00:25:19.640
So it's clear interval,
given an interval value,
it's going to clear the,
the,

448
00:25:19.820 --> 00:25:24.380
the timers.
We have a game timer and we want to clear it.
And once we do that,

449
00:25:24.381 --> 00:25:25.161
then we can say,
okay,

450
00:25:25.161 --> 00:25:29.210
so the new interval is going to be set interval given our loop and it's given

451
00:25:29.211 --> 00:25:31.040
speed.
This is going to go some new timer.

452
00:25:31.610 --> 00:25:36.610
Let's go ahead and say change interval equals false.

453
00:25:38.960 --> 00:25:39.980
So we don't change it.

454
00:25:39.981 --> 00:25:44.930
So we stopped at a time and then we don't change it here.
Okay?
So that,

455
00:25:44.931 --> 00:25:47.930
that's the first,
uh,
if statement.
So we have one more if statement.

456
00:25:47.931 --> 00:25:51.920
So we say if speed equals zero.

457
00:25:51.950 --> 00:25:55.550
So if there is no speed,
so the game has stopped,
we need to say,
well,

458
00:25:55.551 --> 00:25:57.860
don't draw anything.
I mean we,
we stopped the game,

459
00:25:57.861 --> 00:26:01.130
so there's no need to draw anything,
right?
So we say dry equals false.

460
00:26:01.340 --> 00:26:04.220
And then we say,
now it's time to update the game,
right?

461
00:26:04.221 --> 00:26:08.240
So regardless of whether or not we're drawing,
we,
we want to update.

462
00:26:08.241 --> 00:26:09.860
And so this is why

463
00:26:13.310 --> 00:26:17.300
I said that we want to either draw or we want to compute our,
uh,

464
00:26:17.570 --> 00:26:20.270
evolutionary algorithms.
We could do both actually,

465
00:26:20.690 --> 00:26:23.270
but we're going to keep this simple.
We could do both asynchronously.

466
00:26:23.370 --> 00:26:26.300
You think some kind of concurrence,
a library,

467
00:26:26.510 --> 00:26:29.540
but then there's like callback hell and there's a way around that with like

468
00:26:29.541 --> 00:26:30.374
promises.

469
00:26:30.620 --> 00:26:35.510
But we'll focus on the evolutionary algorithms right now.
Okay.
So,

470
00:26:35.540 --> 00:26:40.430
um,
so we have that and let's go ahead and say,
okay,
so that's our if statement.

471
00:26:40.431 --> 00:26:45.210
So then else,
uh,
let's go ahead and draw the,
so if the speed is not zero,

472
00:26:45.211 --> 00:26:48.690
then we need to keep drawing.
We tell the game that we need to keep drawing.

473
00:26:48.691 --> 00:26:53.200
So I'll say draw the elements and the elements are going to be true though.

474
00:26:53.201 --> 00:26:56.880
So we'll set,
draw to true.
That's going to tell our game to draw the elements.

475
00:26:56.881 --> 00:26:59.760
And so by the way,
the update function is going to update the game.

476
00:26:59.790 --> 00:27:01.560
If that means it's going to update a fitness,

477
00:27:01.620 --> 00:27:03.600
make a move and evaluate the next move.

478
00:27:03.810 --> 00:27:06.510
There's going to update the fitness function,
make a move.

479
00:27:06.540 --> 00:27:10.920
The AI will make a move,
like,
you know,
what road,
what shaped,
what block to play,

480
00:27:11.100 --> 00:27:14.130
how to rotate it.
Uh,
and then until it goes to the bottom,

481
00:27:14.280 --> 00:27:17.610
and then it's going to evaluate the next move using that previous mood.

482
00:27:17.611 --> 00:27:21.510
And we'll update it three times to do that.
Uh,
we could update it just twice,

483
00:27:21.511 --> 00:27:25.670
three times or four times,
but,
uh,
we'll just update it three times.
Just,
uh,

484
00:27:25.830 --> 00:27:27.930
so we have some kind of updating happening.

485
00:27:28.170 --> 00:27:31.620
So then we're going to do an update in general,
right?
So regardless of anything,

486
00:27:31.621 --> 00:27:34.170
whether or not the player,
and so this is all about changing speed.

487
00:27:34.380 --> 00:27:37.230
So regardless of whether or not to play or change speed,

488
00:27:37.350 --> 00:27:41.910
we want to update the game anyway.
So we'll update it,
right?
And then we'll say,

489
00:27:41.940 --> 00:27:46.290
um,
what else?
We got?
Uh,
one more value.
So,

490
00:27:50.730 --> 00:27:54.700
so then,
uh,
oh,
this should be a part of the game loop.
What am I thinking?
Blah,

491
00:27:54.910 --> 00:27:59.550
blah,
blah,
blah,
blah.
So then we'll update this update regardless,

492
00:27:59.551 --> 00:28:03.930
and then we'll say
one more time.

493
00:28:03.931 --> 00:28:08.790
So if speed equals zero,
then we're going to draw the elements

494
00:28:10.410 --> 00:28:14.760
and then we're going to update the score.
Okay.
Okay.

495
00:28:14.761 --> 00:28:18.120
So then we're going to initialize it with a document onload function.
Uh,

496
00:28:18.121 --> 00:28:21.880
and so the document onload function is going to uh,
initialize our,

497
00:28:21.960 --> 00:28:26.430
our initialization function,
right when the dom loads up for javascript,

498
00:28:26.550 --> 00:28:28.770
write the html elements and all of those things.

499
00:28:28.771 --> 00:28:32.130
Whenever you load up the webpage,
run this function,
that's what it means.
Okay?

500
00:28:32.131 --> 00:28:34.500
So that's the gist of it.

501
00:28:34.501 --> 00:28:39.240
But the idea here is that we are going to initialize the population,

502
00:28:39.270 --> 00:28:43.530
right?
So we initialize a population of genomes,
which are those sets of values.

503
00:28:43.530 --> 00:28:44.610
And then we run a game loop.

504
00:28:44.970 --> 00:28:48.210
And then whether or not the player has decided to change the speed,

505
00:28:48.420 --> 00:28:49.920
we're going to reset,

506
00:28:50.070 --> 00:28:53.970
we're going to reset the timer for the game and then we're going to iteratively

507
00:28:54.000 --> 00:28:58.860
update the game.
And then if the speed is zero,
then we update the score.
Okay.

508
00:28:58.861 --> 00:29:02.010
So that's the high level code.

509
00:29:02.190 --> 00:29:04.340
And now we'll talk about the a helper functions.

510
00:29:04.341 --> 00:29:07.380
Cause we've got a lot to go through her.
So let's talk about them.
Okay.

511
00:29:07.381 --> 00:29:10.860
So we probably want to start off with looking at this create initial population

512
00:29:10.861 --> 00:29:13.560
function and then just move on from there.
So we'll go in order,

513
00:29:13.620 --> 00:29:15.150
like in order of what we eat to look at,

514
00:29:15.390 --> 00:29:18.390
cause we have a lot of functions and I actually have them here at the bottom.

515
00:29:18.810 --> 00:29:22.920
Let me just move this hold on.
Phone,
phone,
phone.
Okay,

516
00:29:23.300 --> 00:29:25.590
well let's get started.
Okay.
So

517
00:29:27.810 --> 00:29:31.620
move this out of the way.
Okay.
So the first thing we want to look at,

518
00:29:31.680 --> 00:29:33.600
because this is the function,
this is the main function,
right?

519
00:29:33.601 --> 00:29:35.880
This is an initial of function.
So let's look at this.

520
00:29:35.881 --> 00:29:39.660
Create initial population function.
So for create initial population,

521
00:29:39.661 --> 00:29:42.490
this is our key down function.
This is just like,
you know,

522
00:29:42.700 --> 00:29:46.450
depending on what key you press,
run one of these functions like you know,

523
00:29:46.480 --> 00:29:50.380
if you press w a s or d,
which are these key codes,
move down,

524
00:29:50.381 --> 00:29:55.150
move left and fry,
uh,
saved the state.
If you press Q,
load up the previous date,

525
00:29:55.151 --> 00:29:59.170
if you've suppressed w,
change the speed.
If you press e,
uh,

526
00:29:59.410 --> 00:30:02.350
turn the AI on or off.
He's a bunch of,
just a bunch of key precedent.

527
00:30:02.351 --> 00:30:06.400
So we can just skip this function.
Key presses,
right?
This is our,

528
00:30:06.520 --> 00:30:08.710
this is our code.
So let me,
let's talk about this.
This is the,

529
00:30:08.711 --> 00:30:12.520
this is the fun part.
Okay.
So for our create an initial population function,

530
00:30:12.730 --> 00:30:14.680
we're going to initialize a genome array,

531
00:30:14.710 --> 00:30:17.470
which we're going to store all of our genomes in.
And then we're going to say,

532
00:30:17.471 --> 00:30:20.800
okay,
so given a population size,
so it's going to be 50,
right?

533
00:30:20.801 --> 00:30:23.980
We defined it as 50.
So given 50 genomes,

534
00:30:25.150 --> 00:30:27.670
let's say each genome,
we'll initialize it just like this.

535
00:30:27.820 --> 00:30:31.600
So these are the seven values that you saw right up,
right over here,
right?

536
00:30:31.750 --> 00:30:34.870
These are the weight values that improve over time.
Let me slow this AI down.

537
00:30:35.170 --> 00:30:37.870
It is moving so fast that it can't even draw fast enough.

538
00:30:38.290 --> 00:30:41.290
And so that's why we need async more asynchronous code.
So we could do that,

539
00:30:41.291 --> 00:30:42.490
right?
But we have a,

540
00:30:43.960 --> 00:30:47.860
we have a suboptimal code in terms of synchronization and concurrency,

541
00:30:47.861 --> 00:30:51.610
but that's okay.
Let's see.
So watch these white values,
improve,

542
00:30:52.300 --> 00:30:54.850
watch them improve,
they're gonna improve once this,
uh,

543
00:30:55.600 --> 00:30:58.060
once we move on to the next generation,

544
00:31:02.930 --> 00:31:07.670
yeah,
there we go.
They improved.
Okay.
So that's how they,
so they're like,

545
00:31:07.671 --> 00:31:10.370
wait,
values,
their weight values.
Okay,
so let's talk about each of them.

546
00:31:10.580 --> 00:31:11.391
So we have an ID.

547
00:31:11.391 --> 00:31:15.620
So each genome gets its own unique identifier that will initialize randomly and

548
00:31:15.621 --> 00:31:19.640
then we have our rose cleared a parameter or gene.
These are genes,
right?

549
00:31:19.641 --> 00:31:21.800
The genome has genes which are parameters.

550
00:31:22.160 --> 00:31:25.550
And so what roads cleared means it's the weight from each row cleared by the

551
00:31:25.551 --> 00:31:29.120
given move.
The more roads that are cleared,
the more this weight increases.

552
00:31:29.360 --> 00:31:32.030
So it's a way of quantifying how much,

553
00:31:32.031 --> 00:31:35.000
how many rows we clear it and clearing a row.
It's a good thing,
right?

554
00:31:35.060 --> 00:31:38.030
The road disappears.
It means all that row is filled to our score,

555
00:31:38.060 --> 00:31:39.170
our score increases.

556
00:31:39.410 --> 00:31:42.710
So we create a weight value that represents how many rows are cleared.

557
00:31:43.010 --> 00:31:45.220
You might be asking,
well,
why don't we just have the um,

558
00:31:45.540 --> 00:31:49.130
the s the direct value of the absolute value?
Why don't we just say,
well,

559
00:31:49.220 --> 00:31:53.690
two roads have been cleared or three roads have been cleared because the weight

560
00:31:53.691 --> 00:31:53.991
value,

561
00:31:53.991 --> 00:31:57.170
it's kind of like a weight that you were in a neural network where these weight

562
00:31:57.171 --> 00:32:00.530
values are,
they look unrelated to the input data and the output data.

563
00:32:00.740 --> 00:32:02.120
But in actuality they're like,

564
00:32:02.510 --> 00:32:07.510
they are measurements that we use as scalar values essentially.

565
00:32:08.211 --> 00:32:11.150
One more whenever we're matrix multiplying to compute an output.

566
00:32:11.300 --> 00:32:13.700
So these values change there.

567
00:32:13.730 --> 00:32:17.390
They looked like they're unrelated but they're updated so that we can reach that

568
00:32:17.450 --> 00:32:22.280
optimal output.
In the end they're used to optimize for our objective,

569
00:32:22.281 --> 00:32:23.300
whatever that objective is.

570
00:32:23.301 --> 00:32:27.620
And in this case that objective is to get a score of 500 and so we use rose

571
00:32:27.621 --> 00:32:31.430
cleared as we use a weight value that represents the roads cleared and we

572
00:32:31.431 --> 00:32:35.920
initialize it randomly,
right?
Minus 0.5 and you'll see more about this when we,

573
00:32:35.950 --> 00:32:37.950
when we actually uh,

574
00:32:38.000 --> 00:32:41.380
use the amount roads cleared to calculate this weight value,

575
00:32:41.480 --> 00:32:42.950
it all plays into it,
right?

576
00:32:42.950 --> 00:32:46.040
But we initialize that as random and that we use the amount of rows clear to

577
00:32:46.070 --> 00:32:46.850
update it.

578
00:32:46.850 --> 00:32:50.900
And then we obviously then we use crossover to update the wait values in
general,

579
00:32:50.901 --> 00:32:55.370
like all of them.
Okay.
So,
so here,
our seven way values,

580
00:32:55.371 --> 00:32:57.050
we have rose clear,
then we have weighted height,

581
00:32:57.080 --> 00:33:00.800
which is the absolute height of the highest column two,
the power of 1.5.

582
00:33:00.801 --> 00:33:04.880
So the highest column that we've reached when in an intergeneration is the

583
00:33:04.881 --> 00:33:09.410
weighted heights and it was added so that we can detect if the blocks are

584
00:33:09.411 --> 00:33:11.870
stacking too high.
And then we have a cumulative height,

585
00:33:11.900 --> 00:33:13.760
which is the sum of all the column Heights.

586
00:33:13.761 --> 00:33:16.220
So we add all of them together and we use that some.

587
00:33:16.670 --> 00:33:17.990
And then we have a relative height,

588
00:33:17.991 --> 00:33:21.860
which is the highest column minus the lowest column and the holes,

589
00:33:21.861 --> 00:33:24.740
which are the sum of all the empty cells to have a block above them.

590
00:33:24.830 --> 00:33:27.920
So whenever we have a,
our game,
like the holes would be right here,

591
00:33:28.190 --> 00:33:32.210
right here at the bottom.
Like these are no,
these are no,

592
00:33:33.500 --> 00:33:34.700
these bottom values right here.

593
00:33:34.701 --> 00:33:37.730
Our holes right where my mouse is and check those out.
Those are holes.

594
00:33:37.760 --> 00:33:39.950
So we want to,
we want to minimize for those holes,
right?

595
00:33:40.580 --> 00:33:41.570
And then we have a roughness,

596
00:33:41.571 --> 00:33:44.870
which is that some of the absolute differences between the height of each
column,

597
00:33:46.730 --> 00:33:50.630
right?
So just like wait values in a neural network,

598
00:33:50.631 --> 00:33:53.300
we don't know what these optimal value should be,
right?

599
00:33:53.450 --> 00:33:56.720
That's why we're going to optimize for them.
And the way we'll optimize,

600
00:33:56.721 --> 00:34:00.200
it's through a evolutionary algorithms to selection,

601
00:34:00.260 --> 00:34:03.980
crossover and mutation.
That's how these way values learn what,

602
00:34:04.060 --> 00:34:05.450
what the optimal value is.

603
00:34:05.540 --> 00:34:08.870
Like we don't know that we have to minimize the amount of holes,
right?
But we,

604
00:34:09.000 --> 00:34:12.620
but I mean we know,
we intuitively know that we should minimize the holes,

605
00:34:12.770 --> 00:34:16.790
but we haven't told the algorithm that it will learn to minimize for the amount

606
00:34:16.791 --> 00:34:21.620
of holes it will learn to minimize for the relative height and the weighted

607
00:34:21.621 --> 00:34:22.610
height.
Right?

608
00:34:22.640 --> 00:34:26.330
Cause we want the smaller heights are good because it means that our block,

609
00:34:26.390 --> 00:34:30.920
our rows are clearing that are,
are our blocks or shapes are fitting together,

610
00:34:31.070 --> 00:34:31.903
right?

611
00:34:32.600 --> 00:34:37.600
So those are the genes for each genome and we'll take each of them and push them

612
00:34:38.211 --> 00:34:42.230
to our genome array that we initialized and then we'll evaluate the next genome.

613
00:34:42.350 --> 00:34:46.460
Okay.
So right,
so speaking of evaluate next genome,

614
00:34:46.580 --> 00:34:48.380
let's look at this next function,
right?

615
00:34:48.620 --> 00:34:52.370
We created our initial population of genomes and then we're going to evaluate

616
00:34:52.371 --> 00:34:56.330
the next genome.
So let's see what that looks like.
Okay.

617
00:34:56.331 --> 00:35:00.110
So let me make sure that we're,
yeah.
Cool.
So this is the actual selection part.

618
00:35:00.260 --> 00:35:03.350
Now that we've evaluated,
now that we've created that initial population,

619
00:35:03.470 --> 00:35:07.700
we want to select for the best genomes,
right?
So how do we do that?
So we say,

620
00:35:07.701 --> 00:35:11.330
okay,
well first of all,
let's increment where we are in the GMO genome array.

621
00:35:11.360 --> 00:35:14.660
So cause we were going to do this to each genome,
right?
What is the next gene?

622
00:35:14.661 --> 00:35:17.840
And let's evaluate it in the context of,
of Tetris.
So we say,

623
00:35:17.841 --> 00:35:20.900
okay so if there is none,
then we're going to evolve the population.

624
00:35:20.901 --> 00:35:24.500
And so that is the crossover step.
If there is no next genome,

625
00:35:24.501 --> 00:35:27.230
it's time to move on to the next generation,
right?

626
00:35:27.231 --> 00:35:30.440
And that means like start breeding.
But if there is one,

627
00:35:30.860 --> 00:35:33.740
then we want to use it to evaluate what the next move is.

628
00:35:33.860 --> 00:35:35.930
So we'll load up where we are in the game,

629
00:35:36.170 --> 00:35:39.090
we'll reset the amount of moves cause we're going to try out a bunch of moves

630
00:35:39.091 --> 00:35:43.890
for this genome and then we'll make the next move.
Okay.
So,

631
00:35:44.370 --> 00:35:48.930
uh,
so that's our selection steps.

632
00:35:48.931 --> 00:35:52.530
So now let's talk about crossover.
So when it comes to crossover,

633
00:35:52.620 --> 00:35:54.930
so let's say that we've tried all of them out,

634
00:35:55.080 --> 00:35:57.420
like we've tried all the genes out and now we're going to evolve.

635
00:35:57.420 --> 00:36:00.300
So let's talk about what evolution looks like in this case.

636
00:36:00.301 --> 00:36:01.470
Given a set of genomes.

637
00:36:01.740 --> 00:36:05.490
So this is the art evolve function and this is where the step two of

638
00:36:05.491 --> 00:36:09.020
evolutionary algorithms happens.
This is where the,
the,
the,
uh,

639
00:36:09.810 --> 00:36:14.760
mating step happens.
Don't worry if not rated R or rated x.
It's totally rated g.

640
00:36:16.020 --> 00:36:20.980
Okay.
Yeah.
Okay.
So yeah,
it's rated g.
So anyway,
okay,
so,
uh,

641
00:36:21.570 --> 00:36:24.570
we're going to say evolve and then we're going to evolve this genome.

642
00:36:24.571 --> 00:36:26.490
So how does this work?
So we say,
okay,

643
00:36:26.610 --> 00:36:29.610
so we're going to reset the current genome for this generation and then we're

644
00:36:29.611 --> 00:36:32.400
going to increment the generation.
It's time to move on to the next generation,

645
00:36:32.640 --> 00:36:35.340
reset the game.
Because every time we had our new generation,

646
00:36:35.341 --> 00:36:38.580
we want to reset all the block values,
right?
So it's empty.

647
00:36:38.581 --> 00:36:40.860
The grid is empty again.
And then we say,
okay,

648
00:36:40.861 --> 00:36:43.770
so let's get the current state of the game,
like where we are in the game.

649
00:36:44.130 --> 00:36:45.600
And then this is our

650
00:36:48.180 --> 00:36:52.530
way of seeing who has the best fitness.
So we use this function.

651
00:36:52.940 --> 00:36:55.080
We haven't actually defined what the fitness value is,

652
00:36:55.230 --> 00:36:57.450
but we're saying like assuming that we've calculated it,

653
00:36:57.480 --> 00:36:59.580
which we will in a different function that I'll talk about,

654
00:36:59.910 --> 00:37:02.040
assuming we've calculated what the fitness will be,

655
00:37:02.160 --> 00:37:05.880
we can then sort all of our genomes in order of fitness and that's what this

656
00:37:05.881 --> 00:37:08.430
function do.
This,
that's what this function does.

657
00:37:08.520 --> 00:37:11.850
It's going to sort the genomes in that array in order of fitness.

658
00:37:12.000 --> 00:37:15.840
And then once we have those,
we'll push each of them into our elites.
Uh,

659
00:37:16.020 --> 00:37:20.730
remember our,
our,
our archive array had this elites,
um,

660
00:37:20.760 --> 00:37:23.670
value right up here or was it that Addenda C,
this one?

661
00:37:24.150 --> 00:37:27.000
These elite values are the ones that are fit to breed,
right?

662
00:37:27.001 --> 00:37:28.260
These are the ones that are fit to breed.

663
00:37:28.380 --> 00:37:33.210
They had the most fitness of all the genomes and we can say,
ah,

664
00:37:33.390 --> 00:37:37.260
let's add them to this array because we're going to then use those to crossover

665
00:37:37.261 --> 00:37:41.370
to breed.
So then we'll say,
okay,
so then we'll remove the rest.
So the tail end.

666
00:37:41.371 --> 00:37:44.940
So the population size divided by two.
If the length is greater than that,

667
00:37:44.941 --> 00:37:47.310
pop it off the list like,
like a stack,
right?

668
00:37:47.311 --> 00:37:48.660
Pop it off and don't need it anymore.

669
00:37:48.800 --> 00:37:53.690
So we're only going to focus on the the fittest genomes and then we're going to

670
00:37:53.691 --> 00:37:54.121
say,
okay,

671
00:37:54.121 --> 00:37:58.170
let's sum the total of the fitness of each of those genomes together to get the

672
00:37:58.171 --> 00:37:59.880
total fitness.
Okay?

673
00:38:00.120 --> 00:38:03.870
And then we're going to get a random index from the genome array,
which says,

674
00:38:03.900 --> 00:38:04.410
okay,
let's,

675
00:38:04.410 --> 00:38:08.250
let's get a random weighted numbe between zero and the genomes length minus one.

676
00:38:08.520 --> 00:38:12.900
And we're going to use that genome as our,
this is our selection function,

677
00:38:13.080 --> 00:38:15.840
right?
This is selection right here.

678
00:38:15.900 --> 00:38:20.370
This line is essentially selection.
We're basically randomly selecting,

679
00:38:20.610 --> 00:38:24.090
okay.
And that is our fitness in this case.

680
00:38:24.091 --> 00:38:27.620
So it's a very brute force and not proved for us but of air.

681
00:38:27.660 --> 00:38:31.560
It's a very primitive,
a fitness function.
I mean,
we could do other things,

682
00:38:31.561 --> 00:38:35.830
but it is fitness function.
It is a fitness,
it is a fitness function,
right?

683
00:38:35.910 --> 00:38:36.743
It is better than nothing.

684
00:38:37.090 --> 00:38:41.920
So that's how we choose which the which genomes are going to be fit to breed

685
00:38:42.100 --> 00:38:43.480
randomly.
Okay.

686
00:38:43.481 --> 00:38:48.190
So then we have a children array that we were going to populate with our

687
00:38:48.191 --> 00:38:52.420
children and we're going to push the fittest genomes to that array.

688
00:38:52.421 --> 00:38:55.870
So we already have those fitness genomes that we defined and we're going to push

689
00:38:55.871 --> 00:39:00.610
those finished genomes theory because we popped off the bad ones or the not fit

690
00:39:00.611 --> 00:39:03.100
ones.
And so then once we have that,

691
00:39:03.101 --> 00:39:06.130
we're going to say while the length of the children is less than the population

692
00:39:06.131 --> 00:39:10.000
size,
we want to push all the,
um,

693
00:39:10.540 --> 00:39:14.020
now it's time to actually make the children too that children are ready.

694
00:39:14.230 --> 00:39:17.140
So we'll say,
okay,
so push the children.

695
00:39:17.380 --> 00:39:20.920
And the way we do this is we take two random genomes.

696
00:39:20.921 --> 00:39:24.430
That's how we select our parents.
And then we,
and then we do some dot.

697
00:39:24.550 --> 00:39:28.570
Some computation that's defined in this make child function that we're going to,

698
00:39:28.571 --> 00:39:31.990
I'm going to talk about.
And then we're going to get a child,
a child,
Gino,

699
00:39:32.020 --> 00:39:35.320
and we'll push that to this.
Children are right.
Okay.
So that's that step.

700
00:39:35.740 --> 00:39:39.790
And then we're going to create a new genome array and then we're going to store

701
00:39:39.791 --> 00:39:43.140
all the children in there.
And then we're going to store that in our archives.

702
00:39:43.141 --> 00:39:47.590
So we saved it,
right?
And then we'll say,
okay,

703
00:39:47.591 --> 00:39:49.240
so now this is the current generation.

704
00:39:49.241 --> 00:39:51.850
So we have our past generation and our current generation.

705
00:39:52.090 --> 00:39:55.120
And then this is the local storage part.
This is where we saved the archive.

706
00:39:55.390 --> 00:39:57.940
Thanks.
Show javascript,
short term memory,

707
00:39:58.900 --> 00:40:02.080
kind of like a differentiable neural computers,
uh,
external memory bank.

708
00:40:02.500 --> 00:40:04.510
Now that's too advanced for this.
That was pretty awesome.

709
00:40:04.511 --> 00:40:08.440
That wasn't it if you saw that video.
Cool.
Okay.
So,
um,
all right.

710
00:40:08.441 --> 00:40:12.010
So how do we make our children?
Well,
kids,
well boys and girls,

711
00:40:12.011 --> 00:40:16.120
this is how we make children here.
We,
I'm skidding,
uh,
what am I doing?
Okay.

712
00:40:16.450 --> 00:40:20.560
This is how we make children.
We make children by,

713
00:40:21.330 --> 00:40:25.270
uh,
I had so many jokes didn't happen here.
Focus here.
Raj focused on them.

714
00:40:25.271 --> 00:40:30.040
That child function,
we are going to
say,

715
00:40:30.400 --> 00:40:34.720
okay,
so we have a child.
So we have a mom and a dad.
So,
right.

716
00:40:34.721 --> 00:40:37.780
The Mom and the dad are two genomes from the previous generation with those

717
00:40:37.781 --> 00:40:38.860
seven parameter values.

718
00:40:39.040 --> 00:40:44.040
So we'll first initialize a child using both mom and dad's re uh,

719
00:40:44.320 --> 00:40:47.500
values for those seven parameters.
And we'll pick a random choice.

720
00:40:47.770 --> 00:40:52.000
We'll pick a random value.
That's how the actual reproduction happens.
Okay,

721
00:40:52.300 --> 00:40:54.730
so that's the reproduction stuff.
That's the crossover step.

722
00:40:54.731 --> 00:40:56.740
Step to crossover is happening here.

723
00:40:56.860 --> 00:40:59.110
So we say for roads cleared for all those values,

724
00:40:59.200 --> 00:41:02.830
we're going to just pick a random one between both between either mom or dad.

725
00:41:03.250 --> 00:41:07.840
And then once we have that child with it's seven parameter values that have been

726
00:41:07.841 --> 00:41:11.440
decided by crossover,
which is actually just randomly picking between the two,

727
00:41:11.710 --> 00:41:15.550
then we can mutate each of them music our mutation step.
So this is step three.

728
00:41:15.551 --> 00:41:20.320
This is the mutation step,
the last step of evolutionary algorithms,
right?

729
00:41:20.590 --> 00:41:23.770
So we'll say if the mutation rate is greater than some random value,

730
00:41:23.980 --> 00:41:26.590
then set that the child's value,

731
00:41:26.591 --> 00:41:31.180
that that parameter value that gene for each of the genes to,
uh,

732
00:41:31.330 --> 00:41:36.260
its own parameter value plus some random value times are mutation step times two

733
00:41:36.261 --> 00:41:39.950
minus r mutation steps.
So this part right here is yes,
magic number territory,

734
00:41:39.951 --> 00:41:43.580
but recall from hyper parameter search,
it's very similar to hyper parameters.

735
00:41:43.850 --> 00:41:44.091
You know,

736
00:41:44.091 --> 00:41:47.720
we have to kind of guess and check what these values are and then whatever works

737
00:41:47.721 --> 00:41:51.230
best.
That's,
that's what it is.
And you know,

738
00:41:51.290 --> 00:41:54.060
we can learn to learn and we can just have everything be,
um,

739
00:41:54.140 --> 00:41:57.860
not magic numbers and then use evolutionary algorithms even for the,
uh,

740
00:41:57.861 --> 00:41:59.990
these parameters.
But you know,
that's a step further.

741
00:41:59.991 --> 00:42:02.480
But right now we're going to set a two times two,
right?

742
00:42:02.481 --> 00:42:06.390
And then our mutation step and we'll do that for each of the values.

743
00:42:06.391 --> 00:42:09.180
And at the end we'll have our mutated child,

744
00:42:10.080 --> 00:42:12.300
we'll have our mutated child,
but yeah,

745
00:42:12.301 --> 00:42:16.620
so we'll have our mutated child that we can then return.
Okay.
So,
uh,
yeah,

746
00:42:16.621 --> 00:42:19.860
so that was,
those are the three steps.
That's,
that's,

747
00:42:19.890 --> 00:42:24.240
that's the logic for an evolutionary algorithm,
right.
Um,
selection,

748
00:42:24.241 --> 00:42:27.810
crossover and mutation.
So,
but let's keep going.
Right?
So

749
00:42:29.810 --> 00:42:33.290
make next move is the next thing I should be talking about.
So back to this,

750
00:42:33.291 --> 00:42:36.110
back to this and evaluate next.
Gino,
let me go back.
There's a lot of code here,

751
00:42:36.111 --> 00:42:40.280
so,
so it's so keep,
keep track with me.

752
00:42:40.340 --> 00:42:41.240
I know there's a lot of code,

753
00:42:41.540 --> 00:42:46.540
but remember that first step creating an our initial population and then we

754
00:42:46.791 --> 00:42:50.180
said,
okay,
well we created our genome,
we define what those parameters would be.

755
00:42:50.390 --> 00:42:52.370
And then we evaluated the next genome,
right?

756
00:42:52.610 --> 00:42:55.370
And we talked about what the evolved function was and then we went down that

757
00:42:55.371 --> 00:42:56.960
chain,
that hierarchy of what what was next.

758
00:42:56.961 --> 00:43:00.290
And that was basically all of evolutionary algorithms.
But let's talk about this.

759
00:43:00.291 --> 00:43:03.770
Make next move step,
right.
This is right.
So

760
00:43:05.020 --> 00:43:05.650
<v 1>okay,</v>

761
00:43:05.650 --> 00:43:06.540
<v 0>they got some move,
right?
Yeah.</v>

762
00:43:06.541 --> 00:43:10.080
It makes a nice move and then get all possible moves.
Yes.
So let's go to that.

763
00:43:10.081 --> 00:43:12.720
Make the next move step.
What does it,
what does it take to make a next move?

764
00:43:12.840 --> 00:43:16.740
And so that is how does our AI decides to make a next move based on those wait

765
00:43:16.741 --> 00:43:19.560
values?
So this is how it happens.
Let's go down there.

766
00:43:21.610 --> 00:43:24.010
So here's our make next move step.
So here's how it happens.

767
00:43:25.090 --> 00:43:28.540
So we increment the amount of moves taken and then we say if it's over the
limit,

768
00:43:28.720 --> 00:43:32.560
then we want to update the genomes fitness value using the game score and then

769
00:43:32.561 --> 00:43:36.220
evaluate the next genome.
But if it's not over them,
next moves limit,

770
00:43:36.610 --> 00:43:39.700
then we're going to make the next move for this genome.
So we're going to say,

771
00:43:39.701 --> 00:43:41.740
okay,
so we'll store the old drawing.

772
00:43:41.770 --> 00:43:45.640
So we just have that stored and then we'll say let's get all the possible moves

773
00:43:45.641 --> 00:43:46.990
and we'll talk about what this function is.

774
00:43:47.200 --> 00:43:50.950
But basically this function is going to define all the different possible moves

775
00:43:50.951 --> 00:43:54.010
that a genome can make an a game state.
So he's going to rotate a block this way,

776
00:43:54.011 --> 00:43:55.750
this way,
this way we've up down left,

777
00:43:55.751 --> 00:43:59.140
right all the possible moves that you can make for a,
for one genome.

778
00:43:59.410 --> 00:44:01.810
And then we're going to store that in a list and then we're going to get the

779
00:44:01.811 --> 00:44:03.580
state of the game because we're going to update it.

780
00:44:03.790 --> 00:44:07.060
And then what's the next shape to play?
We wanted to find that.

781
00:44:07.240 --> 00:44:11.560
So here's how it goes down.
We say for each possible move.

782
00:44:11.740 --> 00:44:13.030
Let's get the best move.

783
00:44:13.031 --> 00:44:17.050
So we're checking all the possible moves and then we're gonna get the highest

784
00:44:17.051 --> 00:44:21.310
rated move.
The best move,
move,
move section is what I called it.

785
00:44:21.730 --> 00:44:25.750
So we get the best possible move and we saw that in a next move function.
Okay?

786
00:44:25.751 --> 00:44:28.810
And so that's what the best move will be.
And then

787
00:44:31.290 --> 00:44:33.030
we're going to say,

788
00:44:33.420 --> 00:44:36.690
we're going to add that rating to an array of the highest rated moves,
right?

789
00:44:37.740 --> 00:44:39.770
Then we'll load the current state and we'll say,
well,

790
00:44:40.110 --> 00:44:43.680
let's get the highest rated move and store that didn't move and then rotate the

791
00:44:43.681 --> 00:44:47.340
shape as it says to.
So for the amount of rotations and move,

792
00:44:47.460 --> 00:44:50.640
that's how many times we're going to rotate the shape and then move left as,

793
00:44:50.730 --> 00:44:55.020
as many times as it says to translate and then move right as it says as well.

794
00:44:55.110 --> 00:44:57.150
So this is like,

795
00:44:57.360 --> 00:45:01.230
it's decided what the Mooc should be based on those wait values based on those,

796
00:45:01.231 --> 00:45:06.180
uh,
on those genes for genome.
And now we,
it's like we got that back.

797
00:45:06.181 --> 00:45:09.930
So,
and this get highest rate and move and get all possible moves.
Uh,

798
00:45:09.960 --> 00:45:14.640
these two functions,
that's where the actual,
um,
wait values play into the move,

799
00:45:14.690 --> 00:45:17.370
the move that we're going to make.
So we'll go into those functions in a second.

800
00:45:17.610 --> 00:45:22.110
We just keep diving in deeper and deeper.
So once we've made the move,

801
00:45:22.320 --> 00:45:25.260
then we went to update our move algorithm and then we went to draw the old

802
00:45:25.261 --> 00:45:28.680
drawing output,
the state to the screen and update the score.
Okay,

803
00:45:28.681 --> 00:45:32.190
so let's talk about what this get all possible move function is and then this

804
00:45:32.191 --> 00:45:36.480
get highest rated move function.
So,
uh,
so we'll say,
okay,

805
00:45:36.481 --> 00:45:41.190
so forget all the possible moves will initialize the last state.

806
00:45:41.370 --> 00:45:44.340
The possible moves,
the ratings,
and then the number of iterations.

807
00:45:44.490 --> 00:45:47.880
So it's basically a bunch of nested statements.
So here's,

808
00:45:47.910 --> 00:45:50.190
here's how the weights play into the,

809
00:45:50.670 --> 00:45:53.970
the genes or weights play into the move that the each player is going to make.

810
00:45:54.180 --> 00:45:57.060
So we say for each iteration,
so we have in between negative five and five,

811
00:45:57.061 --> 00:45:58.230
so 10 iterations.

812
00:45:58.530 --> 00:46:01.200
We're going to load the last state up and then we're going to say rotate the

813
00:46:01.201 --> 00:46:05.800
shape for as many rotations as,
uh,

814
00:46:06.420 --> 00:46:10.380
we defined a beer up here.
So for each possible rotation,

815
00:46:10.590 --> 00:46:14.880
move left as many times as we can.
Move Right for as many times as we can.

816
00:46:15.240 --> 00:46:18.120
And then if the shape has moved at all,
then move it down.

817
00:46:18.300 --> 00:46:22.830
That means like if it's able to move this so it's not blocked,
then move it down.

818
00:46:23.070 --> 00:46:27.180
And while the results are,
and if it,
if it has,
if it's able to move,

819
00:46:27.390 --> 00:46:30.420
then move it.
So here,
here's the step right here.
This,

820
00:46:30.421 --> 00:46:34.650
this part is how the weights,
how the genomes,

821
00:46:34.980 --> 00:46:36.870
how the genes play into the move.

822
00:46:37.380 --> 00:46:40.770
We set the seven parameters of a genome right here.
Okay?

823
00:46:41.040 --> 00:46:45.210
So these are the seven parameters.
We set them,
uh,
using these get functions

824
00:46:46.710 --> 00:46:49.950
and then we rate each of them.
So given our algorithm,

825
00:46:50.250 --> 00:46:54.270
we rate for the current genome,
all of these values by multiplying them together.

826
00:46:54.540 --> 00:46:58.830
And we just concatenate all those values together to get a scalar rating value.

827
00:46:59.070 --> 00:47:02.490
And if the move loses the game,
then we went to lower that rating.
So if there's,

828
00:47:02.491 --> 00:47:05.940
if it's a,
you know,
boolean value,
if the move lost,
then we want to lose the game,

829
00:47:06.180 --> 00:47:08.610
then we want to,
I mean lower trading.

830
00:47:09.180 --> 00:47:13.080
So then we push all the possible moves with their associated ratings and

831
00:47:13.081 --> 00:47:14.640
perimeter values to an array.

832
00:47:14.700 --> 00:47:19.530
So we've tried out all these possible moves using this,
using these,
um,

833
00:47:20.340 --> 00:47:23.960
parameter values.
And so these get,
get her values are getting these,
uh,

834
00:47:24.030 --> 00:47:26.790
wait values from the state of the game.
So whatever they are currently,

835
00:47:26.791 --> 00:47:30.880
it'll get them.
And then we'll use them to rate each of the

836
00:47:32.010 --> 00:47:32.620
<v 1>yeah,</v>

837
00:47:32.620 --> 00:47:35.710
<v 0>uh,
parameter values in our current genome and,</v>

838
00:47:35.770 --> 00:47:37.960
but for every single one that we try out,

839
00:47:38.140 --> 00:47:41.500
so each genome is going to try out a bunch of moves and then we'll use those

840
00:47:41.501 --> 00:47:44.320
parameter values to rate each of them.
Okay.

841
00:47:44.860 --> 00:47:47.290
And so then once we have all the possible moves,

842
00:47:47.500 --> 00:47:50.710
we'll update the position of the old x value for that shape and then push that

843
00:47:50.711 --> 00:47:54.250
to the old x ray and then load the last date and return that array.

844
00:47:54.520 --> 00:47:57.730
So then given that a right,
well how do we get the highest rated move?
Right?

845
00:47:57.731 --> 00:48:01.360
So this,
the next function,
so we'll start off these days is very small.
So we,

846
00:48:01.420 --> 00:48:05.710
so we have an initial Max rating that we want to update an a max move,
um,

847
00:48:05.830 --> 00:48:10.630
variable as well as ties,
which we'll talk about.
Okay.
So,

848
00:48:10.900 --> 00:48:14.080
uh,
so I will say also,
so let's iterate through the list of Moose,

849
00:48:14.170 --> 00:48:15.610
however many removes we have.

850
00:48:15.910 --> 00:48:18.970
And then we'll say if the current moves rating is higher than our Max rating,

851
00:48:19.150 --> 00:48:21.970
which it will be at the start because this is a very,
very small number.

852
00:48:22.300 --> 00:48:25.900
Then we'll update our max value is to include this moves value and then we'll

853
00:48:25.901 --> 00:48:30.640
store the index of this mood of this move in our ties.
Hooray else.
Okay.

854
00:48:30.670 --> 00:48:33.940
So else if the current moves writing is not higher than our Max Rating,

855
00:48:34.300 --> 00:48:38.500
then add the index.
Then if it ties with the Max Rating,

856
00:48:38.740 --> 00:48:43.150
then we're going to just push it to this,
uh,
ties array.
Okay.

857
00:48:43.151 --> 00:48:46.870
So then eventually we're going to set the highest move value to this move value,

858
00:48:47.020 --> 00:48:48.940
and then set the number of ties right here,

859
00:48:49.060 --> 00:48:50.410
and then we're going to return the move.

860
00:48:52.540 --> 00:48:52.910
<v 1>Okay?</v>

861
00:48:52.910 --> 00:48:57.830
<v 0>Okay.
So that's how we decide what the,
uh,
highest rated movie will be.</v>

862
00:48:58.040 --> 00:49:02.270
Given those all the,
all the possible moves we can play.
So,

863
00:49:05.470 --> 00:49:08.050
and then one more function that I want to talk about it over here is the update

864
00:49:08.051 --> 00:49:08.381
function.

865
00:49:08.381 --> 00:49:12.760
So where did we call the update function while we call the update function,

866
00:49:13.210 --> 00:49:16.600
right?
Where was it?
[inaudible]

867
00:49:21.060 --> 00:49:24.950
did score?
Oh,
we call it up here.
So at the highest level,
right?

868
00:49:24.951 --> 00:49:26.810
So we went down through

869
00:49:28.760 --> 00:49:30.920
all of what create an initial population means,
right?

870
00:49:30.921 --> 00:49:32.330
We went down through all of that.

871
00:49:32.750 --> 00:49:36.260
Now we want to talk about the update function and clear interval is just like

872
00:49:36.261 --> 00:49:37.094
native javascript.

873
00:49:37.180 --> 00:49:40.290
But we went through all of that logic and remember this is the highest level of

874
00:49:40.300 --> 00:49:43.490
function.
So this is what matters.
And we went through all of this.

875
00:49:43.670 --> 00:49:45.890
And so now it's time to go through the update function,
right?

876
00:49:45.891 --> 00:49:50.000
So how do we update the game?
Okay?
So let's,
let's see what that looks like.

877
00:49:53.600 --> 00:49:56.510
And I have painstakingly comments at every single line here.

878
00:49:56.630 --> 00:49:59.800
So definitely check out the code on get hub,
but um,

879
00:50:02.670 --> 00:50:06.990
or refer update.
Okay.
So here's how we update the game.

880
00:50:07.260 --> 00:50:10.770
So it's,
this is pretty,
it's pretty readable code.
I like it.

881
00:50:11.010 --> 00:50:14.640
So if we have our AI turned on and the current genome is non zero,
so we have it,

882
00:50:14.790 --> 00:50:17.460
we have a genome and it's the Ai,
then make a move.

883
00:50:17.880 --> 00:50:21.660
And so we moved the shakedown and if that didn't do anything,
if we,

884
00:50:21.750 --> 00:50:25.890
and if we lost then update the fitness function and move on to the next genome.

885
00:50:26.070 --> 00:50:30.780
But if we didn't lose that,
make the next move.
Pretty simple,
right?
Uh,

886
00:50:30.950 --> 00:50:35.300
so,
and if so,
then we have another l statement.
So if the move didn't do anything,

887
00:50:35.330 --> 00:50:39.680
then just move down,
right?
So if,
if the move didn't rotate,

888
00:50:39.681 --> 00:50:42.710
then we moved down and then we output the state to the screen and then update

889
00:50:42.711 --> 00:50:44.960
the score.
So let's look at this update score function.

890
00:50:45.710 --> 00:50:48.200
What does update score mean?
Right?

891
00:50:48.201 --> 00:50:52.130
So this just updating score just means drawing it to html,
like outputting the,

892
00:50:52.240 --> 00:50:57.240
the score value to html after we've used the seven gene values to help rate each

893
00:50:59.151 --> 00:51:01.370
possible move for each possible genome.

894
00:51:01.640 --> 00:51:04.270
And then we pick it and then we picked the highest one or the,
the,

895
00:51:04.280 --> 00:51:07.330
the fittest one.
Because we randomly cross crossover,

896
00:51:07.730 --> 00:51:10.580
we randomly select children via a crossover.

897
00:51:10.850 --> 00:51:14.030
And then when you take those children via our mutation rate,
once we do that,

898
00:51:14.150 --> 00:51:18.380
then we can update the score and the score just means updating the score to the,

899
00:51:18.650 --> 00:51:21.470
to html or to the,
to the,
to,

900
00:51:21.930 --> 00:51:25.640
to the dom to be more technically accurate.
Okay.
So,

901
00:51:26.180 --> 00:51:28.640
and then the rest of these helper functions or just get her and instead or

902
00:51:28.641 --> 00:51:31.910
functions,
uh,
that was really the main logic of this code.

903
00:51:32.030 --> 00:51:34.670
These are just scattering cetera functions like get cumulative cumulative

904
00:51:34.671 --> 00:51:36.440
heights and get holes.

905
00:51:36.440 --> 00:51:39.950
Like it basically goes through the grid and then just like,
you know,

906
00:51:39.951 --> 00:51:42.290
calculates like how many zeros versus how many ones,

907
00:51:42.410 --> 00:51:46.610
what's filled in versus what's not.
That's what this part does.
And then,
uh,
yeah,

908
00:51:47.480 --> 00:51:51.590
that's basically it.
But it's a,
it's,
it's about a thousand lines of code.
Uh,

909
00:51:51.620 --> 00:51:56.120
but it's all,
it all fits in this js file and it's all readable.
So,

910
00:51:56.600 --> 00:51:59.690
uh,
I def,
I hope you check it out.
It's going to be awesome if you do.

911
00:51:59.780 --> 00:52:03.560
I want to see more people using evolutionary algorithms.

912
00:52:03.680 --> 00:52:05.470
And let me end this with answering,
uh,

913
00:52:05.540 --> 00:52:09.380
just two questions randomly from the comments.
Okay.

914
00:52:09.381 --> 00:52:13.700
So let me answer some questions
from the comments.

915
00:52:14.600 --> 00:52:17.120
Here we go.
All right,
here's a question.

916
00:52:17.180 --> 00:52:20.390
We needed blockchains to distribute and decentralize our systems.

917
00:52:20.450 --> 00:52:24.470
So no single entities like governments or organizations can overpower us.

918
00:52:24.620 --> 00:52:25.640
Absolutely.
I think there's,

919
00:52:25.880 --> 00:52:30.290
I mean there is a huge opportunity to combine artificial intelligence with

920
00:52:30.291 --> 00:52:34.610
blockchain technology to create entirely autonomous organizations and

921
00:52:34.611 --> 00:52:38.370
corporations and all sorts of organizations that live,
uh,

922
00:52:38.570 --> 00:52:42.650
in a distributed system that no one has control over.
And it just,

923
00:52:42.950 --> 00:52:47.480
it self improves itself and it has its own rules embedded in smart contracts.

924
00:52:47.900 --> 00:52:50.390
And Yeah,
there's a lot of possibility for using blockchains.

925
00:52:50.930 --> 00:52:54.700
And one idea that I think is really great is,
uh,

926
00:52:54.960 --> 00:52:56.180
the idea of tensor coin.

927
00:52:56.270 --> 00:52:59.870
So a distributed system where you're using a cryptocurrency to pay people for

928
00:52:59.871 --> 00:53:03.170
compute,
peer to peer compute.
So there's my answer to that,

929
00:53:03.171 --> 00:53:06.800
like it's not really a question,
it was a statement.
But one more question.

930
00:53:07.280 --> 00:53:08.330
And the question is,

931
00:53:10.520 --> 00:53:14.360
can you please make a tutorial on handling multi-variate time series data using

932
00:53:14.361 --> 00:53:19.090
LSTM and care os?
So yes,
I've made a video on that.

933
00:53:19.490 --> 00:53:22.880
How to predict stock prices easily and also,
uh,

934
00:53:24.740 --> 00:53:27.710
what else?
Yeah,
that's the main one.
Okay,
cool.

935
00:53:27.770 --> 00:53:31.580
Please subscribe for more programming videos.
And for now I've got to go evolve.

936
00:53:31.700 --> 00:53:32.930
So thanks for watching.

