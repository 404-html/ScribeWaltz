WEBVTT

1
00:00:00.150 --> 00:00:03.210
Hello world.
It's a Raj and welcome to the blockchain.

2
00:00:03.270 --> 00:00:06.780
I know I've been talking about blockchain a lot these past few weeks and there's

3
00:00:06.781 --> 00:00:11.280
a reason for that because this space is heating up really fast and as people who

4
00:00:11.281 --> 00:00:12.780
are interested in AI,

5
00:00:12.990 --> 00:00:17.370
the blockchain is going to provide a lot of opportunities for AI.

6
00:00:17.520 --> 00:00:19.020
That's what this video is about.

7
00:00:19.230 --> 00:00:22.710
What I'm gonna do is I'm going to first talk about the motivations behind

8
00:00:22.711 --> 00:00:26.760
combining these two different technologies,
blockchain and AI.

9
00:00:26.970 --> 00:00:31.530
Then I'm going to talk about some example apps that use the blockchain and AI

10
00:00:31.531 --> 00:00:32.280
currently,

11
00:00:32.280 --> 00:00:37.280
so you get some ideas on on how you could make your own startup or your own open

12
00:00:37.281 --> 00:00:38.114
source project.

13
00:00:38.220 --> 00:00:43.220
Then I'm going to programmatically right out the proof of work algorithm.

14
00:00:43.710 --> 00:00:44.281
This is the,

15
00:00:44.281 --> 00:00:47.670
this is the key programming bid for this video and after we talk about

16
00:00:47.671 --> 00:00:48.600
blockchain and AI,

17
00:00:48.750 --> 00:00:52.110
we're going to program this thing because it is the workhorse of bitcoin.

18
00:00:52.290 --> 00:00:55.980
Without the proof of work algorithm,
the blockchain is nothing.
Okay.

19
00:00:55.981 --> 00:00:58.140
So that's what we're going to code out.
And the,

20
00:00:58.190 --> 00:01:02.940
the proof of work algorithm is a distributed consensus algorithm and that's

21
00:01:02.941 --> 00:01:06.540
really,
really important for AI.
And by the end of this video,

22
00:01:06.630 --> 00:01:09.870
you will understand why at the,
at the end of the video,

23
00:01:09.871 --> 00:01:13.860
I'm going to talk about a few other distributed consensus algorithms like proof

24
00:01:13.861 --> 00:01:17.130
of stake,
proof of burn and proof of activity.
Uh,

25
00:01:17.131 --> 00:01:20.670
but the main algorithm is going to be proof of work that it's,

26
00:01:20.671 --> 00:01:22.770
that's really what I want to get through.
Okay,

27
00:01:22.771 --> 00:01:27.450
so let's talk about blockchain and AI.
So a blockchain,

28
00:01:27.600 --> 00:01:31.110
a blockchain is,
oh my God,
it is such a Buzzword,
but it should be.

29
00:01:31.470 --> 00:01:36.470
But a blockchain is just a data structure that distributes trust across many

30
00:01:36.811 --> 00:01:41.610
nodes instead of one.
It's like a glorified singly linked to list.
You remember,

31
00:01:41.640 --> 00:01:44.190
you remember link lists from data structures and algorithms,
right?

32
00:01:44.490 --> 00:01:48.240
It's a glorified singly linked lists that lives on everybody's computers,

33
00:01:48.390 --> 00:01:50.520
all the miners,
computers,
all the nodes,

34
00:01:50.521 --> 00:01:53.160
and all the nodes in the network on their computers.

35
00:01:53.460 --> 00:01:57.510
So we can think about the blockchain is a huge chain of transactions.

36
00:01:57.810 --> 00:01:59.970
Let's say we're all a part of the bitcoin network,
right?

37
00:02:00.150 --> 00:02:03.180
Bitcoin is a set of rules for how a network should run.

38
00:02:03.540 --> 00:02:05.760
Let's say you and I are a part of the bitcoin network.

39
00:02:05.790 --> 00:02:08.490
I've got some bitcoin and I want to send you some bitcoin.

40
00:02:08.880 --> 00:02:12.990
When I send you some Bitcoin,
let's say two bitcoin,
cold it huddle to the moon,

41
00:02:12.991 --> 00:02:15.090
right?
Once I send you some Bitcoin,

42
00:02:15.210 --> 00:02:18.600
you're going to hold that bitcoin and the network is going to represent that

43
00:02:18.601 --> 00:02:23.160
transaction as a 25 character hash,
okay?
This is a hash,

44
00:02:23.220 --> 00:02:25.170
a string of letters and numbers,

45
00:02:25.410 --> 00:02:28.800
and then what's going to happen is all the miners in the network are going to

46
00:02:28.801 --> 00:02:31.020
have to validate that transaction.

47
00:02:31.170 --> 00:02:35.070
The majority of the miners have to validate that transaction for it to be added

48
00:02:35.071 --> 00:02:37.200
to the chain of blocks.
This immutable,

49
00:02:37.230 --> 00:02:41.400
this unchangeable list of all the transactions that have ever occurred in the

50
00:02:41.401 --> 00:02:45.930
network that all the nodes have to store a copy of and we can look at this chain

51
00:02:45.931 --> 00:02:47.520
of blocks and it looks kind of like this.

52
00:02:47.521 --> 00:02:51.000
This is a very simplified view of what the block chain looks like.

53
00:02:51.330 --> 00:02:55.920
Each block contains a list of transactions and these transactions are stored in

54
00:02:55.921 --> 00:02:57.930
a Merkle tree.
We'll talk about that in a second.

55
00:02:58.470 --> 00:03:01.840
And then it also has a pointer to the next block in the chain.

56
00:03:01.841 --> 00:03:05.590
That's what I meant by a singly link list.
It's all pointing in one direction.

57
00:03:06.820 --> 00:03:09.400
So it's a chain of blocks,
a blockchain,
right?

58
00:03:09.401 --> 00:03:12.820
So and and a Merkle tree,
by the way,

59
00:03:12.821 --> 00:03:16.780
is a way to organize these transactions,
multiple transactions,
right?

60
00:03:16.960 --> 00:03:19.420
We can hash a set of Hashes,

61
00:03:19.421 --> 00:03:23.260
so creates another hash and then hash those abstractions of hashes again,

62
00:03:23.500 --> 00:03:27.460
and it makes a tree like structure and this is just a way of organizing all of

63
00:03:27.461 --> 00:03:32.380
these different hashes and each minor is going to,
before they can vote,
right?

64
00:03:32.410 --> 00:03:36.880
All the miners have to vote on the validity of any transaction before they can

65
00:03:36.881 --> 00:03:39.790
vote.
They have to provide this proof that they've,

66
00:03:39.940 --> 00:03:44.920
that they've computed this random mathematical problem,
this proof of their work,

67
00:03:44.950 --> 00:03:47.140
this proof of their computational work.

68
00:03:47.230 --> 00:03:50.770
Since every single minor has to provide this proof of work when they give out

69
00:03:50.771 --> 00:03:53.200
their vote,
yes or no,
this transaction is valid.

70
00:03:53.440 --> 00:03:57.550
You would have to have more computing power than the 500 fastest supercomputers

71
00:03:57.551 --> 00:04:01.060
in the world combined to create a fake transaction.

72
00:04:01.061 --> 00:04:05.500
And that's why bitcoin has an $80 billion market cap has been running for seven

73
00:04:05.501 --> 00:04:08.770
or eight years now and no one has broken it.

74
00:04:09.190 --> 00:04:13.180
So that's blockchain.
And now let's talk a little bit about deep learning,
right?

75
00:04:13.181 --> 00:04:14.680
So machine learning and the,

76
00:04:14.960 --> 00:04:18.670
in this in the sense of we're just going to classify something to keep it
simple.

77
00:04:18.671 --> 00:04:23.440
Instead of generating,
right,
we have some input data,
some images of cars.

78
00:04:23.680 --> 00:04:28.180
We want to select the features that we think are going to be most relevant to

79
00:04:28.210 --> 00:04:30.790
identify those pictures as car or not car.

80
00:04:30.820 --> 00:04:35.770
Now remember this is in the labeled data scenario,
the supervised scenario.

81
00:04:36.130 --> 00:04:39.490
We have some cars.
Then we have us at a features for those cars,

82
00:04:39.491 --> 00:04:44.320
like the color blue,
red,
green,
and we have the,
the size,
the make,
the model.

83
00:04:45.210 --> 00:04:49.750
And we want to choose what those ideal features are for our classifier to learn

84
00:04:49.751 --> 00:04:54.010
from.
And once we do that,
then we can classify it.
That's,
that's the,

85
00:04:54.011 --> 00:04:57.370
that's the original way that machine learning worked.
But with the,

86
00:04:57.550 --> 00:04:59.110
but with deep learning,

87
00:04:59.350 --> 00:05:02.560
instead of having to choose those features by hand,

88
00:05:02.890 --> 00:05:07.030
the deep learning algorithm will learn what the best features are.

89
00:05:07.060 --> 00:05:11.800
And this is extremely useful because handpicking features is a pain and we don't

90
00:05:11.801 --> 00:05:12.760
want to have to do that.

91
00:05:13.060 --> 00:05:17.410
Deep learning is a smarter way of learning from our data to classify it.

92
00:05:17.980 --> 00:05:21.760
So one question is,
wait,
so how is this all related?
Well,

93
00:05:21.761 --> 00:05:26.260
deep learning is a set of algorithms in,
it's a subset of machine learning.

94
00:05:26.440 --> 00:05:30.580
So machine learning includes a set of algorithms that learn from data,

95
00:05:30.760 --> 00:05:34.150
that means random forests,
that means support vector machines,

96
00:05:34.300 --> 00:05:38.440
that means neural networks.
And when we take that specific algorithm,

97
00:05:38.470 --> 00:05:43.090
the neural network and apply it to lots of data,
give it lots of computing power.

98
00:05:43.120 --> 00:05:44.620
And so it has lots of layers.

99
00:05:44.830 --> 00:05:48.220
We call that deep learning and it outperforms almost every other machine

100
00:05:48.221 --> 00:05:51.940
learning model almost every time on almost every task.

101
00:05:52.240 --> 00:05:56.470
And that's why it's the hottest space in machine learning right now.
And Ai is a,

102
00:05:56.471 --> 00:05:58.190
is a set of all of that.

103
00:05:58.310 --> 00:06:02.450
So Ai doesn't just have to include traditional algorithms that learn from data

104
00:06:02.451 --> 00:06:04.070
statistically we can all,

105
00:06:04.071 --> 00:06:08.300
we can also use heuristics kind of like these estimate these,
these guesstimates,

106
00:06:08.450 --> 00:06:12.800
right?
Or we could use genetic algorithms or evolutionary algorithms.

107
00:06:12.950 --> 00:06:15.680
There are all sorts of algorithms that encompass AI,

108
00:06:15.860 --> 00:06:19.580
but machine learning and deep learning are the most popular and offer the most

109
00:06:19.581 --> 00:06:24.290
promise,
right?
So it's kind of like this whole Yin and Yang thing.

110
00:06:24.291 --> 00:06:27.260
If we think about the Aa,
if we think about AI and blockchain,

111
00:06:27.261 --> 00:06:30.200
there's a lot of synergy.
I'm going to use the word synergy here,

112
00:06:30.470 --> 00:06:34.880
synergistic between these two technologies and they are very different

113
00:06:34.881 --> 00:06:37.940
technologies,
but they're very complimentary to each other.

114
00:06:38.330 --> 00:06:40.670
So Ai is probabilistic.

115
00:06:40.880 --> 00:06:44.630
We don't know what the outcome is going to be.
It's changing,
right?

116
00:06:44.720 --> 00:06:47.750
These AI algorithms are constantly updating their weights,

117
00:06:47.751 --> 00:06:52.010
their learnings based on the training data that they're fed and their algorithms

118
00:06:52.011 --> 00:06:56.570
that guess what reality is going to be is on the other hand,

119
00:06:56.600 --> 00:07:01.010
are deterministic.
That means we know what the outcome is going to be.

120
00:07:01.250 --> 00:07:05.420
They are permanent,
they are immutable,
they do not change at all.

121
00:07:05.660 --> 00:07:09.500
And these are algorithms and cryptography to record reality.

122
00:07:09.770 --> 00:07:14.720
So while AI is about machines making edgy,
making educated guesses for us,

123
00:07:15.110 --> 00:07:19.730
blockchains are more about validation and permanence and greater degrees of

124
00:07:19.731 --> 00:07:24.340
certainty and control,
right?
Deterministic versus the Castic,

125
00:07:24.470 --> 00:07:27.050
Aka unpredictable,
right?

126
00:07:27.051 --> 00:07:32.030
So Ai can be our intelligence,
right?
It can,
it can learn from data.
It can,

127
00:07:32.031 --> 00:07:36.410
it can find these insights that we could not,
and the blockchain will play.

128
00:07:36.411 --> 00:07:39.380
The rule will play the role of the truth teller,

129
00:07:39.381 --> 00:07:43.400
the mediator that's going to bring two parties together and to,

130
00:07:43.490 --> 00:07:47.750
to complete strangers and let them trust each other without needing a third

131
00:07:47.751 --> 00:07:51.950
party in the mix.
It distributes trust across many notes.

132
00:07:52.400 --> 00:07:56.600
So let's talk about some use cases,
right?
So I made a video on this,
uh,

133
00:07:56.720 --> 00:08:00.080
on this decentralized marketplace for data called open mind.

134
00:08:00.320 --> 00:08:03.870
But let me go over it really quickly.
Again,
so in,
in,

135
00:08:03.871 --> 00:08:07.820
in terms of AI and blockchain,
this is one of the most perfect examples,
right?

136
00:08:08.930 --> 00:08:12.350
Because we have,
we have a model,
right?
If I'm a data scientist,

137
00:08:12.530 --> 00:08:15.500
I have a model that I want to train.
Let's say it's a deep neural network.

138
00:08:15.710 --> 00:08:20.210
I want to train it on your data,
right?
So if I want to train it on your data,

139
00:08:20.450 --> 00:08:23.630
if there was a third party involved,
like some central App,
right?

140
00:08:23.631 --> 00:08:26.990
Some central server,
then three different people could steal from each other,

141
00:08:26.991 --> 00:08:30.680
right?
If I'm an AI scientists and I'm trying to train on your data,

142
00:08:30.860 --> 00:08:34.910
I could steal your data.
Or if I give you my model,
you could steal my model.

143
00:08:35.090 --> 00:08:38.780
Or if we use the third party,
they could steal your data and my model,
right?

144
00:08:38.781 --> 00:08:43.180
So what is a way that we can have this transaction,
right?
Your data,

145
00:08:43.220 --> 00:08:47.000
my model,
I pay you for your data.
You,
I train my model on your data,

146
00:08:47.230 --> 00:08:50.390
return it back to me without anyone having to trust each other.

147
00:08:50.630 --> 00:08:53.910
And that's the problem that open mind solves by using the,

148
00:08:54.020 --> 00:08:58.290
by using AI and blockchain.
Specifically,
when I say blockchain,

149
00:08:58.500 --> 00:09:00.150
I'm talking about a smart contract.

150
00:09:00.330 --> 00:09:05.330
So the Tldr of a smart contract is some code that lives on a blockchain

151
00:09:05.520 --> 00:09:06.353
specifically.

152
00:09:06.420 --> 00:09:10.140
Etherium is probably the most popular of those blockchains where you can,

153
00:09:10.170 --> 00:09:13.200
you can push code onto the blockchain itself,
right?

154
00:09:13.201 --> 00:09:17.400
So normally you would push code on to Heroku and then her would say,
Hey,

155
00:09:17.401 --> 00:09:21.300
I've got your code,
I've computed it.
The answer is five,
trust me.

156
00:09:22.050 --> 00:09:23.100
But with a blockchain,

157
00:09:23.101 --> 00:09:27.300
you don't have to trust Heroku to say to have computed your algorithm.

158
00:09:27.630 --> 00:09:31.530
You instead,
because of this distributed consensus algorithm that's at work,

159
00:09:31.531 --> 00:09:33.630
proof of work,
you don't have to trust anybody.

160
00:09:33.900 --> 00:09:37.710
You know that this code is going to be valid even though it's living on all of

161
00:09:37.711 --> 00:09:41.160
these different notes.
Right.
So you would push some code,

162
00:09:41.190 --> 00:09:43.710
a smart contract to this etherium blockchain.

163
00:09:44.130 --> 00:09:46.260
All the nodes would have to verify that,

164
00:09:46.261 --> 00:09:51.261
that though the majority of the notes would have to verify that this code is

165
00:09:51.331 --> 00:09:52.740
indeed valid.
And then the,

166
00:09:52.830 --> 00:09:57.210
they would also use this consensus algorithm like proof of work or proof of

167
00:09:57.211 --> 00:10:01.250
stake to maintain validity.
So in,

168
00:10:01.251 --> 00:10:06.120
in the case of open mind,
a startup sends a model Spec to a smart contract,
right.

169
00:10:06.360 --> 00:10:10.680
And because the model will initialize inside of the smart contract itself,

170
00:10:10.950 --> 00:10:13.650
uh,
no one can we,

171
00:10:13.720 --> 00:10:16.080
we know that I'm not trying to steal anybody's data,

172
00:10:16.081 --> 00:10:20.340
I haven't hidden anything in the model because the model is initialized on a

173
00:10:20.341 --> 00:10:22.950
smart contract.
So no human is in charge of that.

174
00:10:23.340 --> 00:10:26.520
And then the smart contract is going to send that model spect,

175
00:10:26.550 --> 00:10:30.960
that is some money and some instructions on how to train that model to an
oracle.

176
00:10:31.140 --> 00:10:34.110
And the Oracle is going,
which is a third party,

177
00:10:34.260 --> 00:10:36.540
is going to generate a public private key pair.

178
00:10:36.660 --> 00:10:40.020
It's going to encrypt the model and then send it back to the smart contract.

179
00:10:40.320 --> 00:10:43.800
And then after training on all the users,
the model is sent back to the Oracle.

180
00:10:43.801 --> 00:10:47.550
It's decrypted encrypted with the oracles keys then sent back.

181
00:10:47.760 --> 00:10:50.670
And since the oracle acts as a trusted third party,

182
00:10:50.850 --> 00:10:53.130
no one can decrypt the model or gradients.

183
00:10:53.400 --> 00:10:57.810
We'll have a second smart contract that acts as an insurance policy against the

184
00:10:57.811 --> 00:11:02.700
oracle sharing secrets.
So it's a two step process.
The oracle will pay a bounty.

185
00:11:02.701 --> 00:11:06.030
Let's say the Oracle is AWS,
the Oracle will pay a bounty.

186
00:11:06.240 --> 00:11:09.780
And if anyone discovers the keys,
the public private keys for the model,

187
00:11:09.930 --> 00:11:14.730
then they get that bounty.
So the Oracle is incentivized to not,
uh,

188
00:11:14.910 --> 00:11:17.160
give out those public keys,
right?
So it's a,

189
00:11:17.310 --> 00:11:22.260
it's a trust less system because it uses AI and blockchain.
Let's keep going.

190
00:11:23.460 --> 00:11:27.170
Another example is called numerous,
numerous,
numerous,

191
00:11:27.690 --> 00:11:30.540
which is a decentralized AI hedge fund.
Okay.

192
00:11:30.541 --> 00:11:34.410
So it also uses the blockchain and AI together.
So what this is,

193
00:11:34.411 --> 00:11:39.360
is it's a hedge fund that lets data scientists make predictions based on their

194
00:11:39.361 --> 00:11:42.750
models.
So numerous AI offers data for free.
Okay.

195
00:11:42.751 --> 00:11:46.530
So it's offering all of this stock market data and I,

196
00:11:46.531 --> 00:11:49.800
or you as a data scientist can say,
I'm going to take this data,

197
00:11:49.920 --> 00:11:53.880
I'm going to create some model algorithm and I'm going to my pan,

198
00:11:53.881 --> 00:11:57.530
I'm going to train it on this data and I'm going to submit my predictions back

199
00:11:57.531 --> 00:12:01.330
to numero AI with some tokens to support that prediction.

200
00:12:01.720 --> 00:12:05.530
Now this token is its,
its,
its,
its internal currency.
Numerous,

201
00:12:05.590 --> 00:12:09.880
numerous internal Corrine's currency called Nmr.
Okay.

202
00:12:09.881 --> 00:12:12.100
And it's built on top of the ethereum blockchain.

203
00:12:13.120 --> 00:12:17.530
And so numerous AI will take all the models that all the data scientists give it

204
00:12:17.770 --> 00:12:21.700
and it will combine it into a metta model,
this,
this metamodel.

205
00:12:21.820 --> 00:12:24.970
So we'll use all the learnings,
all the gradients from all the models,

206
00:12:25.090 --> 00:12:27.190
and then we'll combine it and to produce this metamodel.

207
00:12:27.400 --> 00:12:28.480
And then it's going to make.

208
00:12:28.620 --> 00:12:31.750
And then time will show who's predictions where the most accurate.

209
00:12:32.020 --> 00:12:35.680
And those data scientists who had the most accurate predictions will not only

210
00:12:35.681 --> 00:12:39.010
get their money back,
but they will get a reward on top of that.

211
00:12:39.160 --> 00:12:41.830
So everybody is incentivized to make good predictions.

212
00:12:41.950 --> 00:12:44.200
But if you don't make a good prediction,
then you lose your money.

213
00:12:44.770 --> 00:12:49.770
And the fact that they are using an internal token is a great use case for the

214
00:12:51.341 --> 00:12:54.430
blockchain because it acts as a hybrid asset,
right?

215
00:12:54.430 --> 00:12:57.430
You can use this internal token as both a currency,

216
00:12:57.670 --> 00:13:02.670
but you could also save a part of it and use it as a security or I stock a share

217
00:13:02.831 --> 00:13:06.910
in the network that will grow in value over time as the network becomes more

218
00:13:06.911 --> 00:13:11.230
profitable,
right?
So that's a way to kind of share the profits with your users.

219
00:13:11.410 --> 00:13:16.120
And if I had a version of new marae I that did not have an internal token that

220
00:13:16.121 --> 00:13:18.850
the data scientists did not get to share in the profit from,

221
00:13:19.090 --> 00:13:20.710
of course numerous is going to win.

222
00:13:20.711 --> 00:13:24.970
And the way to do that as a use of blockchain where the users can share in the

223
00:13:24.971 --> 00:13:27.190
profit from the,
from the network.

224
00:13:28.960 --> 00:13:31.510
Another example is a self driving car network.

225
00:13:31.540 --> 00:13:34.150
Pretty soon we're going to see a lot of these self driving cars,

226
00:13:34.151 --> 00:13:38.500
tens of thousands of these giant machines that are autonomous.

227
00:13:38.650 --> 00:13:42.730
They're on the road and they're moving at,
you know,
very fast,
right?

228
00:13:42.731 --> 00:13:47.050
So we have to be very careful about how we architect this self driving car

229
00:13:47.080 --> 00:13:51.010
network.
Now one way to do it is using a centralized node,
right?

230
00:13:51.011 --> 00:13:54.310
We have one server and it's controlling every other car.

231
00:13:54.520 --> 00:13:56.950
Just think about the security implications of that,
right?

232
00:13:57.070 --> 00:13:58.690
If someone hacks is server,

233
00:13:58.930 --> 00:14:03.790
then every single car is now vulnerable to attack.
We need a better system,

234
00:14:03.791 --> 00:14:08.680
right?
Cars are on the road.
They might be communicating with each other,
oh,

235
00:14:08.681 --> 00:14:12.340
you're on this land,
you're on that lane.
Let me share some resources with you.

236
00:14:12.520 --> 00:14:15.880
Let me park myself,
let me pay for my own gas,

237
00:14:16.000 --> 00:14:20.920
let me maintain myself.
There's some kind of automated car maintenance shop.

238
00:14:21.160 --> 00:14:24.340
You can see how they're,
how cryptocurrency works well here.

239
00:14:24.490 --> 00:14:27.190
And you can also see how smart contracts work well here.

240
00:14:27.400 --> 00:14:31.540
Let the machines talk to each other without the need for a trusted third party.

241
00:14:31.720 --> 00:14:36.490
And there's a third point as well.
Ideally we would want an audit trail,
right?

242
00:14:36.491 --> 00:14:41.050
So if in case some kind of a car crash happens or some kind of accident,

243
00:14:41.290 --> 00:14:44.920
anyone can,
can verify what the AI model was thinking,

244
00:14:45.040 --> 00:14:50.040
what it's a list of decisions were immediately because it's publicly verifiable

245
00:14:50.111 --> 00:14:53.000
and it's immutable and Aka a blockchain,
right?

246
00:14:53.001 --> 00:14:57.860
So self driving car networks that are fully autonomous involved,

247
00:14:57.861 --> 00:14:59.780
no trusted third party,

248
00:14:59.781 --> 00:15:03.110
they are networks that run and maintain themselves.

249
00:15:03.290 --> 00:15:05.000
So of Joe a self driving car network.

250
00:15:05.001 --> 00:15:08.780
It's another great example of how to use AI and blockchain together.

251
00:15:09.560 --> 00:15:13.700
And um,
right.
So like I said,

252
00:15:13.760 --> 00:15:16.970
[inaudible] it encourages data sharing.
Whenever we use a blockchain,

253
00:15:16.971 --> 00:15:21.740
it encourages data sharing,
which leads to more data,
which leads to more model,

254
00:15:21.770 --> 00:15:26.090
which leads to better models.
It's immutable and it provides an audit trail,

255
00:15:26.091 --> 00:15:30.740
right?
So any kind of decision that an AI makes,
as long as it's,
as long as it's,

256
00:15:30.800 --> 00:15:32.150
it's on a blockchain,

257
00:15:32.300 --> 00:15:36.470
we can all verify all of the decisions that it's been making to,

258
00:15:36.620 --> 00:15:39.110
to kind of come to a conclusion about its result.

259
00:15:39.500 --> 00:15:44.500
And native assets are just a great example of giving more power to our

260
00:15:44.721 --> 00:15:45.770
applications,
right?

261
00:15:45.980 --> 00:15:50.300
That have these internal tokens where the users share in the profits from the

262
00:15:50.301 --> 00:15:54.530
APP and the Ai as well,
which leads me to the wildest,

263
00:15:54.531 --> 00:15:57.890
but also most awesome slash also most scary idea,

264
00:15:58.280 --> 00:16:01.130
which is artificially intelligent,

265
00:16:01.131 --> 00:16:05.900
distributed autonomous organizations or a dao.
You could,

266
00:16:05.901 --> 00:16:07.820
we could call it a doubt,
a doubt.

267
00:16:07.821 --> 00:16:10.070
And in a way to self driving car network is a Dell,

268
00:16:10.250 --> 00:16:15.080
but a dao is a computational process that runs autonomously on decentralized

269
00:16:15.081 --> 00:16:15.950
infrastructure.

270
00:16:15.980 --> 00:16:20.030
That means there is no central point of control with resource manipulation.

271
00:16:20.030 --> 00:16:22.910
That means it has some kind of,
uh,
value,

272
00:16:22.911 --> 00:16:25.550
some crypto token that it can use to spend on things,

273
00:16:25.670 --> 00:16:30.110
which means it's code that can own stuff.
So what do I mean by that?
Well,

274
00:16:30.111 --> 00:16:33.200
I think it's best served by looking at this example.

275
00:16:33.260 --> 00:16:36.670
So check out this trippy image.
This was generated by an AI,
okay,

276
00:16:36.890 --> 00:16:41.480
but that used genetic programming.
Now imagine the art dao,
okay,

277
00:16:41.510 --> 00:16:42.830
this isn't,
this is a,

278
00:16:42.831 --> 00:16:46.910
this is a set of instructions that are all smart contracts.

279
00:16:47.030 --> 00:16:50.630
They'll live on the blockchain.
This is an unstoppable AI.

280
00:16:52.010 --> 00:16:54.720
So let's look at this process.
So what,

281
00:16:54.740 --> 00:16:59.660
what the art dow does is it runs an AI engine to generate a new image like this,

282
00:16:59.661 --> 00:17:03.500
using some kind of AI,
machine learning,
deep,
deep learning technology,

283
00:17:03.830 --> 00:17:07.310
and then it claims claims attribution over that generated image on the

284
00:17:07.311 --> 00:17:11.300
blockchain.
Okay?
So,
so we all know that it was the AI that that created,

285
00:17:11.301 --> 00:17:14.330
that it creates multiple additions of that art.

286
00:17:14.630 --> 00:17:18.530
It submits it to some kind of marketplace and then it's,
it sells it,
right?

287
00:17:18.531 --> 00:17:23.470
So then he earns money for its art and then it uses that wealth to,

288
00:17:23.660 --> 00:17:27.440
to then pay for its own resources like computing power and generate more art.

289
00:17:27.650 --> 00:17:29.630
And it just keeps getting better and better,
right?

290
00:17:29.631 --> 00:17:34.631
So you have this AI that is doing this task that the creator that the creator

291
00:17:35.541 --> 00:17:39.980
asked it to do,
and it's using money to maintain itself and grow itself.

292
00:17:40.040 --> 00:17:42.410
So it will get more and more wealthy,
right?

293
00:17:42.411 --> 00:17:45.740
So this could do a lot of great things for us,
right?

294
00:17:45.830 --> 00:17:48.560
But you could also see how this could be a bad thing,
right?

295
00:17:48.800 --> 00:17:53.580
It depends on the person who is creating this technology.
This is so powerful,

296
00:17:53.640 --> 00:17:57.750
is insanely powerful technology.
And it's up to us.

297
00:17:57.780 --> 00:18:01.200
You watching this video to use this technology for good,

298
00:18:01.260 --> 00:18:03.540
for the good of humanity.
It's seriously,
it's up to us.

299
00:18:03.780 --> 00:18:06.660
Very few people understand any of this,

300
00:18:06.690 --> 00:18:11.190
like forget blockchain or AI,
even python or code,
right?

301
00:18:11.400 --> 00:18:14.940
The fact that you're here at this level of the video is really impressive.

302
00:18:14.941 --> 00:18:19.500
So I am very proud of you.
Okay.
So anyway,
let's get to the good stuff.
The code.

303
00:18:19.680 --> 00:18:24.570
So there are two consensus distributed consensus algorithms that are the most

304
00:18:24.571 --> 00:18:28.020
popular proof of work and proof of stake.
Let's talk about proof of work.

305
00:18:28.440 --> 00:18:32.880
So the proof of work algorithm is the reason that bitcoin works,
right?

306
00:18:32.970 --> 00:18:37.170
We have this distributed ledger of all the transactions on the network that

307
00:18:37.171 --> 00:18:40.470
every minor store,
it's a copy of on their computer.

308
00:18:40.710 --> 00:18:43.290
And when they vote on the validity of a transaction,

309
00:18:43.530 --> 00:18:46.620
they have to offer this proof of work,
right?

310
00:18:46.621 --> 00:18:51.621
This proof of work that they've computed this random math problem and only if

311
00:18:52.021 --> 00:18:54.300
they have done that can they vote on a transaction.

312
00:18:54.570 --> 00:18:59.040
So it's a four step algorithm.
It's a four step algorithm.
So a minor,

313
00:18:59.041 --> 00:19:02.870
we'll retrieve a group of transactions from pending transactions to be valid,

314
00:19:02.970 --> 00:19:04.800
to be validated a block.

315
00:19:05.160 --> 00:19:08.760
And it's gonna process some work to generate a proof.
It's going to,

316
00:19:08.850 --> 00:19:12.720
it's going to broadcast that proof of work to every other node in a network.

317
00:19:13.020 --> 00:19:16.680
And then it's going to end if the majority of the network agrees on the validity

318
00:19:16.681 --> 00:19:21.150
of the transaction,
that transaction is an added to the blockchain,
right?

319
00:19:21.151 --> 00:19:23.430
So let's,
let's,
let's code this out.
All right,

320
00:19:23.431 --> 00:19:25.770
so I'm going to code in Python with the proof of work looks like.

321
00:19:25.800 --> 00:19:28.170
So let's start off by importing our dependencies,
right?

322
00:19:28.171 --> 00:19:30.690
So cis is going to help us print out some statements.

323
00:19:30.960 --> 00:19:33.780
Time is going to help us clock how fast this is going.

324
00:19:33.900 --> 00:19:36.450
Hash live is going to help us hash a transaction.

325
00:19:36.900 --> 00:19:41.670
And then lastly we're going to unpack and pack,
which is going to let us,

326
00:19:41.910 --> 00:19:45.570
um,
compress and decompress some data.
Okay?

327
00:19:45.571 --> 00:19:49.730
So those are our dependencies.
And uh,

328
00:19:49.920 --> 00:19:53.220
now let's,
let's write out our variables.

329
00:19:53.221 --> 00:19:56.490
So the first variable we're going to write out is the timestamp,
right?

330
00:19:56.491 --> 00:19:59.880
So a timestamp.
And this is where we're using our time library.

331
00:20:00.150 --> 00:20:02.730
We're going to say,
okay,
time dot time,
that's our timestamp.

332
00:20:02.731 --> 00:20:06.670
We're going to convert it into a string.
And that's our timestamp.
The next,
uh,

333
00:20:06.740 --> 00:20:11.730
variable.
So this,
the next variable is going to be the message.
So the message,

334
00:20:11.731 --> 00:20:15.040
it just is just going to be,
is this just an example?
But,

335
00:20:15.070 --> 00:20:17.820
but hashing a string is suitable work for this project.

336
00:20:17.821 --> 00:20:20.010
So this is a random message,
right?

337
00:20:20.160 --> 00:20:23.430
We can think of this as a part of the transaction.
And then lastly,

338
00:20:23.431 --> 00:20:27.750
we have some payload to the payload is a combination of the times of the things

339
00:20:27.751 --> 00:20:28.800
that we're going to encrypt,

340
00:20:29.010 --> 00:20:31.740
which is going to be the timestamp and then the message,
right?

341
00:20:31.950 --> 00:20:35.130
So these are the things that we want to send to the network.

342
00:20:35.131 --> 00:20:38.310
It can be blocked data as it is with bitcoin mining.
In this case,

343
00:20:38.311 --> 00:20:41.370
it is a message with a payload,
a message with a timestamp.

344
00:20:41.610 --> 00:20:44.940
And that is the payload.
Okay?
So those are the first three variables.

345
00:20:46.080 --> 00:20:50.290
And now let me make this readable.

346
00:20:50.500 --> 00:20:53.650
So now we're going to write out a nonce.

347
00:20:53.710 --> 00:20:57.250
So a nonce is going to increment from zero to end until the target is met.

348
00:20:57.460 --> 00:21:01.570
By the way,
a nonce is a number only used once in cryptography.

349
00:21:01.870 --> 00:21:03.790
A nonce is highly prop popular.

350
00:21:03.791 --> 00:21:06.640
Whenever you're creating any kind of encryption scheme,

351
00:21:06.850 --> 00:21:11.440
you'll use a nonce as a way to,
um,
I mean there's so many different use cases,

352
00:21:11.500 --> 00:21:15.130
but in this case is going to verify that a minor has indeed tried out many

353
00:21:15.131 --> 00:21:19.180
different solutions before offering the proof of computational work.

354
00:21:19.540 --> 00:21:22.120
So we have a nonce and then we have a guest.

355
00:21:22.300 --> 00:21:24.550
And the guest is this is going to store our guests,

356
00:21:24.610 --> 00:21:27.310
which effectively it begins that if infinity

357
00:21:28.840 --> 00:21:32.140
throttle is going to be equivalent to the bitcoin difficulty,

358
00:21:32.141 --> 00:21:36.850
we'll just have some measure of how difficult we want our proof of work

359
00:21:36.851 --> 00:21:38.830
algorithm to be.
Let's just say you know,

360
00:21:39.100 --> 00:21:43.270
a million and the target is going to be the maximum value,
uh,

361
00:21:43.300 --> 00:21:46.300
that have eight bytes divided by the difficulty,
right?

362
00:21:46.301 --> 00:21:48.900
So it's going to be the maximum value,
um,

363
00:21:51.700 --> 00:21:52.570
by the difficulty.

364
00:21:55.390 --> 00:21:57.730
So the nones gonna increment by one each time.

365
00:21:57.731 --> 00:22:00.100
And it's going to count how many guests is the computer makes.

366
00:22:00.400 --> 00:22:03.580
So whenever the system does work,
it doesn't have to trace back over each guest.

367
00:22:03.730 --> 00:22:07.030
It only checks the non submitted with the data.
So

368
00:22:08.740 --> 00:22:12.820
now what we can do is we can create this payload hash.
All right?

369
00:22:12.821 --> 00:22:17.310
By using Hash live.
So we're going to hash the payload,
right?
So that is the uh,

370
00:22:17.410 --> 00:22:22.410
message and that is the timestamp payload hash by using Hash Lie Dot Shah five

371
00:22:25.661 --> 00:22:30.490
12,
take the payload and then digest it.
Uh,
right.

372
00:22:30.700 --> 00:22:34.540
And now we're going to start clocking this proof of work algorithm by saying

373
00:22:34.541 --> 00:22:37.150
start time.
We've got our payload,
we've hashed it.

374
00:22:37.300 --> 00:22:39.400
Now let's run the proof of work.
How rhythm.

375
00:22:39.550 --> 00:22:43.600
So this is a simple loop that I'm going to write and this is the proof of work

376
00:22:43.601 --> 00:22:48.520
algorithm.
So I'm going to say while the guest is greater than the target,
um,

377
00:22:49.180 --> 00:22:54.040
let's increment,
uh,
the nones by one every time.
And then,

378
00:22:54.310 --> 00:22:58.690
uh,
we're going to hash our data with two rounds of Sha two,
five,
six.
Okay.

379
00:22:58.870 --> 00:23:01.570
So we're going to say,
guess unpack.

380
00:23:01.900 --> 00:23:05.060
Let me just write this out cause it's quite a,
quite a lot to write out.

381
00:23:05.061 --> 00:23:09.640
So we've got Hash Live Dot Shah five 12,
and then we're going to hash it again.

382
00:23:10.450 --> 00:23:15.430
Oh Man,
right.
Hash Live Dot Shah five 12.

383
00:23:15.850 --> 00:23:16.390
Uh,

384
00:23:16.390 --> 00:23:21.390
and then again we're going to hash a hash slide dot Shah five 12.

385
00:23:22.060 --> 00:23:24.850
And then we're going to pack this,
uh,

386
00:23:26.380 --> 00:23:28.840
greater than Q,
uh,

387
00:23:28.900 --> 00:23:33.900
which is a [inaudible] plus the payload Hash Dot Digest Dot digest cause it was

388
00:23:38.321 --> 00:23:42.340
to ashes.
And then between zero and eight,
right?

389
00:23:42.341 --> 00:23:45.070
So we went the first bites and the first eight bytes,

390
00:23:45.170 --> 00:23:47.720
that's why we said zero to eight and they're going to be turned into a number.

391
00:23:47.720 --> 00:23:50.840
Effectively.
This is how a computer makes a guess.

392
00:23:51.260 --> 00:23:55.430
So the nonce is going to prove that that work was done.

393
00:23:55.431 --> 00:23:58.020
And let me at the end of this,
let me write out,
uh,

394
00:23:58.090 --> 00:24:01.520
end who could end because we've,
we've ended the,
uh,

395
00:24:02.810 --> 00:24:06.140
the timer,
right?
So the nonce is going to prove that work was done.

396
00:24:06.141 --> 00:24:08.390
And in this valley,
in this example,

397
00:24:08.750 --> 00:24:13.050
it's value represents the number of attempts are CPU made before it founded

398
00:24:13.070 --> 00:24:14.630
valid gas below the target.

399
00:24:14.930 --> 00:24:19.040
And because each guest has the same probability of being under the target method

400
00:24:19.041 --> 00:24:21.620
of generating are nones,
it doesn't matter.
However,

401
00:24:21.621 --> 00:24:25.820
simply incrementing the nonce is cheaper than generating a random number.

402
00:24:25.850 --> 00:24:28.760
So that's why we're,
we're using a nonce,
right?
So

403
00:24:31.170 --> 00:24:35.610
the nones is going to count how many times we've,
we've,
we've made this guests,

404
00:24:35.611 --> 00:24:39.270
right?
So we have some,
right?
So remember our guests is this number right here.

405
00:24:39.540 --> 00:24:42.540
And as long as that number is greater than our target,

406
00:24:42.750 --> 00:24:45.700
this is just going to keep going,
right?
And the nones is our way of,

407
00:24:45.870 --> 00:24:47.400
of saying that yes,
this,

408
00:24:47.401 --> 00:24:51.390
this minor has indeed a computed all of these different solutions before

409
00:24:51.391 --> 00:24:56.130
arriving at this,
uh,
at this,
at this end solution.
And so at the end,

410
00:24:56.131 --> 00:24:57.240
we can print out

411
00:24:59.250 --> 00:25:03.570
all of all of our variables to see,
uh,
what,
what has happened here?

412
00:25:05.700 --> 00:25:06.130
<v 1>Okay?</v>

413
00:25:06.130 --> 00:25:10.210
<v 0>That's it for the proof of work.
And so,
yeah.
So,
so that's proof of work.</v>

414
00:25:10.240 --> 00:25:13.780
Now let's talk about proof of stake a little bit.
So in proof of work,

415
00:25:13.781 --> 00:25:17.300
the probability of mining a block is dependent on how much a month,

416
00:25:17.380 --> 00:25:19.270
how much work is done by the mine.

417
00:25:19.570 --> 00:25:22.480
So payouts become smaller and smaller for bitcoin miners.

418
00:25:22.481 --> 00:25:27.190
So the idea is that there will be less of an incentive to avoid a 51% attack

419
00:25:27.370 --> 00:25:30.880
because minors are going to get paid less over time because there was a limited

420
00:25:30.881 --> 00:25:34.540
supply of bitcoins out there.
Uh,
and so pan,

421
00:25:34.570 --> 00:25:38.980
the other argument behind not having proof of work systems is that mining

422
00:25:38.981 --> 00:25:40.630
communities,
it becomes centralized,
right?

423
00:25:40.631 --> 00:25:42.610
But people have bought these giant computer farms,

424
00:25:42.611 --> 00:25:44.590
just a mine and it's getting centralized.

425
00:25:44.710 --> 00:25:48.580
So one potential solution to proof of work,
it's a youth proof of stake.

426
00:25:48.640 --> 00:25:49.960
So in proof of stake,

427
00:25:50.110 --> 00:25:53.950
a person can mind depending on how many coins they already hold.

428
00:25:54.310 --> 00:25:59.230
And the proof of state system makes any 51% attack more expensive.

429
00:25:59.231 --> 00:26:00.620
So when you,
when,

430
00:26:00.670 --> 00:26:04.990
when a minor is going to vote on the validity of a transaction,

431
00:26:05.260 --> 00:26:07.780
it's not about how much computing power it's they have,

432
00:26:07.930 --> 00:26:10.210
it's about how much stake they have in the network,

433
00:26:10.240 --> 00:26:13.210
which means literally how much money do they have.

434
00:26:14.080 --> 00:26:14.730
<v 1>Okay.</v>

435
00:26:14.730 --> 00:26:19.390
<v 0>Uh,
and it's a more decentralized system.
So in general,</v>

436
00:26:19.391 --> 00:26:22.240
the proof of stake algorithm looks as follows and it's actually,

437
00:26:22.241 --> 00:26:27.241
it's actually really hard to find code for the proof of stake algorithm or

438
00:26:27.550 --> 00:26:31.450
really any kind of diagram or,
I mean,
you can find code,
but it's going to be,

439
00:26:32.050 --> 00:26:36.370
it's going to be huge.
I mean like c plus plus just like 300 lines of code.
So,

440
00:26:36.660 --> 00:26:41.290
um,
I'm just gonna I just code the,
I just coded out the proof of work this time,

441
00:26:41.291 --> 00:26:44.640
but next time I'll,
I'll,
I'll write out the proof of stake and the others.

442
00:26:44.641 --> 00:26:48.600
But it's,
it's a very simple algorithm.
It's a very simple algorithm.

443
00:26:48.930 --> 00:26:49.830
The blockchain keeps,
uh,

444
00:26:50.130 --> 00:26:53.940
keeps track of a set of validators also called miners and the proof of stake

445
00:26:53.941 --> 00:26:54.570
sense.

446
00:26:54.570 --> 00:26:58.800
And anyone can become a validator by sending a special type of transaction that

447
00:26:58.801 --> 00:27:01.050
locks up their coin into a deposit.

448
00:27:01.380 --> 00:27:05.520
And the process of creating and agreeing on new blocks is then done through a

449
00:27:05.521 --> 00:27:09.900
consensus algorithm that all the current validators can participate in.

450
00:27:10.980 --> 00:27:15.180
So there are a lot of different ways to assign awards to these validators who

451
00:27:15.181 --> 00:27:17.670
participate in the consensus algorithm,
right?

452
00:27:17.671 --> 00:27:21.750
There's chain based proof of stake and there's Byzantine fault tolerant proof of

453
00:27:21.751 --> 00:27:24.750
stake,
which is a little too much to go into for one video,

454
00:27:24.751 --> 00:27:29.460
but that is kind of the next up and coming mainstream,

455
00:27:29.660 --> 00:27:32.670
uh,
distributed consensus algorithm after proof of work.

456
00:27:32.820 --> 00:27:37.820
Because the argument is that proof of work is way too computationally expensive.

457
00:27:38.040 --> 00:27:42.480
It wastes way too much electricity and proof of state can be made better.

458
00:27:42.580 --> 00:27:43.740
Ethereum,
for example,

459
00:27:43.980 --> 00:27:48.980
the second highest market cap of cryptocurrency plans on moving from proof of

460
00:27:50.281 --> 00:27:53.670
work to proof of stake next year.
But we'll see how that works.

461
00:27:53.671 --> 00:27:56.340
Because proof of work,
as expensive as it is,

462
00:27:56.550 --> 00:27:59.250
as a unnecessarily wasteful as it is,

463
00:27:59.430 --> 00:28:04.380
it is still the only known distributed consensus algorithm that can work at the

464
00:28:04.381 --> 00:28:09.270
scale that bitcoin has become at.
So we'll see how it goes.

465
00:28:10.050 --> 00:28:11.520
There's also proof of activity,

466
00:28:11.730 --> 00:28:14.580
which is kind of a hybrid of proof of work and proof of stake.

467
00:28:14.820 --> 00:28:19.050
The idea is that it starts off as a proof of work algorithm with all the miners

468
00:28:19.051 --> 00:28:22.400
trying to solve this mathematical problem.
And then,
um,

469
00:28:22.920 --> 00:28:24.540
once there is a winning transaction,

470
00:28:24.541 --> 00:28:28.110
it then switches to proof of stake standard instead of validators are going to

471
00:28:28.111 --> 00:28:30.420
be chosen to sign this new block.

472
00:28:32.340 --> 00:28:33.720
There's also proof of burn,

473
00:28:33.721 --> 00:28:37.140
which is all about you burning coins by sending them to an address,
uh,

474
00:28:37.200 --> 00:28:41.340
where they are irretrievable,
right?
So once you commit your coins to never,

475
00:28:41.341 --> 00:28:44.880
never land ride this place where you can never get this,
get them back,

476
00:28:45.030 --> 00:28:48.990
you earn a lifetime privilege of being able to mind on a system based on a

477
00:28:48.991 --> 00:28:53.760
random selection process.
And over time your stake in the system decays.

478
00:28:53.880 --> 00:28:57.420
So you'll want to continually burn more coins to increase your odds of being

479
00:28:57.421 --> 00:29:01.410
selected in this lottery.
And they're,
they're even more,

480
00:29:01.411 --> 00:29:05.430
there's proof of replication,
which is what file coin uses.
There's proof of,

481
00:29:05.800 --> 00:29:10.140
there's proof of a storage,
there's proof of,

482
00:29:10.200 --> 00:29:14.550
uh,
intelligence,
which is way out there,
which I'll get to at some point.

483
00:29:14.990 --> 00:29:18.930
There's a lot of different proofs and these proofs can be distributed,

484
00:29:19.200 --> 00:29:23.700
but it's also useful to think about proofs just in a general sense,
right?

485
00:29:23.701 --> 00:29:28.560
So on a distributed consensus proof of algorithm that I would most want to see

486
00:29:28.830 --> 00:29:31.710
is called proof of unique identity.
What that means is,

487
00:29:31.770 --> 00:29:35.430
can you prove that you are a unique person in a decentralized way?

488
00:29:35.610 --> 00:29:38.280
We already know how to do this in a centralized way,
right?

489
00:29:38.430 --> 00:29:42.670
Like a government or any kind of central entity can your ID,
right?

490
00:29:42.671 --> 00:29:45.910
Like a government id or social security number or whatever passport.

491
00:29:46.360 --> 00:29:49.720
And then they can say,
well,
I've got this unique number for you.

492
00:29:49.750 --> 00:29:52.540
If you say you're him,
nope,
he's the only one.
Right?

493
00:29:52.541 --> 00:29:54.820
We know how to do that in a central,
centralized way.

494
00:29:55.090 --> 00:29:58.390
But how do we do it in a decentralized way?
And that hasn't been solved?

495
00:29:58.720 --> 00:30:01.300
If we are able to solve proof of unique identity,

496
00:30:02.350 --> 00:30:05.200
he removes the need to have a proof of workout for them,
right?

497
00:30:05.201 --> 00:30:10.120
Because minors are already proven to be unique.
So a civil attack is impossible.

498
00:30:10.150 --> 00:30:12.550
Gaining 51% of the network,
we can just say,

499
00:30:12.730 --> 00:30:16.780
here are all the nodes that are unique.
51% of them have to agree,
right?

500
00:30:16.781 --> 00:30:19.990
So it can also help us create a basic income,
right?

501
00:30:19.991 --> 00:30:24.730
A basic income coin where you could just give out money to a set of unique nodes

502
00:30:24.731 --> 00:30:27.520
in a network.
There's so much we could create online governments,
we could,

503
00:30:27.550 --> 00:30:28.900
we could create so many different things,

504
00:30:28.901 --> 00:30:32.560
but we would just have to solve this proof of unique identity problem.
Uh,

505
00:30:32.650 --> 00:30:36.390
and but anyway,
blockchains and AI go,

506
00:30:36.520 --> 00:30:40.990
blockchain and AI go really well together.
If you were to ask me,
sir,
Rod,

507
00:30:40.991 --> 00:30:41.440
what would you,

508
00:30:41.440 --> 00:30:45.580
what would you do as a startup or what would you do if you were trying to build

509
00:30:45.581 --> 00:30:48.100
something really cool outside of making videos?

510
00:30:48.370 --> 00:30:52.960
I would say I would combine blockchain and AI to make an APP that no one has

511
00:30:52.961 --> 00:30:55.240
ever made before.
And that's what it lets you do.

512
00:30:55.450 --> 00:30:59.110
It lets you create software that has never before been possible.

513
00:30:59.170 --> 00:31:01.600
So if you're studying AI,
if you're setting machine learning,

514
00:31:01.601 --> 00:31:05.680
if you're setting deep learning,
no,
at least a little bit about the blockchain,

515
00:31:05.681 --> 00:31:08.860
because I promise you it's going to come into your periphery.

516
00:31:08.861 --> 00:31:12.700
It's going to come into your line of sight very soon,
if not now.
Okay.

517
00:31:12.701 --> 00:31:16.210
So I hope this video was helpful.
I hope it gave you some ideas and yeah.

