WEBVTT

1
00:00:00.090 --> 00:00:00.840
Hello world.

2
00:00:00.840 --> 00:00:05.040
It's a Raj and who's ready to go into the mathematics of cryptography?

3
00:00:05.280 --> 00:00:09.750
I know I am.
That's what this video is about.
The mathematics of cryptography.

4
00:00:09.930 --> 00:00:13.800
Cryptography is used all over the place in our day to day lives in places we

5
00:00:13.801 --> 00:00:14.730
don't even think about it.

6
00:00:14.731 --> 00:00:19.170
Everything from our telephones to ATM machines to https,

7
00:00:19.171 --> 00:00:23.130
the one of the protocols that are fundamental to the web blockchain technology

8
00:00:23.131 --> 00:00:26.250
and of course artificial intelligence.
Okay,

9
00:00:26.251 --> 00:00:30.180
so what we're gonna do is we're going to go into the math of cryptography and

10
00:00:30.181 --> 00:00:32.370
I'm going to show you a demo.
First of all,

11
00:00:32.580 --> 00:00:34.920
this is running on local host right now.
I've see right here.

12
00:00:35.160 --> 00:00:40.140
What this is is it is a collaborative text editor that is zero knowledge.

13
00:00:40.290 --> 00:00:44.430
What that means is we can collaborate on this text editor,

14
00:00:44.431 --> 00:00:46.650
like I can type something in like you know,
hey,

15
00:00:46.651 --> 00:00:50.340
what's up and notice how I'm anonymous.
Other users can join this.

16
00:00:50.370 --> 00:00:54.810
It's peer to peer and no server can can know what we are typing.

17
00:00:55.140 --> 00:00:57.510
Even if we were to put this app on a server,

18
00:00:57.720 --> 00:01:02.250
no one would be able to tell what that data is unless they had our key signature

19
00:01:02.280 --> 00:01:05.670
or digital signature for the,
for this,
uh,
editor.
So that's,

20
00:01:05.820 --> 00:01:06.870
that's the really cool part.

21
00:01:06.871 --> 00:01:09.810
I'm going to go into the code for this at the very end.
Uh,

22
00:01:09.811 --> 00:01:11.010
but before we get into that,

23
00:01:11.160 --> 00:01:13.890
we have to talk about the mathematics that that's used in it,
right?

24
00:01:13.891 --> 00:01:15.780
The mathematics of cryptography.

25
00:01:16.050 --> 00:01:19.830
Now what I'm gonna do is I'm going to go into the details of cryptography and

26
00:01:19.831 --> 00:01:21.540
then I'm going to go into some of the use cases,

27
00:01:21.690 --> 00:01:23.910
particularly artificial intelligence,

28
00:01:24.240 --> 00:01:27.150
and then we're going to eventually go into the code for this.
Okay.

29
00:01:27.180 --> 00:01:29.550
So first of all,

30
00:01:29.580 --> 00:01:34.000
and also the thing I'm most excited to talk about is the concept of Zika.

31
00:01:34.020 --> 00:01:36.810
Snarks you might be thinking,
what are you,
yeah,

32
00:01:36.870 --> 00:01:38.190
I know we're going to get into that,

33
00:01:38.191 --> 00:01:41.610
but we have some building blocks to get into before we can talk about Zika.

34
00:01:41.611 --> 00:01:44.840
Snarks so what is cryptography?
So check out this,
uh,

35
00:01:44.900 --> 00:01:49.890
image I've got here of,
uh,
this beautiful text.
I love apples.

36
00:01:49.920 --> 00:01:54.630
I do love apples.
I don't like apple juice.
I like apples.
So we take this text,

37
00:01:54.780 --> 00:01:58.110
I love apples and we have a key.
This key could be anything.

38
00:01:58.111 --> 00:01:59.820
It's it's some sort of algorithm.

39
00:01:59.821 --> 00:02:04.230
It's some sort of series of steps to in cipher or encrypt some,

40
00:02:04.231 --> 00:02:07.260
some plain text.
So we say I love apples.

41
00:02:07.320 --> 00:02:11.070
The key is to replace every letter with the third successive letter.

42
00:02:11.580 --> 00:02:14.430
So I love apples would be I,
we start off with ISO.

43
00:02:14.490 --> 00:02:19.440
What's the third successive letter in the alphabet?
I J k.
So then I becomes k.

44
00:02:19.920 --> 00:02:23.820
Okay,
so a,
what's the third success of letter in the alphabet,
a,
B,
c.

45
00:02:23.821 --> 00:02:26.940
So then a becomes C and we do that for every single letter.

46
00:02:27.180 --> 00:02:31.170
And once we do that we're going to end up with this random looking unreadable,

47
00:02:31.320 --> 00:02:34.860
what's called cipher.
Now this is the essence of cryptography.

48
00:02:34.861 --> 00:02:39.810
Cryptography is a set of techniques to scramble data,
disguise data.

49
00:02:39.960 --> 00:02:42.390
It's used all over the place in computer science.

50
00:02:42.510 --> 00:02:45.990
And it's a really important topic to understand because no matter what you're

51
00:02:45.991 --> 00:02:50.220
doing,
no matter what field you go into in computer science,
whether it's Ai,
web,

52
00:02:50.221 --> 00:02:54.240
APP development,
mobile APP development,
cryptography is paramount to security,

53
00:02:54.390 --> 00:02:58.740
to privacy and to an anonymity.
Okay?
So this is a really important concept.

54
00:02:58.800 --> 00:03:02.800
And so in cryptography the scrambled data is available only to someone who can

55
00:03:02.801 --> 00:03:05.230
restore the data to its original form.

56
00:03:05.440 --> 00:03:09.280
So what that means is this data is kept secret from unauthorized people,

57
00:03:09.520 --> 00:03:14.440
but easily decipherable by authorized people.
Someone who has the key for that,

58
00:03:14.441 --> 00:03:19.000
for that cipher text.
Cryptography deals with encryption,
decryption,

59
00:03:19.150 --> 00:03:23.110
hashing and digital signatures mainly.
Let's go into each of these.

60
00:03:23.290 --> 00:03:28.290
So encryption first of all is one of the most critical tools used in

61
00:03:28.361 --> 00:03:33.040
cryptography.
It means converting intelligible,
plain text into cipher text,

62
00:03:33.220 --> 00:03:34.420
which is not intelligible.

63
00:03:34.690 --> 00:03:38.500
And there are three forms of encryption that are widely used,
symmetric,

64
00:03:39.070 --> 00:03:40.720
asymmetric and hashing.

65
00:03:40.930 --> 00:03:44.230
So check out this image here we have a sender and we have a recipient to

66
00:03:44.231 --> 00:03:45.580
different nodes in a network.

67
00:03:45.910 --> 00:03:50.170
And if I'm the sender and I want to send you some plain text message that only

68
00:03:50.171 --> 00:03:52.960
you can read and no matter if this message is intercepted,

69
00:03:53.080 --> 00:03:56.710
if it goes to the wrong person only you will be able to read this message.

70
00:03:57.100 --> 00:04:01.070
I will use encryption to secure that message and so I'll have some plain text

71
00:04:01.110 --> 00:04:05.710
like hello world,
the strength,
I'll encrypt it using some encryption algorithm.

72
00:04:06.730 --> 00:04:08.290
Let's say a public key for example.

73
00:04:08.620 --> 00:04:12.910
Let's say I receive a public key from that encryption algorithm that that

74
00:04:12.940 --> 00:04:17.050
message becomes a cipher text and if you,
once you receive that cipher text,

75
00:04:17.170 --> 00:04:20.350
it looks random.
It's just a bunch of letters.
That knee nonsense.

76
00:04:20.650 --> 00:04:22.090
If you have the private key,

77
00:04:22.180 --> 00:04:26.680
you can decrypt that a cipher and get the plain text,
the original plain text,

78
00:04:26.681 --> 00:04:29.320
hello world and that's public private key cryptography.

79
00:04:29.321 --> 00:04:30.700
That's one type of cryptography,

80
00:04:31.120 --> 00:04:36.120
but symmetric encryption is the one of the oldest forms of cryptographic methods

81
00:04:36.641 --> 00:04:39.490
known to mankind.
Okay.
The concept is very,

82
00:04:39.491 --> 00:04:42.430
very simple and if we were to break it down to steps,
it would look like this.

83
00:04:42.760 --> 00:04:46.510
I have some message m that I want to send over to you.
Okay.

84
00:04:46.840 --> 00:04:50.470
I encrypt the message with a key and I get a cipher text.
See,
okay,

85
00:04:50.471 --> 00:04:53.300
this is a cipher text.
Now you get that cipher text.

86
00:04:53.301 --> 00:04:55.570
See if you had that same key that I have.

87
00:04:55.690 --> 00:05:00.670
You can now retrieve that original message m so it's one key to both encrypt and

88
00:05:00.671 --> 00:05:04.690
decrypt.
And because it's one key on both sides,
it's called symmetric.

89
00:05:04.720 --> 00:05:06.400
So that's the oldest form of encryption.

90
00:05:06.790 --> 00:05:11.260
Now another form of encryption that uses a public private key pair is called

91
00:05:11.261 --> 00:05:14.940
asymmetric encryption.
No,
you know,
notice from Bitcoin,

92
00:05:14.950 --> 00:05:18.190
it uses this and all of these blockchains they use public private key

93
00:05:18.191 --> 00:05:21.100
cryptography.
But the idea is similar but different.

94
00:05:21.101 --> 00:05:25.330
The idea is that utilizes two keys,
not one,
a public key and a private key.

95
00:05:25.360 --> 00:05:27.940
And the use of one key cancels out the use of the other.

96
00:05:28.180 --> 00:05:31.600
So I'll encrypt something with the public key and then you can use the private

97
00:05:31.601 --> 00:05:34.630
key or the secret key to then decrypt it and it's asymmetric.

98
00:05:36.340 --> 00:05:39.500
Now hashing is another example.
So recall from you know,

99
00:05:39.570 --> 00:05:43.630
data structures and algorithms.
One O one.
Hopefully you've taken that.
Uh,
if not,

100
00:05:43.900 --> 00:05:46.450
uh,
don't worry about it.
We always go over it a bit right now.

101
00:05:46.451 --> 00:05:49.840
But hashing is a way to take some,
uh,

102
00:05:50.080 --> 00:05:54.310
plain text key and convert it into a hash that you're putting into a bucket or a

103
00:05:54.311 --> 00:05:56.770
hash table,
which is easily retrievable.

104
00:05:56.771 --> 00:06:01.771
So Hash tables are great because they have constant time retrieval,

105
00:06:01.911 --> 00:06:06.290
which is awesome.
And storage as well,
I believe,
don't quote me on that one,

106
00:06:06.291 --> 00:06:07.520
I'm just saying that from memory,

107
00:06:07.521 --> 00:06:11.180
but hash tables are really fast for both storage and retrieval compared to other

108
00:06:11.181 --> 00:06:14.480
data structures.
But the idea is that you have some hash function.
It's a,

109
00:06:14.481 --> 00:06:18.140
it's a static hash function.
It could be dynamic,
but you know,
standard,

110
00:06:18.170 --> 00:06:21.740
the standard is a static hash function and you put in a list of keys,
right,

111
00:06:21.741 --> 00:06:26.060
names,
passwords,
whatever.
And it's going to convert that key into a hash.

112
00:06:26.090 --> 00:06:30.200
Like John Smith will become Otu using this hash function.
Lisa Smith will become,

113
00:06:30.201 --> 00:06:34.010
oh one Sam doe will become,
oh for Sandra Dee will become Otu.

114
00:06:34.011 --> 00:06:38.480
So notice that both John Smith and Sandra Dee Dee become Otu.

115
00:06:38.720 --> 00:06:43.340
And this is a problem,
right?
We want unique,
we want unique Hashes for these keys.

116
00:06:43.580 --> 00:06:45.650
And so this is considered a collision,
right?

117
00:06:45.770 --> 00:06:50.600
We want to prevent collisions from happening.
Uh,
and in the context of Bitcoin,

118
00:06:50.840 --> 00:06:54.800
the transactions are taking as input and run through a hashing algorithm.

119
00:06:54.950 --> 00:06:58.370
So bitcoin uses what's called the Sha two five six algorithm,

120
00:06:58.460 --> 00:07:00.530
which gives an output of a fixed length.

121
00:07:00.830 --> 00:07:04.460
So there's a specific type of hash function that these blockchains use.

122
00:07:04.730 --> 00:07:07.310
And this is called a cryptographic hash function.

123
00:07:07.520 --> 00:07:11.300
It's a special class of Hash functions that has various properties that make it

124
00:07:11.330 --> 00:07:14.900
ideal for cryptography.
So the first property is that it's deterministic,

125
00:07:14.930 --> 00:07:18.170
that that means that no matter how many times you parse through a particular

126
00:07:18.171 --> 00:07:21.500
input through a hash function,
you're always gonna get the same results.

127
00:07:21.710 --> 00:07:25.280
And this is important because if you get different hashes every single time,

128
00:07:25.550 --> 00:07:28.490
it's impossible to keep track of the original input.

129
00:07:28.820 --> 00:07:32.780
The second property is quick computation.
This hash functions gotta be fast.

130
00:07:32.781 --> 00:07:35.120
You've got to be able to hash to think fast.
And if not,

131
00:07:35.121 --> 00:07:37.850
it's not gonna be able to scale.
Your system's not going to be able to scale.

132
00:07:38.320 --> 00:07:41.720
It's got to be pre image resistance,
meaning that given a hash,

133
00:07:41.870 --> 00:07:46.640
it's infeasible to determine the original,
uh,
plain text.
And notice that,

134
00:07:46.650 --> 00:07:48.890
that I said the word infeasible,
not impossible.

135
00:07:49.010 --> 00:07:52.580
We already know that it's not impossible to determine the original input,

136
00:07:52.790 --> 00:07:54.080
but it should be really,
really hard.

137
00:07:55.100 --> 00:07:59.180
Small changes to the input should make huge changes to the Hash,
right?

138
00:07:59.181 --> 00:07:59.961
So if I change this,

139
00:07:59.961 --> 00:08:04.880
a single letter in a 25 character input is there should be huge changes in what

140
00:08:04.881 --> 00:08:08.840
that hash would be if we were to hash that.
It's gotta be collision resistant.

141
00:08:08.841 --> 00:08:11.660
We've already talked about that.
And lastly,
it should be puzzled.

142
00:08:11.661 --> 00:08:15.020
Friendly meaning given part of the input and the output,

143
00:08:15.021 --> 00:08:17.660
it's very difficult for us to find the rest of the input.

144
00:08:17.900 --> 00:08:19.970
And this is central to bitcoin mining,

145
00:08:19.971 --> 00:08:23.840
which is essentially a race to solve a cryptographic puzzle by essentially

146
00:08:23.841 --> 00:08:28.280
trying out many,
many solutions uniformly,
randomly.
Now,

147
00:08:28.281 --> 00:08:32.540
the last part that is a key to cryptography,
no pun intended,

148
00:08:32.780 --> 00:08:35.570
or the concept of digital signatures.
Okay.

149
00:08:35.571 --> 00:08:39.830
So imagine that a paper that I've signed with my signature,

150
00:08:40.070 --> 00:08:43.490
what should this,
what should a good signature do?
That is a question,
right?

151
00:08:43.670 --> 00:08:46.220
So a good signature should provide verification,

152
00:08:46.400 --> 00:08:49.520
meaning that someone should be able to verify that it was me who signed it,

153
00:08:49.521 --> 00:08:51.200
right?
My handwritten signature.

154
00:08:51.530 --> 00:08:54.980
It should be non forageable meaning no one else should be able to forge my

155
00:08:54.990 --> 00:08:57.480
signature.
It should have non repudiation.

156
00:08:57.720 --> 00:08:59.730
Meaning if I've signed something with my signature,

157
00:08:59.970 --> 00:09:03.660
I shouldn't be able to take it back or claim that someone else did it right?

158
00:09:03.661 --> 00:09:06.720
So in the real world,
no matter how good my signature is,

159
00:09:06.721 --> 00:09:10.410
no matter how unique it is going to be easily forageable by somebody,
right?

160
00:09:10.680 --> 00:09:14.520
But cryptography gives us a solution by means of what's called a digital

161
00:09:14.521 --> 00:09:17.700
signature,
which is done via the use of keys,
right?

162
00:09:17.770 --> 00:09:21.420
And generating and verifying digital signatures involves encrypting a message

163
00:09:21.421 --> 00:09:25.620
digest with a private key to create the electronic equivalent of a handwritten

164
00:09:25.621 --> 00:09:28.770
signature.
Both a handwritten signature and a digital signature.

165
00:09:28.860 --> 00:09:31.800
Verify the identity of the signer and cannot be forged.

166
00:09:31.980 --> 00:09:35.460
And they serve to ensure that nothing has altered the signed document since it

167
00:09:35.461 --> 00:09:39.390
was signed.
So I've got this uh,
diagram here of using digital signatures.

168
00:09:39.570 --> 00:09:42.810
I've got a signer and my data,
I'll encrypt it using my private key,

169
00:09:42.811 --> 00:09:45.360
and that's going to create a digitally signed document.

170
00:09:45.900 --> 00:09:49.770
We put that through a hash algorithm and use the decryption public key to then

171
00:09:49.771 --> 00:09:53.280
match if the signature is valid,
if two of the hash values have matched,

172
00:09:53.490 --> 00:09:57.330
and then the receiver can then read that document and then know that it was me

173
00:09:57.390 --> 00:10:01.500
who was the originator of that document.
Here's another diagram.

174
00:10:01.501 --> 00:10:04.740
So we have a sender and we have a receiver,
right?
So I've got some message,

175
00:10:04.770 --> 00:10:07.010
let's say it's Crypto,
compare.com and some strength.

176
00:10:07.470 --> 00:10:11.970
I can use a public private key pair to then input to assigning how rhythm and

177
00:10:11.971 --> 00:10:15.300
that's going to output a public key,
my signature and the original message.

178
00:10:15.570 --> 00:10:19.860
The receiver can use that public key to verify that it was indeed me who signed

179
00:10:19.861 --> 00:10:23.310
that message and read that message.
So it's proof of ownership.

180
00:10:23.430 --> 00:10:27.240
Digital signatures are great for proof of ownership and they're used in bitcoin

181
00:10:27.241 --> 00:10:30.270
for that exact purpose.
Okay.
So,
uh,

182
00:10:30.660 --> 00:10:33.720
now what are some examples of cryptography?
Right?
Like I said,

183
00:10:33.721 --> 00:10:37.740
they're used everywhere and in day to day life they're using smart cards and

184
00:10:37.860 --> 00:10:38.760
electronic commerce,

185
00:10:38.761 --> 00:10:43.260
any sort of online banking or anytime you need to make a payment online,

186
00:10:43.560 --> 00:10:47.100
computer,
passwords,
ATM,
anything that is critical.

187
00:10:47.101 --> 00:10:48.690
Anything that is very important.

188
00:10:48.900 --> 00:10:53.670
We want to use cryptography as a way to ensure that that data cannot be,

189
00:10:53.940 --> 00:10:58.680
uh,
forged or stolen by an unauthorized third party.
Okay.

190
00:10:58.681 --> 00:11:03.681
So cryptography keeps data confidential and helps verify data integrity.

191
00:11:03.930 --> 00:11:07.800
So one great example for this is http.
S right?

192
00:11:07.801 --> 00:11:11.880
So HDP is the protocol for the Web,
right?
You know this probably,

193
00:11:11.881 --> 00:11:16.530
but it's how we communicate on the Internet.
It's fundamental.
It's stateless.

194
00:11:16.710 --> 00:11:20.250
And since the server forgets the client,
once the transaction is over,

195
00:11:20.490 --> 00:11:24.030
most of our day to day transactions are done online these days.
Bill payments,

196
00:11:24.150 --> 00:11:25.860
online shopping,
right?
So it's,

197
00:11:25.890 --> 00:11:29.730
it's absolutely necessary that the communication between the server and the

198
00:11:29.731 --> 00:11:34.170
client is secure.
So https was invented to help with this.

199
00:11:34.380 --> 00:11:39.000
It is http.
But running on top of SSL.
I know acronym hell right now,

200
00:11:39.001 --> 00:11:44.001
but SSL stands for secure sockets layer and that's what htps runs on as I sell

201
00:11:45.050 --> 00:11:48.480
insurance,
the secure channel of communication using cryptography.

202
00:11:48.810 --> 00:11:50.280
So here's how it works.

203
00:11:51.330 --> 00:11:54.790
We have the client and the server and it's a seven step process.

204
00:11:55.030 --> 00:11:59.290
So we have an initial hello message that and we agree on encryption algorithms

205
00:11:59.291 --> 00:12:02.440
and key sizes.
The client requests a public key.

206
00:12:02.680 --> 00:12:07.270
The server sends a digital certificate,
the client encrypt or random number,
uh,

207
00:12:07.271 --> 00:12:10.240
with the public he extracted from the digital signature.

208
00:12:10.570 --> 00:12:13.900
Both sides generates symmetric keys based on that random number.

209
00:12:14.230 --> 00:12:16.550
The server proves the identity by replying with,

210
00:12:16.570 --> 00:12:18.490
with a finished handshake message.

211
00:12:18.730 --> 00:12:22.480
And both sides encrypt data in both directions using their symmetric key.

212
00:12:22.660 --> 00:12:24.610
So it's a seven step process,
right?

213
00:12:24.611 --> 00:12:28.150
You know about the digital certificate and that lock sign in your web browser,

214
00:12:28.240 --> 00:12:33.070
that is https and it uses cryptography to secure the data between both the

215
00:12:33.071 --> 00:12:37.690
client and the server.
What's another example of cryptography?
WHATSAPP,
right?

216
00:12:38.350 --> 00:12:39.670
So whatsapp is one of his,

217
00:12:39.680 --> 00:12:43.030
is the most popular mobile messaging software in the world right now.

218
00:12:43.240 --> 00:12:47.260
And conversations are are end to end encrypted.
What do I mean?

219
00:12:47.261 --> 00:12:50.370
What that means is only the data is encrypted.
The headers,

220
00:12:50.380 --> 00:12:53.890
the trailers and the routing information are not encrypted and it makes sure

221
00:12:53.891 --> 00:12:58.420
that a message that is sent is received only by the intended recipient and no

222
00:12:58.421 --> 00:13:01.780
one else.
WHATSAPP has ensured that even it as a server,

223
00:13:01.781 --> 00:13:06.190
as a third party cannot read the messages bolstering a very strong messaging

224
00:13:06.191 --> 00:13:08.440
platform.
So on the client side,

225
00:13:08.441 --> 00:13:10.720
the user is encrypting their message using a public key,

226
00:13:10.840 --> 00:13:12.250
sends it off to the server,

227
00:13:12.280 --> 00:13:16.780
the server cannot read that message and the message then goes to the client B or

228
00:13:16.781 --> 00:13:19.270
user B.
And then using a private key,

229
00:13:19.271 --> 00:13:22.780
they can then decrypt that message client side and read it and the server could

230
00:13:22.781 --> 00:13:25.720
not read what was happening between those two parties.

231
00:13:26.380 --> 00:13:30.400
Now artificial intelligence,
so I know some of you might be thinking,

232
00:13:30.401 --> 00:13:33.820
why are you talking about cryptography so much?
It's,
it's not related to Ai.

233
00:13:33.860 --> 00:13:37.660
While I'm here to tell you that it is very,
very much related to Ai.

234
00:13:37.690 --> 00:13:41.770
And now here's,
here's one example.
Open mind.
Open mind is a community.

235
00:13:41.771 --> 00:13:46.771
It's an online community that has a single mission and that mission is to

236
00:13:46.841 --> 00:13:49.790
democratize data.
They want to democratize data and what,
what,

237
00:13:49.800 --> 00:13:53.200
what it means specifically is they want to make deep learning technology

238
00:13:53.201 --> 00:13:57.700
accessible to consumers who supply the data and machine learning practitioners

239
00:13:57.760 --> 00:13:59.950
who train models on that data.
Okay.

240
00:13:59.951 --> 00:14:03.610
So basically if I had got some data right on my computer locally,

241
00:14:03.850 --> 00:14:06.700
and you're a machine learning practitioner and you want to train your model on

242
00:14:06.701 --> 00:14:07.480
that data,

243
00:14:07.480 --> 00:14:12.040
how do I give you access to my data without you knowing exactly what data is in

244
00:14:12.041 --> 00:14:12.874
there?
Right?

245
00:14:12.880 --> 00:14:17.710
How do I let you train your AI on my personal data without you as a person

246
00:14:17.711 --> 00:14:20.050
knowing what my data is about?
Right?

247
00:14:20.051 --> 00:14:24.490
So all of this is using encryption all over the place,
right?

248
00:14:24.700 --> 00:14:28.240
How do we do this in a decentralized way without using a third party server?

249
00:14:28.241 --> 00:14:32.920
Right?
How do you train an AI on data that you don't know what is,
uh,

250
00:14:32.950 --> 00:14:36.700
the details of it,
right?
So like,
let's say for example,
hospital records,

251
00:14:36.970 --> 00:14:41.560
I want to train my AI model on some really sensitive patient data.

252
00:14:41.800 --> 00:14:45.580
But knowing the patient's name and all their details,
that's,

253
00:14:45.610 --> 00:14:47.740
that should be private,
right?
They don't want to give that away.

254
00:14:47.920 --> 00:14:52.920
However they want to let me train my AI on data so that I can then solve some

255
00:14:53.540 --> 00:14:57.590
disease in the future.
Right?
So this would be a perfect use case for open mind,

256
00:14:57.620 --> 00:15:02.510
which heavily uses encryption.
Now another use case,
and this is the future of Ai,

257
00:15:02.511 --> 00:15:06.890
which is where we're going,
is the idea of distributed autonomous organizations.

258
00:15:07.130 --> 00:15:12.130
So recall that corporations are actually a rough initial form of artificial

259
00:15:14.140 --> 00:15:18.200
intelligences,
right?
Corporations are,
consists of humans right there,

260
00:15:18.230 --> 00:15:21.830
they consist of humans,
but really a corporation is,
is,

261
00:15:21.831 --> 00:15:24.610
is an entity in and of itself,
but they're there.

262
00:15:24.611 --> 00:15:27.110
They're the second stage and getting to real AI.

263
00:15:27.230 --> 00:15:32.030
So what I mean is corporations are humans at the center and humans at the edges.

264
00:15:32.090 --> 00:15:36.320
While we're moving to where we will actually,
where we are right now is having,

265
00:15:36.890 --> 00:15:41.060
is having humans at the center and AI at the edges,
right?
So Uber for example,

266
00:15:41.061 --> 00:15:44.150
once they have this self driving car network is going to be humans at the
center.

267
00:15:44.270 --> 00:15:47.990
And Ai at the edges.
So the cars are going to be,
uh,
Ais,
right?

268
00:15:47.990 --> 00:15:50.030
So that's the second step.

269
00:15:50.210 --> 00:15:53.960
Eventually we'll have AI at the center and humans at the edges.

270
00:15:54.020 --> 00:15:58.820
So the AI is making the decisions,
the main decisions and humans are going to be,

271
00:15:58.990 --> 00:16:03.080
uh,
completing tasks that the AI needs.
But eventually,

272
00:16:03.081 --> 00:16:07.430
eventually we'll have AI at the center and AI at the edges.

273
00:16:07.490 --> 00:16:11.450
So that's a completely autonomous system that doesn't need humans at all.

274
00:16:11.600 --> 00:16:14.960
That can flourish,
that can learn for itself,
that can get the data it needs,

275
00:16:15.110 --> 00:16:16.490
it can pay for what it needs.

276
00:16:16.730 --> 00:16:21.200
All of this requires encryption end to end encryption in order to make sure that

277
00:16:21.201 --> 00:16:25.190
it's a system that can be trustable,
that we can trust this system,
right?

278
00:16:25.400 --> 00:16:27.950
It doesn't become something bad that we don't know what it's doing.

279
00:16:28.100 --> 00:16:30.020
It needs to be able to prove what it's doing.
Right?

280
00:16:30.270 --> 00:16:35.120
Approvable trustful system that is verifiable by third parties,
humans,

281
00:16:35.300 --> 00:16:38.570
the in that,
the work that it's doing is valid.
So all over the place,
right?

282
00:16:38.780 --> 00:16:40.250
We can have ais at the edges,

283
00:16:40.370 --> 00:16:43.520
we can have ais at the centers and we can have swarms of Ais,
right?

284
00:16:43.521 --> 00:16:47.750
These are all simple AI agents that together make up this higher level

285
00:16:47.751 --> 00:16:50.570
complexity and encryption is kind of like the glue.

286
00:16:50.571 --> 00:16:54.140
It's kind of like the tape that makes sure all the systems are able to work

287
00:16:54.141 --> 00:16:57.950
together seamlessly.
Encryption and cryptography,
all of this is important stuff,

288
00:16:58.160 --> 00:17:02.540
but you might be wondering what math do I need to know in order to do this?
Well,

289
00:17:02.660 --> 00:17:04.670
for cryptography in general,

290
00:17:04.671 --> 00:17:08.270
there are four topics that are supremely important to know.
Well,

291
00:17:08.540 --> 00:17:12.410
the first is mathematic notation.
The second is abstract Algebra,

292
00:17:12.470 --> 00:17:15.590
the third is discrete math,
and the fourth is calculus.

293
00:17:15.710 --> 00:17:19.880
Now if you want a refresher on all of these,
I highly recommend Khan Academy.

294
00:17:19.881 --> 00:17:23.690
That is the,
that is the best source I think out there for learning.

295
00:17:23.840 --> 00:17:28.640
Just basic math and also a brilliant.org brilliant.org check it out.

296
00:17:28.760 --> 00:17:31.850
Some great interactive games to learn math.
Okay,

297
00:17:31.851 --> 00:17:33.920
so that's a primer on cryptography.

298
00:17:34.100 --> 00:17:38.420
Now let's get into a type of cryptography called zero knowledge proofs.

299
00:17:38.540 --> 00:17:40.820
I mean there's so many directions we can take this.

300
00:17:40.821 --> 00:17:44.330
I mean we could just go in depth on a single topic like forever,

301
00:17:44.510 --> 00:17:47.740
but I'm just going at a high level right now because I want to get to Zika

302
00:17:47.810 --> 00:17:52.140
snarks at the end.
Okay,
so now I want to talk about zero knowledge proofs.

303
00:17:52.620 --> 00:17:56.680
Zero knowledge proofs are a type of cryptography that our supreme,
we useful,
uh,

304
00:17:56.880 --> 00:17:58.980
in both blockchain technology and an AI.

305
00:17:59.040 --> 00:18:04.040
So the idea is that how can I prove that I know something without having to tell

306
00:18:05.281 --> 00:18:09.390
you what it is that I know?
That's the idea behind zero knowledge proofs.

307
00:18:09.630 --> 00:18:11.490
How do I prove that I know something?

308
00:18:11.520 --> 00:18:15.240
It could be anything without having to reveal what it is that I know.

309
00:18:15.390 --> 00:18:17.790
Here's some examples.
Treasure hunts,
PR.

310
00:18:17.880 --> 00:18:21.930
How do I prove that I know the location of a hidden object without revealing

311
00:18:21.931 --> 00:18:24.570
what it's location,
it's and Sudoku.

312
00:18:24.630 --> 00:18:28.020
How do I prove that I know the solution to the puzzle without revealing what

313
00:18:28.021 --> 00:18:31.050
that solution is?
Sealed bid auctions.

314
00:18:31.170 --> 00:18:34.290
How do I prove who won without revealing any bid?

315
00:18:34.350 --> 00:18:36.780
Are you beginning to see the idea here is zero knowledge proofs,

316
00:18:36.990 --> 00:18:37.920
account balances.

317
00:18:38.070 --> 00:18:42.600
How do I prove that my account has enough without revealing what that amount is?

318
00:18:42.810 --> 00:18:46.650
Zero knowledge proofs are super useful for all of these use cases.

319
00:18:46.860 --> 00:18:50.460
So the idea came in the 1980s to a group of MIT researchers.

320
00:18:50.700 --> 00:18:55.350
Zero knowledge states that approver can prove to the verifier that they possess

321
00:18:55.380 --> 00:18:59.250
certain knowledge without telling them what that knowledge actually is.

322
00:18:59.390 --> 00:19:03.750
A zero knowledge proof has three properties,
completeness,
soundness,

323
00:19:03.810 --> 00:19:05.730
and zero knowledge for completeness.

324
00:19:05.850 --> 00:19:09.690
If the statement is true than an honest verifier can be convinced of it by an

325
00:19:09.720 --> 00:19:13.170
honest prover soundness.
If the prover is dishonest,

326
00:19:13.290 --> 00:19:17.520
they can't convince the verifier of the soundness of the statement by line and

327
00:19:17.550 --> 00:19:19.500
zero knowledge.
If the statement is true,

328
00:19:19.710 --> 00:19:23.310
the verifier will have no idea what the statement actually is.

329
00:19:23.520 --> 00:19:25.290
So let's go into two examples here.

330
00:19:25.590 --> 00:19:30.330
The first case is this scenario called Alibaba's cave,
right?

331
00:19:30.331 --> 00:19:31.500
So in this example,

332
00:19:31.501 --> 00:19:35.550
the prover p is saying to the Verifier v that they know the password of the

333
00:19:35.551 --> 00:19:39.300
secret door at the back of the cave and they want to prove it to the verifier

334
00:19:39.301 --> 00:19:42.870
without actually telling them the password to the prover goes down any of the

335
00:19:42.871 --> 00:19:46.890
paths a and B.
And suppose they initially decided to go down the path a,

336
00:19:46.891 --> 00:19:48.030
there are two paths here.

337
00:19:48.660 --> 00:19:52.380
When they do so the verifier comes in at the entrance with no knowledge of which

338
00:19:52.381 --> 00:19:55.920
path the prover actually took and declares that they want to see that the prover

339
00:19:55.921 --> 00:20:00.060
appears on path B.
The prover does indeed appear in path B.

340
00:20:00.061 --> 00:20:03.040
But what if it was dumb luck?
What if it's not that they knew it?

341
00:20:03.050 --> 00:20:06.600
What was path B they had to take?
What if they just guessed?
How do we prove that?

342
00:20:06.601 --> 00:20:09.240
Right?
So to test the validity,

343
00:20:09.330 --> 00:20:11.610
we just do that experiment multiple times.

344
00:20:11.820 --> 00:20:15.630
If the approver can appear at the correct path every single time,

345
00:20:15.900 --> 00:20:19.830
it proves to the verifier that indeed the prover knows the password,

346
00:20:20.010 --> 00:20:23.670
even though the verifier doesn't know what that password actually is.

347
00:20:24.120 --> 00:20:27.060
And so this,
this satisfied the zero knowledge properties,
right?

348
00:20:27.210 --> 00:20:30.090
It's completeness.
Because since the statement was true,

349
00:20:30.270 --> 00:20:34.320
the honest prover convinced the honest verifier,
it satisfies soundness.

350
00:20:34.350 --> 00:20:35.910
If the prover was dishonest,

351
00:20:36.180 --> 00:20:40.140
they couldn't have fooled the verifier because the test was done multiple times

352
00:20:40.470 --> 00:20:44.820
and zero knowledge.
The pro,
the verifier never knew what the password was,

353
00:20:44.940 --> 00:20:48.070
but was convinced that the prover had the possession of it.

354
00:20:48.220 --> 00:20:51.010
One more case finding Waldo.
So who played a where's Waldo?

355
00:20:51.010 --> 00:20:52.630
Cause I used to play that right?

356
00:20:52.810 --> 00:20:56.380
Remember that book shout out to the 90s all those kids out there.

357
00:20:56.710 --> 00:21:00.730
So finding Waldo is this game where you have to find this Guy Waldo in a sea of

358
00:21:00.731 --> 00:21:01.180
people.

359
00:21:01.180 --> 00:21:06.040
So imagine you and me are playing where's Waldo and I solve this puzzle before

360
00:21:06.041 --> 00:21:10.330
you and I want to prove to you that I've solved that puzzle without giving any

361
00:21:10.331 --> 00:21:13.930
hints as to where,
where Waldo is,
right?
Like I could tell you,
hey,

362
00:21:13.931 --> 00:21:16.850
I found Waldo and you might say,
well where is he?
And I want to,

363
00:21:16.930 --> 00:21:20.410
I just want to prove to you that I found him without telling you where he is.

364
00:21:20.411 --> 00:21:22.720
Cause I want you to solve it to,
how do I do that?

365
00:21:22.960 --> 00:21:26.920
So one way to do this is to take a sheet of paper with identical dimensions to

366
00:21:26.921 --> 00:21:31.450
the picture and mark the spot on it in the exact position where Waldo is.

367
00:21:31.540 --> 00:21:35.110
And then I fold a sheet of paper into some kind of origami or something and give

368
00:21:35.111 --> 00:21:38.860
it to you.
So once you solve that puzzle,
you can open up that folding,

369
00:21:38.861 --> 00:21:42.640
put it back on top of Waldo,
like an overlay,
and then see,
oh,

370
00:21:42.641 --> 00:21:44.830
that point is exactly where Waldo was.

371
00:21:45.220 --> 00:21:47.800
And that's a way of having a zero knowledge proof.

372
00:21:47.950 --> 00:21:50.290
Just to give you some concrete examples of what I mean,
right?

373
00:21:50.291 --> 00:21:53.020
To really drive this point home.
Okay.

374
00:21:53.021 --> 00:21:57.940
So there are two types of zero knowledge proofs.
The first is proof of statement,

375
00:21:58.180 --> 00:22:00.220
and the second is proof of knowledge.

376
00:22:00.370 --> 00:22:04.990
So proof of statement means that this is some intrinsic truth about the

377
00:22:04.991 --> 00:22:07.390
universe,
like the number x belong to the group.

378
00:22:07.391 --> 00:22:11.980
Why or this star is brighter than the other stars?
Proof of knowledges.

379
00:22:12.130 --> 00:22:15.010
I want to prove that I have knowledge of a particular idea.

380
00:22:15.160 --> 00:22:19.140
Without revealing what that knowledge is that's as can be seen in those two

381
00:22:19.240 --> 00:22:24.040
examples I just gave.
Cryptocurrency is mostly focused on proof of knowledge.

382
00:22:24.160 --> 00:22:26.890
Okay,
so now let's get into Z K snarks a bit.

383
00:22:26.891 --> 00:22:31.720
So this stands for zero knowledge succint non-interactive arguments of
knowledge.

384
00:22:31.810 --> 00:22:32.200
Okay.

385
00:22:32.200 --> 00:22:37.200
Zika snarks so it's used in it's use in modern blockchain technology is immense.

386
00:22:38.080 --> 00:22:39.880
And to understand its application,

387
00:22:40.030 --> 00:22:42.670
we have to understand a bit about how smart contracts work.

388
00:22:43.120 --> 00:22:47.260
Basically it's an escrow of funds which gets activated once a particular

389
00:22:47.261 --> 00:22:51.190
function is done.
So let's say I've entered into a smart contract with you,

390
00:22:51.191 --> 00:22:55.480
for example,
Ben,
um,
and I'm only going to get the payment if I do a,
B,
and c a,

391
00:22:55.481 --> 00:22:59.320
B and c are tasks.
What if I don't want to reveal the details of what a,

392
00:22:59.321 --> 00:23:03.610
B and c are because they are confidential to my company and I don't want any

393
00:23:03.611 --> 00:23:05.440
competitors to know what I have to do.

394
00:23:05.820 --> 00:23:10.120
What Z K snarks does is it proves that those steps have been taken into smart

395
00:23:10.121 --> 00:23:13.570
contract without revealing what those steps actually are.

396
00:23:13.780 --> 00:23:16.510
And this is very useful in protecting privacy.

397
00:23:17.230 --> 00:23:20.920
It can just reveal part of the process without showing the whole process itself

398
00:23:21.070 --> 00:23:25.480
and prove that I'm being honest with my claims.
So how does this work?

399
00:23:25.720 --> 00:23:30.060
So it consists of three algorithms,
g,
P and V gs.

400
00:23:30.070 --> 00:23:33.190
The key generator,
p is the prover and v is the verifier.

401
00:23:33.520 --> 00:23:36.520
G is going to take an input lambda and this is a,

402
00:23:36.640 --> 00:23:38.500
this should be kept confidential,
right?

403
00:23:38.710 --> 00:23:42.730
It shouldn't be revealed under any circumstances and a program see it then

404
00:23:42.731 --> 00:23:45.680
proceeds to generate to publicly available keys,

405
00:23:45.900 --> 00:23:49.490
a proven key PK and a verification key VK.

406
00:23:49.790 --> 00:23:50.930
These keys are both public.

407
00:23:50.931 --> 00:23:54.050
Anybody can look at them and available to any concerned parties.

408
00:23:54.260 --> 00:23:58.070
Lambda is that part that has to be kept secret.
So P is approver.

409
00:23:58.100 --> 00:24:01.280
Who's going to use those three items as input,
the proving key,

410
00:24:01.460 --> 00:24:02.600
the random input x,

411
00:24:02.601 --> 00:24:06.200
which is publicly available and a private statement that they want to prove the

412
00:24:06.201 --> 00:24:08.630
knowledge of without revealing what it actually is,

413
00:24:09.140 --> 00:24:11.360
which is we're going to call that private statement w.

414
00:24:11.660 --> 00:24:16.660
So p is going to generate a proof such had the proof equals p of the private

415
00:24:16.941 --> 00:24:18.710
key,
a random input x.

416
00:24:18.800 --> 00:24:21.950
And then the private statement that we want to keep private w that's our,

417
00:24:21.951 --> 00:24:25.340
that's really what we want to use.
Everything for.
How do we encrypt this thing?

418
00:24:25.341 --> 00:24:30.140
Right?
So the verifier Algorithm v has basically returned a boolean value.

419
00:24:30.440 --> 00:24:35.180
The boolean variable only has two choices.
It can be true or it can be false.

420
00:24:35.390 --> 00:24:40.390
So the verifier takes into verifying key public input x and proof PRF as inputs

421
00:24:40.971 --> 00:24:41.804
such as the,

422
00:24:42.020 --> 00:24:47.020
the of fee k x PRF and returns true if the prover is correct and false.

423
00:24:47.960 --> 00:24:50.870
Otherwise the value of lambda must be kept confidential.

424
00:24:50.871 --> 00:24:53.540
We've talked about this and here's what an example looks like.

425
00:24:53.780 --> 00:24:58.010
A function c with parameters x NW returns the Sha two five,

426
00:24:58.011 --> 00:25:02.720
six of the original,
you know,
private statement equal,
equal,
equal x.

427
00:25:03.030 --> 00:25:03.291
All right?

428
00:25:03.291 --> 00:25:07.400
It takes two volumes as input a public hash value x and the secret statement

429
00:25:07.401 --> 00:25:08.330
that needs to be verified.

430
00:25:08.331 --> 00:25:12.500
W if the Sha two five six hash value of w equals x,

431
00:25:12.710 --> 00:25:17.270
then the function returns true.
Otherwise it returns false.
Okay?

432
00:25:18.020 --> 00:25:20.670
Now,
uh,
the proving Algorithm we talked about,

433
00:25:20.671 --> 00:25:24.110
it looks like this proof equals p of PK XW.

434
00:25:24.440 --> 00:25:27.230
And now that someone has generated the proof PRF,

435
00:25:27.380 --> 00:25:30.950
they're going to give that value to the second person who's going to finally run

436
00:25:30.951 --> 00:25:34.160
the verification algorithm of Zika snarks,
which is this,

437
00:25:34.190 --> 00:25:37.670
the of the k x Prf here.

438
00:25:37.730 --> 00:25:42.230
Vk is a verifying key and x is the known hash value and Prf is the proof that

439
00:25:42.350 --> 00:25:45.740
they've gotten from the first person.
If the algorithm returns true,

440
00:25:45.770 --> 00:25:49.750
that means the first person was honest and they did indeed have the secret
value.

441
00:25:49.751 --> 00:25:51.260
W if it returns false,

442
00:25:51.440 --> 00:25:54.740
it means that that person was lying about knowing what w is.
So lastly,

443
00:25:54.741 --> 00:25:58.100
I want to go over this code for this repository called crypt pad that I found is

444
00:25:58.101 --> 00:25:59.450
a really cool repository.

445
00:25:59.870 --> 00:26:04.190
Basically it's a zero knowledge real time collaborative editor and there's a lot

446
00:26:04.191 --> 00:26:06.680
of code involved,
but it's really easy to install.

447
00:26:06.681 --> 00:26:10.130
Like it's like just three lines that I just,
you know,
Bauer install,
npm install,

448
00:26:10.131 --> 00:26:12.920
and then node app dot js and it's running on local host.

449
00:26:14.060 --> 00:26:17.420
But there were some parts of this that I wanted to talk about really quickly.

450
00:26:17.421 --> 00:26:20.960
So one part is the,
uh,
common hash.

451
00:26:21.470 --> 00:26:23.360
So if we opened that,

452
00:26:36.890 --> 00:26:38.870
this is where the hashing is happening here,
right?

453
00:26:38.990 --> 00:26:43.770
So they're using different hashing algorithms here to get the keys from the

454
00:26:43.771 --> 00:26:44.604
server.
Right?

455
00:26:44.670 --> 00:26:49.440
But the idea is that only the clients that have that key can decrypt the

456
00:26:49.441 --> 00:26:52.320
messages.
So if there's a server that is why that is hosted on,

457
00:26:52.590 --> 00:26:57.090
then the people who control that server can't see what the data is that these

458
00:26:57.091 --> 00:27:00.360
people are collaborating on in real time.
Okay.

459
00:27:00.480 --> 00:27:03.690
And they're using javascript to do this with the common hash function.

460
00:27:04.970 --> 00:27:07.410
I mean there's a lot of code here,
but uh,

461
00:27:07.590 --> 00:27:11.370
I think in main dot js we can see the high level of what's going on here.

462
00:27:11.371 --> 00:27:13.640
If we go to examples,
right,

463
00:27:13.680 --> 00:27:18.680
where we go into examples and then pin and then main dot js.

464
00:27:20.940 --> 00:27:25.320
So this is,
this is what's happening on,
on APP start,
right?

465
00:27:25.321 --> 00:27:29.490
So we synchronize the channels,
right?
So we get the Hash Channel List,

466
00:27:29.700 --> 00:27:30.900
we get the file size,

467
00:27:30.901 --> 00:27:35.610
we get to server hash and then once that's ready we get the network,

468
00:27:35.611 --> 00:27:40.470
the store and then we create a pin path of a pin pad by synchronizing the Hashes

469
00:27:40.530 --> 00:27:44.700
from all of these different clients and all of its being encrypted and decrypted

470
00:27:44.701 --> 00:27:45.534
client's side.

471
00:27:45.600 --> 00:27:49.170
So the server never has any knowledge of what these people are talking about in

472
00:27:49.171 --> 00:27:51.360
real time.
So Google docs for example,

473
00:27:51.450 --> 00:27:53.580
Google knows what you're typing in real time,

474
00:27:53.790 --> 00:27:57.090
but if there was a zero knowledge proof involve like Zika snarks are,
you know,

475
00:27:57.091 --> 00:28:00.690
et Cetera,
then they could not know what you guys are collaborating on.

476
00:28:00.870 --> 00:28:03.630
So it's really useful to keep your data private,

477
00:28:03.750 --> 00:28:08.750
to keep it anonymous and to create systems that are trust less or you could say

478
00:28:09.151 --> 00:28:10.680
more trustful in a way.

479
00:28:11.310 --> 00:28:14.790
But z cash is a great example that uses Zika snarks.

480
00:28:15.000 --> 00:28:18.780
It aims to provide completely safe and shielded transaction spaces for its users

481
00:28:18.960 --> 00:28:23.130
without revealing their details and etherium as well once to integrate Zika

482
00:28:23.131 --> 00:28:26.010
snarks as it enters its next phase of development.

483
00:28:26.040 --> 00:28:28.620
Please subscribe for more programming videos.
And for now,

484
00:28:28.680 --> 00:28:31.530
I'm going to research some crypto map,
so thanks for watching.

