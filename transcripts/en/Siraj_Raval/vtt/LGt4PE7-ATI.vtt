WEBVTT

1
00:00:00.180 --> 00:00:03.240
Discrete math will help us build tronc

2
00:00:04.980 --> 00:00:08.340
hello world.
It's Suraj and if you're interested in coding,

3
00:00:08.341 --> 00:00:12.750
not just machine learning but any kind of coding you need to understand discreet

4
00:00:12.780 --> 00:00:13.620
mathematics.

5
00:00:13.650 --> 00:00:17.430
It's become a really important subject in the past few years because of how

6
00:00:17.431 --> 00:00:20.130
useful it is in computer science.
In fact,

7
00:00:20.131 --> 00:00:24.570
pretty much every single computer science degree program contains at least one

8
00:00:24.571 --> 00:00:29.310
course on discrete mathematics.
Sometimes too liberal arts majors.
It's okay.

9
00:00:29.430 --> 00:00:30.263
Breathe.

10
00:00:30.300 --> 00:00:34.170
I'm here now in this video I'm going to give you an overview of the foundational

11
00:00:34.171 --> 00:00:38.190
topics in discrete math to help you understand how it all works.

12
00:00:38.430 --> 00:00:42.180
We'll learn about each of them by necessity since we'll play the role of a cyber

13
00:00:42.181 --> 00:00:44.910
security agent working for mic six.

14
00:00:45.150 --> 00:00:49.620
Our task is to crack a password protected database of international criminals

15
00:00:49.710 --> 00:00:51.480
that stored on a USB drive.

16
00:00:51.540 --> 00:00:55.050
Discrete math isn't actually the name of a traditional branch of mathematics

17
00:00:55.051 --> 00:00:57.360
like calculus or linear Algebra is.

18
00:00:57.600 --> 00:01:02.100
It's instead a description of a set of branches of math that all have in common.

19
00:01:02.101 --> 00:01:05.610
One feature,
they're discreet rather than continuous.

20
00:01:05.910 --> 00:01:08.730
Discrete stands for individually separate and distinct.

21
00:01:08.731 --> 00:01:13.020
While continuous stands for forming an unbroken whole without interruption.

22
00:01:13.050 --> 00:01:17.730
Discrete math deals in objects in discrete bundles like one or two Kendrick

23
00:01:17.730 --> 00:01:22.050
Lamar album's at least three if you're a real fan,
especially down in contrast,

24
00:01:22.051 --> 00:01:26.850
continuous math deals with objects that very continuously like 3.4 centimeters

25
00:01:26.851 --> 00:01:31.380
from a wall.
A good analogy would be digital watches versus analog watches.

26
00:01:31.381 --> 00:01:35.010
The ones where the second hand loops around continuously without stopping.

27
00:01:35.460 --> 00:01:39.330
Basically discreet data is able to take on only integer values,

28
00:01:39.331 --> 00:01:41.820
but continuous data can take on any value.

29
00:01:42.150 --> 00:01:46.710
Discrete math was created several decades ago as the mathematical language of

30
00:01:46.711 --> 00:01:51.450
computer science colleges learned that traditional math subjects did not cover

31
00:01:51.540 --> 00:01:54.180
the type of math needed by computer scientists,

32
00:01:54.300 --> 00:01:59.160
so they put a bunch of math topics together and called it discrete math is
creep.

33
00:01:59.160 --> 00:02:02.880
Math helps us design high speed networks and message routing paths,

34
00:02:03.030 --> 00:02:04.290
perform web searches,

35
00:02:04.440 --> 00:02:09.240
analyze algorithms for efficiency and design cryptographic protocols that can do

36
00:02:09.241 --> 00:02:11.940
things like automatically block any image of will.

37
00:02:11.941 --> 00:02:16.941
Smith has a genie beyond cringy before we can start cracking the password to get

38
00:02:16.981 --> 00:02:18.630
the data on the USB drive.

39
00:02:18.780 --> 00:02:22.770
We've got to get to the lab and there are a lot of different paths we can take

40
00:02:22.771 --> 00:02:24.870
to drive there,
but we're on a deadline,

41
00:02:24.871 --> 00:02:27.420
so we want to get to the lab as fast as possible.

42
00:02:27.421 --> 00:02:30.780
Meaning we want to take the shortest path to compute.

43
00:02:30.781 --> 00:02:35.040
This will need to represent the collection of streets and intersections as a

44
00:02:35.041 --> 00:02:39.480
graph so that we can design an algorithm that will calculate the fastest way to

45
00:02:39.481 --> 00:02:43.380
get there.
Since each street is two way.
This is an undirected graph,

46
00:02:43.381 --> 00:02:47.430
so there's no distinction between the two vertices associated with each edge.

47
00:02:47.700 --> 00:02:48.750
It says graph theory,

48
00:02:48.751 --> 00:02:53.160
the study of graphs and an important part of discrete math graphs are

49
00:02:53.161 --> 00:02:57.030
mathematical structures used to model relations between objects.

50
00:02:57.180 --> 00:02:59.920
In our case intersections in graph theory.

51
00:02:59.921 --> 00:03:03.940
The problem with finding a path between two vertices such that the sum of the

52
00:03:03.941 --> 00:03:07.750
weights of its constituent edges is minimized,
would be ideal.

53
00:03:07.930 --> 00:03:11.320
The weights in our case would be the time it takes to drive from one bird techs

54
00:03:11.321 --> 00:03:12.154
to the other.

55
00:03:12.280 --> 00:03:17.020
Here we can use one of the most famous algorithms in computer science dieters,

56
00:03:17.050 --> 00:03:20.320
shortest path Algorithm,
which is a five step procedure.

57
00:03:20.500 --> 00:03:24.610
Luckily we're not in la.
Even Dykstra is no match for its traffic.

58
00:03:24.850 --> 00:03:26.950
We start by marking our initial node,

59
00:03:26.951 --> 00:03:30.730
which is our current location with the current distance of zero and the rest

60
00:03:30.731 --> 00:03:31.564
with infinity.

61
00:03:31.750 --> 00:03:35.770
Then we set the non visited node with the smallest current distance as the

62
00:03:35.771 --> 00:03:38.560
current node for each neighbor of our current node.

63
00:03:38.560 --> 00:03:42.730
We add the current distance of the current node with the weight of the edge

64
00:03:42.731 --> 00:03:46.480
connecting it to the neighbor.
If it's smaller than the current distance of n,

65
00:03:46.600 --> 00:03:48.640
we set it as a new current distance event.

66
00:03:48.880 --> 00:03:53.050
We then mark the current node has visited and if there are any non visited nodes

67
00:03:53.051 --> 00:03:57.970
left,
we repeat the process starting at the second step until we visited all the

68
00:03:57.971 --> 00:04:00.190
notes.
Thanks to a little python script.

69
00:04:00.191 --> 00:04:04.390
We can easily find the shortest path to the lab saving us a lot of time.

70
00:04:04.450 --> 00:04:06.040
Now that we've arrived at the lab,

71
00:04:06.041 --> 00:04:09.730
let's plug this USB into the computer to see what we've got here.

72
00:04:10.000 --> 00:04:11.740
In order to access the database,

73
00:04:11.741 --> 00:04:15.400
we need a password and we have the password here,
but it's encrypted.

74
00:04:15.670 --> 00:04:19.180
We need to figure out how to decrypt it into the actual password.

75
00:04:19.420 --> 00:04:23.410
The only thing we know is that the length of the password is six characters long

76
00:04:23.650 --> 00:04:28.360
and it can contain either numbers,
alphabetic characters or both.
No emojis.

77
00:04:28.361 --> 00:04:29.194
Thankfully.

78
00:04:29.200 --> 00:04:33.100
Our first strategy here will be to see if we can write a script that will brute

79
00:04:33.101 --> 00:04:37.750
force all possible combinations of every character a through z and one through

80
00:04:37.751 --> 00:04:41.830
nine but when we start running the script,
it starts taking quite a while.

81
00:04:41.950 --> 00:04:46.390
In the meantime,
let's try and calculate how many combinations are possible here.

82
00:04:46.810 --> 00:04:48.880
Since there are 26 letters in 10 digits,

83
00:04:49.000 --> 00:04:52.480
we have a total of 36 characters to choose from for each position.

84
00:04:52.810 --> 00:04:55.270
If we started from the left,
we can fill in the first position,

85
00:04:55.271 --> 00:04:59.680
36 possible ways for each of the 36 possibilities.
For the first character,

86
00:04:59.681 --> 00:05:02.260
there are 36 possibilities.
For the second character.

87
00:05:02.500 --> 00:05:07.060
That means our 36 squared wastes fill in the first two characters for each of

88
00:05:07.061 --> 00:05:10.180
the 36 squared ways to fill in the first two characters.

89
00:05:10.360 --> 00:05:13.540
There are an additional 36 ways to fill in the third character,

90
00:05:13.750 --> 00:05:17.350
so there are 36 cubed ways to fill in the first three characters.

91
00:05:17.620 --> 00:05:20.800
Notice the pattern here and know the number 69 is not involved here.

92
00:05:21.160 --> 00:05:25.780
The total number of possible combinations is 36 to the end where n is the length

93
00:05:25.781 --> 00:05:28.540
of the character field,
which is six in our case,

94
00:05:28.660 --> 00:05:33.250
making it over 2 billion possible combinations way too much to brute force,

95
00:05:33.370 --> 00:05:35.500
so we can go ahead and pause our script.

96
00:05:35.530 --> 00:05:37.930
This is an example of common historics torics.

97
00:05:37.931 --> 00:05:42.931
The study of counting both has a means and an end and obtaining results and it's

98
00:05:42.971 --> 00:05:44.260
a part of discrete math.

99
00:05:44.320 --> 00:05:47.890
We need to think of a smarter way to decode this password.

100
00:05:48.190 --> 00:05:52.360
What if each of the characters in the string was equivalent to a number and the

101
00:05:52.361 --> 00:05:54.970
actual password was solely numerical?

102
00:05:55.120 --> 00:05:57.950
What could the mapping from characters and numbers be here?

103
00:05:58.280 --> 00:06:00.800
Maybe if we converted each character too,

104
00:06:00.801 --> 00:06:02.960
it's numerical position in the alphabet.

105
00:06:03.230 --> 00:06:07.490
It would represent a prime number one that's x counts away from zero,

106
00:06:07.670 --> 00:06:11.180
but if we tried that out,
it doesn't work.
Never give.

107
00:06:12.050 --> 00:06:15.650
Maybe the numerical version of it correlates to some sort of sequence here.

108
00:06:15.710 --> 00:06:20.030
Notice how I'm trying to categorize these integers into different number types

109
00:06:20.180 --> 00:06:21.710
based on their relationships.

110
00:06:21.860 --> 00:06:26.060
The study of relationships between numbers is called number theory,

111
00:06:26.240 --> 00:06:30.350
a part of discrete math.
There are odd numbers and even numbers,

112
00:06:30.590 --> 00:06:33.050
square numbers,
Pythagorean triples.

113
00:06:33.170 --> 00:06:37.400
The FIBONACCI sequence number theory involves analyzing the mathematical

114
00:06:37.401 --> 00:06:39.620
relationships between numbers.

115
00:06:39.860 --> 00:06:43.640
Right now I'm trying to figure out the theory behind these numbers in
particular.

116
00:06:44.210 --> 00:06:48.320
Maybe each letter of this text can actually be replaced by a letter,

117
00:06:48.321 --> 00:06:51.320
some fixed number of positions down the alphabet.

118
00:06:51.620 --> 00:06:54.350
The question then becomes how many positions?

119
00:06:54.530 --> 00:06:58.250
Let's write out a function for this one where we can call the function inside of

120
00:06:58.251 --> 00:07:02.810
itself for each character in the string while apply a shift operation and

121
00:07:02.811 --> 00:07:07.160
recursively call our function until we're done shifting the entire phrase,

122
00:07:07.430 --> 00:07:10.730
recursion a part of discrete math is a way to solve a problem.

123
00:07:10.730 --> 00:07:15.470
Where the solution depends on solutions to smaller instances of the same
problem.

124
00:07:15.860 --> 00:07:19.310
If we Google searched the word recursion,
it recursively asks,

125
00:07:19.370 --> 00:07:20.510
did you mean recursion,

126
00:07:20.810 --> 00:07:24.530
which is a fun little Easter egg from the programmers at Google.
In fact,

127
00:07:24.560 --> 00:07:27.950
the Internet is riddled with these uh,
popular reddit threads.

128
00:07:27.980 --> 00:07:29.840
Top answer for the question,

129
00:07:29.870 --> 00:07:34.190
what is recursion is a link to that very same post.
An example of recursion,

130
00:07:34.250 --> 00:07:38.570
a recursive function is a function that calls itself until some base condition

131
00:07:38.571 --> 00:07:43.010
is true and the execution stops.
When we write out our recursive function,

132
00:07:43.070 --> 00:07:46.940
we can try out different lengths of the possible shifts until we get one that

133
00:07:46.941 --> 00:07:50.880
works and it turns out that it's three shifts.
That was the passport.

134
00:07:51.140 --> 00:07:53.000
We just needed to shift the characters.

135
00:07:53.270 --> 00:07:57.710
It turns out that this password was encrypted using what's called the Caesar

136
00:07:57.710 --> 00:08:00.050
Cipher.
One of the simplest methods of encryption.

137
00:08:00.350 --> 00:08:03.050
Each letter of a given text is replaced by a letter,

138
00:08:03.110 --> 00:08:06.560
some fixed number of positions down the alphabet.
For example,

139
00:08:06.590 --> 00:08:11.210
with the shift of one a would be replaced by B,
B would become c and so on.

140
00:08:11.510 --> 00:08:15.170
It's named after Julius Caesar who apparently use it to communicate with his

141
00:08:15.171 --> 00:08:17.420
officials is this ambition.

142
00:08:20.540 --> 00:08:23.030
We now have the database of known criminals.

143
00:08:23.060 --> 00:08:27.140
This is a SQL database and we'll want to compile a report for [inaudible].

144
00:08:27.320 --> 00:08:31.070
Now that we've cracked it and that list of top 10 most wealthy criminals by

145
00:08:31.071 --> 00:08:35.810
amount of money they donated to underground organizations.
In order to do that,

146
00:08:35.811 --> 00:08:39.710
we'll write some sequel queries which will select the top 10 highest spenders

147
00:08:39.860 --> 00:08:41.750
from a certain section of the database.

148
00:08:42.080 --> 00:08:46.460
Relational databases like sequel are based almost entirely upon set theory.

149
00:08:46.640 --> 00:08:47.990
A part of discrete math.

150
00:08:48.260 --> 00:08:52.760
A set is nothing more than an unordered collection of elements with absolutely

151
00:08:52.761 --> 00:08:53.720
no duplicates.

152
00:08:53.990 --> 00:08:58.770
Even the most SQL statements are nothing more than operations on sets.

153
00:08:58.980 --> 00:09:02.160
A SQL inner join is the intersection of two sets.
For example,

154
00:09:02.490 --> 00:09:05.970
a Venn diagram is an easy way to explain the concept of sets.

155
00:09:06.180 --> 00:09:09.870
Two different sets have distinct values and where they intersect,

156
00:09:09.930 --> 00:09:12.900
they have similar values,
unions,
this junctions,

157
00:09:12.901 --> 00:09:17.430
there are all sorts of terminologies related to sets and this is what set theory

158
00:09:17.431 --> 00:09:21.630
is all about.
We can write down the top 10 criminals.
For our report,

159
00:09:21.631 --> 00:09:23.310
but we have one more step here.

160
00:09:23.520 --> 00:09:27.570
We need to create a proof for our report to show Msx [inaudible] how we crack

161
00:09:27.571 --> 00:09:30.960
the code.
The rules of logic,
a part of discrete math,

162
00:09:31.020 --> 00:09:33.510
specify the meeting of mathematical statements.

163
00:09:33.720 --> 00:09:37.620
They help us understand and reason with statements like there exists an integer

164
00:09:37.621 --> 00:09:39.600
that is not the sum of two squares.

165
00:09:40.050 --> 00:09:44.850
It's the basis of all mathematical reasoning and has practical applications in

166
00:09:44.880 --> 00:09:46.440
all of computer science.

167
00:09:46.680 --> 00:09:50.010
One of the basic building blocks of logic are propositions.

168
00:09:50.070 --> 00:09:55.070
A declarative sentence that is either true or false but not both like DC is the

169
00:09:55.081 --> 00:09:56.580
capital of the USA is true.

170
00:09:56.581 --> 00:10:01.350
While DC is the capital of Mexico is false negations,
truth tables,

171
00:10:01.351 --> 00:10:03.120
combinations,
conjunctions.

172
00:10:03.330 --> 00:10:07.380
We can build off of the basic rules of logic to create all sorts of proofs.

173
00:10:07.590 --> 00:10:11.280
So logically speaking we can define the proof of our algorithm with the

174
00:10:11.281 --> 00:10:15.930
following equation where the decrypted version of the text is equal to each

175
00:10:15.931 --> 00:10:20.931
character shifting end degrees out of 26 possible characters and my six is going

176
00:10:21.151 --> 00:10:24.570
to be very pleased with this.
We'll probably get a double o status.

177
00:10:24.571 --> 00:10:25.920
Now licensed to code.

178
00:10:26.130 --> 00:10:29.610
So those are some of the major concepts in discrete math.

179
00:10:29.640 --> 00:10:33.930
I've listed them all in the video description as well as a free open source

180
00:10:33.931 --> 00:10:37.200
textbook.
I found on the topic of discrete math study it.

181
00:10:37.710 --> 00:10:40.830
There are three things to remember from this video.
Discrete math,

182
00:10:40.831 --> 00:10:43.350
cause they said a branches of math at all have in common.

183
00:10:43.351 --> 00:10:48.351
The feature that they are discreet rather than continuous discrete data can only

184
00:10:48.811 --> 00:10:50.190
take on integer values.

185
00:10:50.191 --> 00:10:54.660
Whereas continuous data can take on any value and discrete math topics like

186
00:10:54.661 --> 00:10:59.310
recursion,
logic and common.
A torics help define the basis of computer science.

187
00:10:59.311 --> 00:11:00.690
And what's your favorite topic in map?

188
00:11:00.700 --> 00:11:03.810
Let me know in the comment section and please subscribe for more programming

189
00:11:03.811 --> 00:11:07.950
videos.
For now.
I've got to check my logic,
so thanks for watching.

