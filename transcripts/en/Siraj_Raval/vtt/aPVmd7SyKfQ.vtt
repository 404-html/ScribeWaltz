WEBVTT

1
00:00:00.210 --> 00:00:01.710
Hello world.
It's Raj.

2
00:00:01.740 --> 00:00:05.820
And welcome to the first video in the decentralized applications course.

3
00:00:06.030 --> 00:00:10.290
This video is called web 3.0 explained pretty self explanatory title.

4
00:00:10.291 --> 00:00:15.291
But what I'm going to do is explain why we need web 3.0 how it works,

5
00:00:15.840 --> 00:00:17.340
how a block chain works.

6
00:00:17.520 --> 00:00:21.930
And at the very end we're going to write out our own smart contract and the

7
00:00:22.080 --> 00:00:25.310
solidity programming language to the language of etherium.
So it's,

8
00:00:25.320 --> 00:00:27.930
it's going to look kind of like this where we'll say,
okay,

9
00:00:28.050 --> 00:00:33.030
here's the integer create,
it's going to create a value in this contract object.

10
00:00:33.031 --> 00:00:35.670
And this is on a decentralized virtual machine.

11
00:00:35.671 --> 00:00:38.850
I know right now it sounds like a bunch of crazy.
What are you talking about?

12
00:00:38.851 --> 00:00:42.390
But don't worry,
we have so much to cover in this video.
I'm so excited.

13
00:00:42.690 --> 00:00:45.840
So just sit back,
relax,
and get ready for some amazing,

14
00:00:45.841 --> 00:00:47.670
amazing stuff because this stuff is just,

15
00:00:48.020 --> 00:00:51.750
it blows my mind every time I look at it,
it blows my mind.
So that's,

16
00:00:51.751 --> 00:00:54.780
that's the demo at the end of the video.
But we have some things to cover first.

17
00:00:55.080 --> 00:00:58.830
So this is the only part that's going to be non technical at the beginning.

18
00:00:58.831 --> 00:01:02.910
And that is the why.
Why does web 3.0 matter,

19
00:01:02.911 --> 00:01:06.060
okay now that's very important.
So web 1.0 we've,

20
00:01:06.090 --> 00:01:10.290
that was the birth of the Internet web 2.0 was the creation of the services that

21
00:01:10.291 --> 00:01:14.100
we all know and love.
Google,
you know all the social networks,
the snapchat,

22
00:01:14.101 --> 00:01:14.730
everything.

23
00:01:14.730 --> 00:01:19.710
That's web 2.0 now we need to move to web 3.0 so I'm going to explain why.

24
00:01:19.740 --> 00:01:23.100
Okay,
so this is actually a multivariate problem.

25
00:01:23.101 --> 00:01:27.330
There are multiple reasons why we need to move to web 3.0 so,

26
00:01:27.331 --> 00:01:29.940
but I think the easiest reason,
the easiest,

27
00:01:30.300 --> 00:01:34.260
the main reason I could give people that people would care about the most is

28
00:01:34.261 --> 00:01:39.180
that if you want to build a startup that can compete with the big giants,

29
00:01:39.450 --> 00:01:43.530
this is the only way to really do that.
Or it's the best way.

30
00:01:43.531 --> 00:01:45.060
It's the best way to do that.

31
00:01:45.420 --> 00:01:50.420
So if we look at web 2.0 the first problem is there is no room for competition.

32
00:01:51.060 --> 00:01:53.850
Look at these services that control the Internet.
At this point,

33
00:01:54.090 --> 00:01:58.890
all traffic goes through Google and Microsoft and Facebook.
By do Amazon.

34
00:01:59.070 --> 00:02:02.430
These companies have the most money.
They have all the data,

35
00:02:02.670 --> 00:02:05.730
they have the best talent to create the best algorithms.

36
00:02:06.000 --> 00:02:07.710
They have the most computing power.

37
00:02:07.890 --> 00:02:12.660
How is anyone supposed to compete with these people,
right?
They have everything.

38
00:02:12.661 --> 00:02:14.250
They have all the resources.

39
00:02:14.550 --> 00:02:18.570
How are you supposed to start a startup in this day and age?
Well,

40
00:02:18.571 --> 00:02:20.520
the answer is decentralized applications,

41
00:02:20.550 --> 00:02:25.140
so that's just the first problem with web 2.0 the second problem is that we have

42
00:02:25.141 --> 00:02:28.710
a shrinking economy.
It's a winner take all economy right now.

43
00:02:28.740 --> 00:02:31.680
What I mean by that is the rise of these services,

44
00:02:31.710 --> 00:02:35.640
the rise in terms of the valuation and the data and the computing power and the

45
00:02:35.641 --> 00:02:37.980
talent.
As they grow bigger and bigger and bigger,

46
00:02:38.320 --> 00:02:43.320
they have created this kind of winner take all economy via the Internet and it's

47
00:02:43.441 --> 00:02:47.760
responsible for a lot of the income inequality because all of these services

48
00:02:47.761 --> 00:02:52.020
that used to be,
they used to belong to the creators to say,
for example,

49
00:02:52.080 --> 00:02:56.310
the music industry.
Now it's all those profits are being concentrated,

50
00:02:56.340 --> 00:02:59.430
centralized into these giant,
what Jerome Linear,

51
00:02:59.440 --> 00:03:03.820
one of the pioneers of the Internet calls,
siren servers,
Amazon,
Google,
Facebook,

52
00:03:03.870 --> 00:03:06.940
etc. So take the music industry,
for example,

53
00:03:07.150 --> 00:03:11.560
the Internet liberated the distribution of music.
Great Spotify,
Pandora,

54
00:03:11.561 --> 00:03:15.070
iTunes.
But what happened is working class musicians,

55
00:03:15.250 --> 00:03:19.570
their earnings have consistently gone down over the years and they become this

56
00:03:19.630 --> 00:03:24.630
underpaid underclass who can no longer count on royalties as the basis of a

57
00:03:24.821 --> 00:03:26.920
sustainable middle class life.

58
00:03:27.100 --> 00:03:30.620
The Internet rocked everything in the music industry rights and now I'm

59
00:03:30.621 --> 00:03:34.090
musicians can't get paid.
So this is uh,
this is a problem,
right?

60
00:03:34.091 --> 00:03:37.660
This is this a real problem because in a good economy we should be monetizing

61
00:03:37.690 --> 00:03:41.200
more and more.
But in a bad economy,
we're monetizing less and less.

62
00:03:41.350 --> 00:03:43.840
And that's exactly what's happening as all the data,

63
00:03:44.080 --> 00:03:49.030
the real value in this new world that we're building,
all of it is being owned,

64
00:03:49.031 --> 00:03:52.330
controlled,
and monetize by a few key entities.

65
00:03:52.600 --> 00:03:55.120
You are not owning your data,

66
00:03:56.110 --> 00:03:58.540
which brings me to the third problem.
Data ownership.

67
00:03:58.930 --> 00:04:01.840
We no longer feel like we can control our data.
You don't own it.

68
00:04:01.900 --> 00:04:05.260
You're giving away your free data in return for a free service,

69
00:04:05.290 --> 00:04:09.310
and this works well enough.
However,
it's caused the economy to shrink over time.

70
00:04:09.670 --> 00:04:13.000
Your data is being used to spy on you.
Take prison,
for example,

71
00:04:13.180 --> 00:04:15.640
advertised to you to things you wouldn't even know.

72
00:04:15.760 --> 00:04:20.440
I was talking to a friend the other day and then I saw the ad for the topic I

73
00:04:20.441 --> 00:04:22.630
was talking about show up in my Facebook messenger.

74
00:04:22.840 --> 00:04:25.900
They are listening in our phones.
They're listening in our Google homes.

75
00:04:26.020 --> 00:04:27.490
They're listening everywhere,
okay,

76
00:04:27.491 --> 00:04:30.820
and they can do that because we've given them the permission to do that.

77
00:04:30.970 --> 00:04:34.300
We're giving them all our data and they are profiting off of our data.

78
00:04:34.390 --> 00:04:38.980
We should be profiting off of our data.
Fourth Point,
accountability.

79
00:04:39.010 --> 00:04:39.843
Right?

80
00:04:40.540 --> 00:04:45.370
Edward Snowden became infamous when he told the world about prison,
right?

81
00:04:45.371 --> 00:04:49.630
That US government and it say surveillance service.
He said,
well,
look,

82
00:04:49.660 --> 00:04:53.050
all of these companies have partnered with the NSA to give away your email,

83
00:04:53.051 --> 00:04:55.630
your chat,
your videos,
your photos,
all this stuff,

84
00:04:55.930 --> 00:04:59.400
and we can't really do anything about it,
right?
There's no oversight.
It's,

85
00:04:59.530 --> 00:05:03.820
there's no transparency into what these services are doing with our data.

86
00:05:04.000 --> 00:05:06.640
There's no,
it's a one way street.
You give them your data,

87
00:05:06.790 --> 00:05:10.990
they decide what to do with it.
That's it.
Hands off.
They'll govern how it's used.

88
00:05:11.170 --> 00:05:15.550
This is a problem.
Okay,
so another person is a Tristen Harris.

89
00:05:15.730 --> 00:05:20.730
So Tristan Harris is an x design ethicist at Google and Tristan Harris says that

90
00:05:21.610 --> 00:05:25.190
these siren servers like Facebook,
Google,
Amazon,
uh,

91
00:05:25.630 --> 00:05:29.950
are competing for attention.
We have,
we are moving to an attention economy.

92
00:05:30.010 --> 00:05:32.140
The Facebook newsfeed for example,

93
00:05:32.380 --> 00:05:37.240
is optimizing for your attention because that's what drives their ad revenue

94
00:05:37.241 --> 00:05:39.040
business model.
However,

95
00:05:39.070 --> 00:05:43.150
this is a problem because what's what gets your attention isn't necessarily

96
00:05:43.151 --> 00:05:46.240
what's beneficial to you.
It isn't necessarily what's good for you.

97
00:05:46.270 --> 00:05:50.890
What they should be optimizing for is your time well spent and that's a movement

98
00:05:50.891 --> 00:05:53.650
that he's,
he's working on election tampering.

99
00:05:53.740 --> 00:05:57.100
We have no say in the governance of how these systems are created.

100
00:05:57.320 --> 00:06:00.920
Fifth point artificial general intelligence.
Okay.

101
00:06:01.220 --> 00:06:04.220
We have got way too many problems in the world.
Climate Change,

102
00:06:04.221 --> 00:06:05.150
existential crisis.

103
00:06:05.151 --> 00:06:10.040
He's like asteroid impact and pollution and disease and warfare.

104
00:06:10.040 --> 00:06:13.580
And this is way too many problems in the world.
But if we saw AI,

105
00:06:13.610 --> 00:06:17.810
we can say solve for x and it will solve literally everything.

106
00:06:18.020 --> 00:06:22.820
If we solve real intelligence,
Aka artificial general intelligence,

107
00:06:22.910 --> 00:06:27.910
so it is to be seen that Agi is the most important thing we can work on to solve

108
00:06:28.341 --> 00:06:30.350
all of these other problems.
Beneficial Agi,

109
00:06:30.410 --> 00:06:34.790
maybe there is a missing link to creating AGI.
What is that missing link?

110
00:06:34.850 --> 00:06:38.000
So if we think about an AI as a control system,
right?

111
00:06:38.001 --> 00:06:41.270
A control system that has a controller,
it has a state,

112
00:06:41.360 --> 00:06:45.950
it has systems for sensing the world motor sensors for moving around,

113
00:06:46.130 --> 00:06:49.190
internal forwarding mechanisms to transmit all this data.

114
00:06:49.310 --> 00:06:51.470
You don't have to understand all this right now.
This is kind of just a,

115
00:06:51.710 --> 00:06:55.040
an abstract general idea of how an AI runs.

116
00:06:55.670 --> 00:07:00.560
How can we let this AI make decisions on its own and learn by itself in a way

117
00:07:00.561 --> 00:07:05.330
that's not controlled by humans right now we store our AI on a server and we

118
00:07:05.331 --> 00:07:07.070
control everything about it.

119
00:07:07.270 --> 00:07:11.180
But what if we let it free and live into the live in the world and make its own

120
00:07:11.181 --> 00:07:12.014
decisions?

121
00:07:12.110 --> 00:07:16.070
What we would need some kind of decentralized service not controlled by anybody,

122
00:07:16.100 --> 00:07:16.933
right?

123
00:07:17.530 --> 00:07:22.530
So if we create what's called an AI distributed autonomous organization,

124
00:07:22.781 --> 00:07:24.100
don't worry if you don't understand that word,

125
00:07:24.400 --> 00:07:26.530
but what that means is it's a new breed.

126
00:07:26.560 --> 00:07:29.710
It's another word for decentralized application,
Dao,
dao.

127
00:07:30.100 --> 00:07:33.510
It's a new way of creating companies,
of entities on the web is.

128
00:07:33.600 --> 00:07:37.570
So if we link these two technologies together,
AI and blockchain,

129
00:07:38.050 --> 00:07:39.460
we can see that the AI,

130
00:07:39.461 --> 00:07:43.540
it's getting its missing link resources like cryptocurrency that it doesn't

131
00:07:43.541 --> 00:07:47.620
depend on any central third party,
right?
And the DA,
oh,

132
00:07:47.621 --> 00:07:50.920
the blockchain gets its missing link,
autonomous decision making.

133
00:07:51.070 --> 00:07:54.640
So we put these things together and we create something like a living entity

134
00:07:54.641 --> 00:07:59.290
that lives on the web.
And the last,

135
00:07:59.320 --> 00:08:03.610
the last problem is data permanence.
So there's this idea of book burning,
right?

136
00:08:03.611 --> 00:08:06.400
In the Middle Ages,
book burning was considered heresy.

137
00:08:06.430 --> 00:08:10.270
It was considered one of the worst things that anybody could do because books

138
00:08:10.271 --> 00:08:14.140
where the store of information,
right?
So book burning was a really bad thing.

139
00:08:14.350 --> 00:08:18.790
So right now,
the way we store our data,
it can be lost over time,
right?
Yes,

140
00:08:18.791 --> 00:08:22.390
it's stored in a data server and yes,
you know,
that server could go down,

141
00:08:22.391 --> 00:08:23.500
but maybe there's a backup.

142
00:08:23.680 --> 00:08:27.670
But ideally all data is replicated hundreds of times across the web.

143
00:08:27.671 --> 00:08:30.370
So you could never,
never,
never destroyed data.

144
00:08:30.580 --> 00:08:32.770
Think about all the things that really mattered to us.

145
00:08:32.890 --> 00:08:37.060
Scientific discoveries and diaries and memories of your loved ones and lost,

146
00:08:37.120 --> 00:08:39.370
you know,
things over time he never wanted to lose.

147
00:08:39.550 --> 00:08:44.170
So we need a way to create data permanence.
So six,

148
00:08:44.200 --> 00:08:46.630
six reasons.
Okay,
so six reasons for this.

149
00:08:46.990 --> 00:08:51.380
So I'm going to take all those reasons and provide a single solution called a

150
00:08:51.400 --> 00:08:53.920
decentralized application.
Okay.

151
00:08:53.921 --> 00:08:58.260
So what is now possible with the advent of the Bitcoin blockchain?

152
00:08:58.500 --> 00:09:02.520
A couple of years ago we discovered that it was possible to create what's called

153
00:09:02.521 --> 00:09:04.290
a decentralized application.

154
00:09:04.590 --> 00:09:08.340
That is an application that that is not controlled by any single entity.

155
00:09:08.670 --> 00:09:11.460
So if we look at this map of different types of networks,

156
00:09:11.640 --> 00:09:16.380
the centralized network is like this where the main,
all the other nodes,

157
00:09:16.440 --> 00:09:21.060
like let's say humans or computers rely on a single server.
Okay?

158
00:09:21.090 --> 00:09:25.110
So that's a centralized model.
There's the distributed network like this.
Okay?

159
00:09:25.111 --> 00:09:28.740
The one on the far right's where there,
it could still be centralized,

160
00:09:28.890 --> 00:09:31.910
but it's not just dependent on a single node.
It can happen.

161
00:09:31.940 --> 00:09:33.690
It can be distributed.
So for example,

162
00:09:33.960 --> 00:09:37.980
it's type of system can be both centralized and distributed.
Facebook,

163
00:09:37.981 --> 00:09:41.430
for example,
it doesn't have a single server.
It's got multiple servers,

164
00:09:41.580 --> 00:09:43.410
but it's controlled by a single entity.

165
00:09:43.500 --> 00:09:47.160
So it's both centralized and distributed across the world,

166
00:09:47.310 --> 00:09:49.440
but it's still controlled by a single entity.
Now,

167
00:09:49.441 --> 00:09:53.670
decentralize is a new type of system that was enabled by bitcoin.

168
00:09:53.880 --> 00:09:55.680
It was the first decentralized system.

169
00:09:55.830 --> 00:09:58.530
What that means is if you take away one of those notes,

170
00:09:58.800 --> 00:10:02.250
the system will still run because it doesn't depend on any node.
However,

171
00:10:02.251 --> 00:10:05.820
for a distributed network that's centralize,
you take away the central node,

172
00:10:05.850 --> 00:10:08.730
the whole thing collapses.
But for a decentralized system,

173
00:10:08.731 --> 00:10:10.110
you can never destroy it.

174
00:10:11.460 --> 00:10:15.480
So you can now create an APP that's number one,

175
00:10:15.780 --> 00:10:19.890
open source and profitable.
That's never been possible before.

176
00:10:20.220 --> 00:10:22.990
Either it's closed source like Microsoft office or APP,

177
00:10:23.010 --> 00:10:28.010
anything by apple and it makes money or it's open source like Ubuntu or Firefox,

178
00:10:28.441 --> 00:10:30.900
and you don't make any money for the first time.

179
00:10:30.900 --> 00:10:34.530
You can make an application that's both open source and profitable.

180
00:10:34.920 --> 00:10:39.840
Second of all,
this can be a community governed slash controlled application.

181
00:10:40.590 --> 00:10:44.580
All of these actions that we perform inside of this network,
whether that be,

182
00:10:44.790 --> 00:10:49.350
you know,
what to spend our money on,
what,
who to hire,
how to market the product,

183
00:10:49.351 --> 00:10:50.280
how to make sales.

184
00:10:50.490 --> 00:10:55.410
We can create a structure using the blockchain where the people who use the APP

185
00:10:55.411 --> 00:10:57.870
can also opt in.
They can also say,

186
00:10:58.020 --> 00:11:00.600
let me vote on what we should be doing.

187
00:11:01.200 --> 00:11:05.520
I'll get into how all of this is possible later on.
And lastly,

188
00:11:05.760 --> 00:11:08.850
it can create,
we can create apps that are censorship resistance.

189
00:11:08.851 --> 00:11:10.440
So this is an example of,
you know,

190
00:11:10.441 --> 00:11:13.910
the APP store rejecting a certain APP because it,
it's,

191
00:11:13.940 --> 00:11:16.650
it's doesn't abide by Chinese law,
et Cetera.
You know,

192
00:11:16.710 --> 00:11:20.550
the Chinese firewall blocks a lot of applications from entering.
Um,

193
00:11:20.610 --> 00:11:25.610
because all of the apps that are mainstream on the internet today are not

194
00:11:25.830 --> 00:11:29.610
censorship resistant.
But if we build a decentralized APP,
no one,

195
00:11:29.611 --> 00:11:30.810
not the Chinese government,

196
00:11:30.840 --> 00:11:34.110
not any kind of negative entity could block your application.

197
00:11:34.260 --> 00:11:36.630
Like the Chinese government can't stop Bitcoin,

198
00:11:36.780 --> 00:11:40.710
they can also not stop any other kind of be centralized application that we

199
00:11:40.711 --> 00:11:41.544
built.

200
00:11:42.450 --> 00:11:46.830
So there's a lot of hype behind decentralized applications.
Okay.

201
00:11:47.010 --> 00:11:50.640
But the problem is it's kind of like this trade off,
right?

202
00:11:50.641 --> 00:11:54.070
So right now a lot of the decentralized applications out there,

203
00:11:54.340 --> 00:11:59.340
we are sacrificing speed and cost and scalability and sometimes even user

204
00:11:59.381 --> 00:12:03.370
interface for one single thing.
And that is censorship resistance.

205
00:12:03.880 --> 00:12:07.450
However,
as more people build these decentralized applications,

206
00:12:07.570 --> 00:12:11.470
this seesaw is gonna is gonna tear this way.
So it's going to be more even.

207
00:12:11.680 --> 00:12:14.260
And then all of those things will go to the,
to the left side.

208
00:12:14.260 --> 00:12:17.710
So we're going to gain back some of these things that we're sacrificing for the

209
00:12:17.711 --> 00:12:21.970
sake of censorship resistance.
So that's what we're building.

210
00:12:21.971 --> 00:12:24.160
We're trying to get there.
We are getting there very fast.

211
00:12:24.430 --> 00:12:27.910
All of these problems are being worked on.
So how do we get started?
Okay,

212
00:12:27.911 --> 00:12:32.620
so how do we get started with web 3.0 well it all starts with what I like to

213
00:12:32.621 --> 00:12:35.890
call the linked list.
So this is in python,

214
00:12:35.920 --> 00:12:38.230
don't worry if you don't understand it.
It's just a very,

215
00:12:38.231 --> 00:12:40.630
very basic class with some functions.

216
00:12:40.870 --> 00:12:44.900
But the link lists is a simple data structure that we learn in data structures.

217
00:12:44.920 --> 00:12:48.790
One Oh one the link lists is basically a way to store data.

218
00:12:49.210 --> 00:12:51.700
So a liquids is like this.

219
00:12:51.790 --> 00:12:55.270
Let's say you have a phrase like hello stack overflow,

220
00:12:55.271 --> 00:12:58.600
and you want to store that in some kind of data structure.
Let's say a link list.

221
00:12:58.840 --> 00:13:02.230
This is how it would look.
Okay,
so we'd say,
let's create a class.

222
00:13:02.231 --> 00:13:05.380
It's called class node and this represents a single node,

223
00:13:05.381 --> 00:13:08.170
like this little box inside of a linked list.

224
00:13:08.470 --> 00:13:11.980
Now this node is going to have several functions that will create the first

225
00:13:11.981 --> 00:13:14.230
function is the constructor function.
We'll,
we'll say,

226
00:13:14.470 --> 00:13:18.490
what is the data that we want to give this and what's the next node in the list?

227
00:13:18.491 --> 00:13:23.020
So we'll say initialize it with hello and then say self dot.
Next equals none.

228
00:13:23.050 --> 00:13:23.191
Well,

229
00:13:23.191 --> 00:13:26.710
we're going to set what the next note is so it just kind of block out all the

230
00:13:26.711 --> 00:13:28.330
other,
the other two boxes,

231
00:13:28.331 --> 00:13:32.440
there's only one box and now will secrete functions for getters and setters.

232
00:13:32.500 --> 00:13:36.520
So get data says return whatever we store it in that single node,
which would be,

233
00:13:36.521 --> 00:13:38.020
hello,
get next.

234
00:13:38.021 --> 00:13:41.860
We'll say we'll get the data in the next node that it's connected to set data.

235
00:13:41.860 --> 00:13:45.460
We'll say set what's inside of that note.
So we'll say set data,

236
00:13:46.000 --> 00:13:49.480
hello or whatever you want to store in there.
And lastly,
set next.

237
00:13:49.481 --> 00:13:51.520
We'll say we'll set the data in the next node,

238
00:13:51.521 --> 00:13:55.300
which would be stack and then set next again would be overflow.

239
00:13:55.480 --> 00:14:00.480
So now we have this link list of hello stack overflow three different strings

240
00:14:00.790 --> 00:14:05.170
stored in three different nodes.
The whole thing is considered a link list.

241
00:14:06.280 --> 00:14:10.780
So this link lists is an immutable data structure.

242
00:14:10.781 --> 00:14:13.420
We can change the values in this link list.

243
00:14:13.960 --> 00:14:17.080
But what if we could not change the values in this link list?

244
00:14:17.380 --> 00:14:21.790
What if it was an immutable link lists?
So once you store data in there,

245
00:14:21.910 --> 00:14:23.350
you cannot change it.

246
00:14:23.650 --> 00:14:27.550
So if we create what's called an immutable linked list,

247
00:14:27.940 --> 00:14:32.230
we would call it a blockchain.
Okay?

248
00:14:32.470 --> 00:14:33.790
That is what a blockchain is.

249
00:14:33.791 --> 00:14:38.791
A blockchain is a glorified linked list on immutable linked list.

250
00:14:39.580 --> 00:14:42.970
And instead of calling them nodes,
we call them blocks.

251
00:14:43.030 --> 00:14:45.280
And inside of these blocks we store data.

252
00:14:45.460 --> 00:14:49.150
The data is in the form of water called transactions.
Okay?

253
00:14:49.270 --> 00:14:50.680
So I'm gonna explain how this works.

254
00:14:50.860 --> 00:14:55.860
So a blockchain is essentially a linked lists that you cannot change the values

255
00:14:55.911 --> 00:14:59.610
of what's inside of there.
You cannot change.
How does this happen?
Well,

256
00:14:59.611 --> 00:15:02.420
so Toshi said,
let's create this system.
Bitcoin was,

257
00:15:02.510 --> 00:15:07.250
and it's going to use this data structure called the blockchain on my computer.

258
00:15:07.430 --> 00:15:11.570
I'm going to store this length list,
a block chain of transactions.
You know,

259
00:15:11.571 --> 00:15:13.760
Bob sent to Mary,
Mary Center,
blah,
blah,
blah.

260
00:15:13.790 --> 00:15:15.680
All these transactions of people sending money.

261
00:15:15.920 --> 00:15:18.800
And I'm going to store it on my computer.
And then other people,

262
00:15:18.801 --> 00:15:23.270
let's say 10 other people will store the same exact data structure.
Okay,

263
00:15:23.420 --> 00:15:24.253
the blockchain,

264
00:15:25.280 --> 00:15:29.420
how do I make sure that no one can change the values in this list?
Right?

265
00:15:29.450 --> 00:15:32.280
You don't want your bank changing the values in your account,
right?
You,

266
00:15:32.281 --> 00:15:35.630
it would change your account balance,
right?
That's what we have banks.

267
00:15:35.870 --> 00:15:38.030
But what Sitoshi said was,
oh,
I have a,

268
00:15:38.090 --> 00:15:42.350
I have a genius way of preventing people from changing the value in this

269
00:15:42.410 --> 00:15:43.790
blockchain.
So Toshi said,

270
00:15:43.820 --> 00:15:47.180
in order for someone to change the value in their blockchain,

271
00:15:47.540 --> 00:15:51.650
they would have to have more computing power in the majority of the network.

272
00:15:51.980 --> 00:15:56.830
And what happened was the bitcoin network grew so fast,
it,
it,

273
00:15:57.310 --> 00:16:01.040
it had more computing power than the 500 fastest supercomputers in the world

274
00:16:01.041 --> 00:16:01.874
combined.

275
00:16:01.910 --> 00:16:06.080
So in order to change any of those values in a single block of that actor would

276
00:16:06.081 --> 00:16:09.950
have to have more computing power than the 500 fastest supercomputers in the

277
00:16:09.951 --> 00:16:12.980
world combined.
And no one has that much computing power.

278
00:16:12.981 --> 00:16:17.390
So the blockchain has remained immutable and this has been a revolution,
right?

279
00:16:17.390 --> 00:16:18.051
For the first time.

280
00:16:18.051 --> 00:16:21.710
We don't need to trust a bank or any kind of central party to say,

281
00:16:21.770 --> 00:16:23.990
we're not going to modify your,
your data structure.

282
00:16:24.020 --> 00:16:27.260
Now we have this network where no one can change that.
No one controls.

283
00:16:27.530 --> 00:16:30.020
Now we can use this to apply it to different things.

284
00:16:30.320 --> 00:16:35.300
But the way the proof of work algorithm works is by doing several things.

285
00:16:35.390 --> 00:16:38.840
The first is a node is,
so a note in the block chain,

286
00:16:38.870 --> 00:16:43.730
a miner will say,
I'm going to retrieve a pending transaction.
Okay?

287
00:16:43.820 --> 00:16:46.580
So they're going to retrieve that transaction.
It's got to several features,

288
00:16:46.760 --> 00:16:50.090
a Hash,
a block id,
uh,
transactions hash.

289
00:16:50.420 --> 00:16:52.610
And then what they're going to do is they're going to calculate the proof of

290
00:16:52.611 --> 00:16:55.120
work.
It's going to take some time.
They're going to stand,

291
00:16:55.130 --> 00:16:59.390
send the blog and prove to the node,
update the blockchain,
and then broadcast.

292
00:17:01.010 --> 00:17:04.130
So what is the proof of work look like?
So the proof of work looks like this.

293
00:17:04.310 --> 00:17:08.600
They're going to say,
okay,
here are some proposed transactions.
Okay,
I get you.

294
00:17:08.601 --> 00:17:09.830
I get the transactions.

295
00:17:10.010 --> 00:17:13.850
Now I'm going to hash it using what's called the Sha two five six hashing

296
00:17:13.851 --> 00:17:15.770
algorithm.
Don't worry if you don't understand this,

297
00:17:15.830 --> 00:17:18.890
we're going to go over this in the future,
but let's just say the block,

298
00:17:18.891 --> 00:17:19.680
we'll take the,

299
00:17:19.680 --> 00:17:24.410
the minor will take this transaction and try to compete compute some random

300
00:17:24.411 --> 00:17:29.330
string from this transaction.
If the computed Hash is below a threshold value,

301
00:17:29.630 --> 00:17:33.500
then he'll say,
okay,
I won the game and now this is my proof of work,

302
00:17:33.740 --> 00:17:35.870
but if it hasn't,
it's got to Redo it again.

303
00:17:36.160 --> 00:17:40.400
She's got to keep redoing that hash calculation over and over and over and over

304
00:17:40.401 --> 00:17:44.960
and over over again until the value is below this threshold and then it can say,

305
00:17:44.990 --> 00:17:49.190
okay,
this is the proof of work.
I proved it,
I've solved it,
done.
That's the basic.

306
00:17:49.560 --> 00:17:51.990
Now,
if all the miners do this,
they all do.

307
00:17:52.170 --> 00:17:55.590
Then the amount of computing power that the network has,
his giant,
gigantic,

308
00:17:55.591 --> 00:17:55.771
right?

309
00:17:55.771 --> 00:17:59.910
Because there there's so many minors and that's why it's secured that no one can

310
00:17:59.911 --> 00:18:02.730
change it because they would have to have more computing power than all of these

311
00:18:02.731 --> 00:18:06.180
minors or half of them,
which is no one has that much computing power.

312
00:18:07.140 --> 00:18:10.890
So the best way to really explain how this blockchain thing works is by

313
00:18:10.891 --> 00:18:15.150
looking@avisualdemothatifoundbythisguyandrewandrews.com so here's,

314
00:18:15.180 --> 00:18:19.500
so hashing is basically taking some value and creating some fixed outputs.

315
00:18:19.501 --> 00:18:22.500
So taking an input,
doing some kind of function to it,

316
00:18:22.501 --> 00:18:25.200
some series of operations and the computing an output,

317
00:18:25.201 --> 00:18:28.230
which we couldn't call a hash.
So let's say I have some data,

318
00:18:28.231 --> 00:18:32.730
like y'all notice how every letter I type the hash below changes.

319
00:18:32.820 --> 00:18:37.710
So if I type in a,
B,
c,
d,
a unique hash shows up,
let me try it again.
A,

320
00:18:37.711 --> 00:18:42.690
B,
c,
d,
the same exact unique hash shows up.
So no matter what,

321
00:18:42.810 --> 00:18:47.010
if someone has,
if someone wants to create a hash that looks like this,

322
00:18:47.350 --> 00:18:52.230
the only input data that could create this hash is the word a,
B,
c,
d.

323
00:18:52.290 --> 00:18:54.960
That's it.
So that's,
that's the hashing function.
Okay.

324
00:18:55.200 --> 00:18:58.440
That and then so bitcoin uses what's called the Sha two five six.

325
00:18:58.441 --> 00:19:01.980
I'll go into the details of that later on,
but it's a type of hashing function.

326
00:19:02.580 --> 00:19:07.320
So that brings us to the block.
Okay.
So for block we're going to say,

327
00:19:07.321 --> 00:19:10.560
let's have some data and it's got this hashing function.
Okay?

328
00:19:10.561 --> 00:19:13.080
So this is blocked number one.
So what are,

329
00:19:13.140 --> 00:19:16.650
what a minor will do is they'll mind that block to find what's called the knots.

330
00:19:16.950 --> 00:19:21.090
The number only used once,
it's called a nonce,
but it's got to find what is,

331
00:19:21.150 --> 00:19:25.950
what is the,
what is a valid nonce for this data to create a hash.

332
00:19:26.010 --> 00:19:26.880
So I hit mine.

333
00:19:28.400 --> 00:19:29.140
<v 2>Okay.</v>

334
00:19:29.140 --> 00:19:33.580
<v 0>Okay.
And then it shows this correct knots.
So now it's mine.
The block,</v>

335
00:19:33.581 --> 00:19:38.170
it's computed like exactly what I said before from,
from the proof of work,

336
00:19:38.171 --> 00:19:41.690
a demo right here.
What is that threshold value?
Got It.
Here's the nones.

337
00:19:41.810 --> 00:19:45.940
It's kept trying to calculate this nonce for this data such that the hash looks

338
00:19:45.970 --> 00:19:50.020
just like this.
Okay?
So that's how mining works.

339
00:19:50.380 --> 00:19:55.060
Now a blockchain then is like this.
So it's a series of these blocks until minor.

340
00:19:55.061 --> 00:19:58.060
We'll say,
okay,
here's the data for this block.
Let me mine it.

341
00:20:00.450 --> 00:20:01.283
<v 2>Okay,</v>

342
00:20:01.320 --> 00:20:02.153
<v 0>Kay.</v>

343
00:20:06.670 --> 00:20:09.250
So in order to be able to mine any of these blocks,

344
00:20:09.490 --> 00:20:13.640
the miner has to have the,
the previous block before it,
right?

345
00:20:13.641 --> 00:20:17.440
So each block depends on the hash value of the previous block.

346
00:20:17.530 --> 00:20:19.510
What happens is the p,

347
00:20:19.560 --> 00:20:23.770
the Meyers with the longest chain are considered the most valid because they'd

348
00:20:23.771 --> 00:20:26.770
been around the longest time.
So if I tried to break any of this,
if I,

349
00:20:26.771 --> 00:20:30.610
if I change the value here,
notice how this one turned red as well.

350
00:20:30.730 --> 00:20:32.170
The whole blockchain breaks.

351
00:20:32.440 --> 00:20:37.330
So the miners with the longest chain are considered the most valid during this

352
00:20:37.331 --> 00:20:38.440
proof of work mechanism.

353
00:20:38.590 --> 00:20:42.250
I just wanted to give you kind of fly by overview of how a block chain works.

354
00:20:42.730 --> 00:20:44.320
We'll go into more of those details later,

355
00:20:44.321 --> 00:20:48.130
but I just wanted to give you some idea of a blockchain.
It's not,
you know,

356
00:20:48.640 --> 00:20:51.400
it's super complicated thing.
It's actually very simple thing.

357
00:20:51.401 --> 00:20:53.260
It's a glorified linked list.

358
00:20:53.290 --> 00:20:57.940
It's immutable at a bunch of people store secured by a proof of work algorithm,

359
00:20:58.090 --> 00:21:01.900
which uses hashing,
which is which the topic in computer science,

360
00:21:01.990 --> 00:21:05.830
which I'll go over in detail later.
So let's move on to the web 3.0 stack.

361
00:21:06.220 --> 00:21:10.750
So for Web 2.0 if you want to build an app you use for computation,

362
00:21:10.780 --> 00:21:13.120
use Amazon Ece to Heroku,
right?

363
00:21:13.121 --> 00:21:16.030
These are services that provide computation in the cloud,

364
00:21:16.360 --> 00:21:18.910
but now you can use what's called etherium.
Okay,

365
00:21:18.911 --> 00:21:22.730
I'll talk about that in a second.
For file storage,
you would use [inaudible],

366
00:21:22.750 --> 00:21:25.750
Google cloud,
Floyd hub,
one of these storage providers.

367
00:21:25.751 --> 00:21:30.220
But now you can use what's called IPFS.
For external data,

368
00:21:30.221 --> 00:21:33.490
you use a third party Api to pull data from the web.

369
00:21:33.670 --> 00:21:38.410
But now you use what's called an oracle.
For Monetization,
you would say,

370
00:21:38.440 --> 00:21:43.180
okay,
it's gotta be the ad model,
but now we've got the token model for payments.

371
00:21:43.180 --> 00:21:45.880
You'd use paypal,
visa,
AMX,
all of these depend on banks.

372
00:21:46.210 --> 00:21:49.150
But now we can use bitcoin like coin etherium.

373
00:21:49.360 --> 00:21:54.360
So each aspect of web 2.0 is now decentralized and we can use all of these

374
00:21:55.901 --> 00:21:56.710
services.

375
00:21:56.710 --> 00:22:00.850
So am I going to talk about every single one of these etherium IPFS Oracle's

376
00:22:00.851 --> 00:22:04.840
token in this video?
No,
that'd be far too much.
We've got a lot to cover.

377
00:22:04.841 --> 00:22:09.220
Like I said,
okay.
We understand the basics of how blockchain works,

378
00:22:09.400 --> 00:22:12.730
which is fine for now.
Now let's just go over a theory.
I'm just,

379
00:22:12.731 --> 00:22:16.210
just a little bit,
just a very little bit.
We have so much to cover.
Don't worry.

380
00:22:16.211 --> 00:22:21.160
I know it's a lot.
But the,
if the idea behind ethereum was the founders said,

381
00:22:21.190 --> 00:22:25.390
let's take this idea of bitcoin where we have this blockchain and immutable data

382
00:22:25.391 --> 00:22:29.710
structure and say,
well,
we don't have to trust a bank to store this data.

383
00:22:30.010 --> 00:22:33.070
What else can we use this for?
Well,
we can use this to say,

384
00:22:33.610 --> 00:22:37.810
we can basically decentralize everything that exists right now,
right?
Insurance,

385
00:22:38.020 --> 00:22:42.220
uh,
social networks.
We have to trust the central party for social networks,

386
00:22:42.400 --> 00:22:45.850
ride sharing,
uh,
everything,
games,

387
00:22:46.510 --> 00:22:47.980
blizzard and world of Warcraft.

388
00:22:48.040 --> 00:22:52.660
There's always some kind of central middlemen that we have to trust between all

389
00:22:52.661 --> 00:22:53.410
these services.

390
00:22:53.410 --> 00:22:58.060
So we can basically disrupt everything and just apply blockchain to every single

391
00:22:58.061 --> 00:22:58.591
idea.
And,

392
00:22:58.591 --> 00:23:01.750
and now it's a new type of startup that couldn't have been possible before.

393
00:23:01.900 --> 00:23:02.860
So what they said was,

394
00:23:03.040 --> 00:23:08.040
let's create a blockchain that we can store code inside of.

395
00:23:08.560 --> 00:23:11.440
Okay,
not just transactions.
Transactions are fine,

396
00:23:11.590 --> 00:23:14.320
but what if we started code inside of this thing?
Well,

397
00:23:14.350 --> 00:23:17.950
then we can decentralize what's called like Heroku,
right?
Computation.

398
00:23:18.310 --> 00:23:23.110
Now it's a world computer.
We can create an APP and let it live on this network,

399
00:23:23.170 --> 00:23:26.410
not Heroku,
but on a network that nobody controls.

400
00:23:26.530 --> 00:23:29.380
So it's essentially an unstoppable application.

401
00:23:29.530 --> 00:23:33.190
No one can shut down this application.
So that's just the first bit,
right?

402
00:23:33.191 --> 00:23:36.790
There's a lot of different things going on here and noticed how the etherium

403
00:23:36.791 --> 00:23:39.640
blockchain look similar to the bitcoin blockchain,

404
00:23:39.790 --> 00:23:43.700
except there's a whole bunch of other features and variables in there.

405
00:23:43.720 --> 00:23:46.280
We don't have to worry about that.
Just notice code bid right here.

406
00:23:46.400 --> 00:23:51.170
That's it for now.
It's stores code.
It's like the Bitcoin blockchain except for,

407
00:23:51.200 --> 00:23:54.830
except it doesn't just store transactions.
It stores code.

408
00:23:54.950 --> 00:23:59.300
It's a decentralized Heroku.
That's it.
Okay.

409
00:23:59.390 --> 00:24:00.980
So when I say it stores code,

410
00:24:01.190 --> 00:24:05.540
it stores a specific type of code that's called a smart contract.

411
00:24:05.780 --> 00:24:09.170
And a smart contract looks like this.
Okay?
A theory,

412
00:24:09.171 --> 00:24:12.200
I'm has its own language called solidity,

413
00:24:12.201 --> 00:24:14.600
which we're going to go into so much over the coming weeks,

414
00:24:14.900 --> 00:24:15.950
but it's called solidity.

415
00:24:16.190 --> 00:24:19.910
And what you can do is you can write code in this language that goes on the

416
00:24:19.911 --> 00:24:24.140
ethereum blockchain that no one can shut down.
It's,
it's unstoppable,

417
00:24:24.290 --> 00:24:26.600
unchangeable,
immutable code.

418
00:24:26.870 --> 00:24:30.950
And generally if solidity contracts have four parts,

419
00:24:31.010 --> 00:24:35.810
they've got an address that you know,
identifies what,
where that contract is.

420
00:24:36.050 --> 00:24:39.650
They've got to balance,
they've got some code and they have a state.
Okay?

421
00:24:39.860 --> 00:24:43.370
So what we're going to do right now is we're going to code our first simple

422
00:24:43.371 --> 00:24:48.140
solidity contract.
So what I've got here is the remix solidity compiler.

423
00:24:48.141 --> 00:24:51.620
What this is,
is is a browser compiler for solidity.

424
00:24:51.800 --> 00:24:55.910
So we can compile solidity contracts in the browser,
very useful stuff.

425
00:24:56.090 --> 00:25:01.090
It's that you can find it@remixdotethereum.org so all of the solidity contracts

426
00:25:02.090 --> 00:25:05.090
and in dot Sol because is its own language.

427
00:25:05.300 --> 00:25:07.130
It's very similar to Java script,

428
00:25:07.131 --> 00:25:09.290
so we're going to have to take some getting used to,

429
00:25:09.291 --> 00:25:11.300
I'm going to teach you a lot about this over the coming weeks,

430
00:25:11.450 --> 00:25:13.130
but let's just try it.
A very simple one.
Okay?

431
00:25:13.310 --> 00:25:17.930
So the first thing we're going to do for solidity is important is say,
well,

432
00:25:17.931 --> 00:25:19.910
what is the version of solidity we want to use?

433
00:25:19.911 --> 00:25:23.270
So we always have to say pragmatic,
just kind of an identifier to say,

434
00:25:23.390 --> 00:25:25.430
here's the version of solidity we want to use.

435
00:25:25.580 --> 00:25:29.720
And I'm going to say it's going to be point a 4.16

436
00:25:31.280 --> 00:25:33.920
now I'm going to say,
okay,
I'm going to create my contract.

437
00:25:33.950 --> 00:25:37.940
So this is my contract object and I'm going to call it test contract.

438
00:25:38.090 --> 00:25:41.630
So this is my contract class,
okay?
It's a class object,
right?

439
00:25:41.660 --> 00:25:44.900
Object oriented programming.
This is my class.
This is my object.

440
00:25:44.901 --> 00:25:48.290
That's called test contract.
Now what I'm going to do is I'm gonna say,
okay,

441
00:25:48.291 --> 00:25:53.090
well this contract has a single value called in called value.
Okay?

442
00:25:53.240 --> 00:25:55.190
That's all it's gonna do.
It's going to store this value.

443
00:25:55.340 --> 00:25:59.090
And what I'm gonna do is I'm going to create getters and setters to help set the

444
00:25:59.091 --> 00:26:00.890
value here and get the value here.

445
00:26:02.030 --> 00:26:06.620
So the first function that I'm going to create in this test contract class is

446
00:26:06.621 --> 00:26:11.600
called a test contract.
And the input is going to be an integer.

447
00:26:11.870 --> 00:26:16.430
And this is essentially notice how this name of this function is the same as the

448
00:26:16.431 --> 00:26:21.050
object's name,
which means it's called a constructor.
Exactly.

449
00:26:21.051 --> 00:26:24.080
It's called the constructor.
It's okay if you don't know that it's a constructor

450
00:26:25.730 --> 00:26:27.770
which basically says,
if I initialize this object,

451
00:26:27.890 --> 00:26:32.240
here's the value I'm setting for value,
for value,
right when we start.
So I can,

452
00:26:32.270 --> 00:26:36.700
I can initialize it as whatever value I want to.
Now I'll create the set,
uh,
uh,

453
00:26:36.710 --> 00:26:41.090
create a set function called set p,
which stands for set payable.

454
00:26:41.360 --> 00:26:46.350
What this means is there is this called payable that solidity contracts use that

455
00:26:46.351 --> 00:26:48.150
say whether or not we can,

456
00:26:48.220 --> 00:26:52.380
the contract will accept any kind of payment in the form of ether,
right?

457
00:26:52.470 --> 00:26:56.220
And this can be used for different things,
whether it's a store up,
an auction,

458
00:26:56.340 --> 00:26:58.050
a shop,
you know,
all these different things.

459
00:26:58.140 --> 00:27:02.670
We'll dysfunction except we'll this object,
this test contract except payments,

460
00:27:02.671 --> 00:27:07.440
yes or no.
And so for this last function is called not payable and it says,

461
00:27:07.441 --> 00:27:11.040
well you can't pay this object anymore.
It doesn't accept payments.

462
00:27:11.041 --> 00:27:14.400
And here's the value that we want to set it to as well.
So for this last part,

463
00:27:14.401 --> 00:27:16.230
I'm going to say,
let's create a getter function.

464
00:27:16.231 --> 00:27:21.231
So it's called get constant returns and it's going to return the value of value,

465
00:27:22.351 --> 00:27:26.790
right?
Right here,
that's all it does.
And then it says return,

466
00:27:28.090 --> 00:27:29.430
boom.
Just like that.

467
00:27:30.870 --> 00:27:35.580
And now that's our contract,
right?
We've created this test contract object,

468
00:27:35.880 --> 00:27:40.620
it's got these tests,
these getters and setters,

469
00:27:41.760 --> 00:27:43.110
and now we can run this thing.

470
00:27:43.111 --> 00:27:46.920
So let me go ahead and refresh this page

471
00:27:50.560 --> 00:27:53.530
and then say,
start to compile.
Okay,

472
00:27:53.531 --> 00:27:58.390
so now I've compiled it and now I can create some value for this.
I'll say,
well,

473
00:27:58.420 --> 00:28:02.440
here's the value I want to add to the test contract.
Object create.

474
00:28:02.680 --> 00:28:04.870
So I've initializes test contract object.

475
00:28:04.871 --> 00:28:09.040
It now exists on the ethereum blockchain.
This is a test.
Blockchain is not the,

476
00:28:09.220 --> 00:28:11.170
it's not the production blockchain,
but now it exists.

477
00:28:11.380 --> 00:28:14.440
And now I can execute one of these functions I created.
Get set,

478
00:28:14.441 --> 00:28:19.420
not payable and set payable.
So I'll say set payable 20 okay,

479
00:28:20.430 --> 00:28:24.190
and now let's get the value.
Oh,
it's 20 right?
So let me set,

480
00:28:24.191 --> 00:28:28.810
not payable 10 so now it's not payable,
I can't pay it.

481
00:28:29.110 --> 00:28:32.800
And now I get,
and it's zero,
right?
So if we can set payable,

482
00:28:32.860 --> 00:28:36.780
I'm going to say 300 set payable yet.
And now that,

483
00:28:36.910 --> 00:28:39.910
now that that object,
that tests contract object,

484
00:28:40.120 --> 00:28:44.230
it's not initialized and exists on the blockchain,
on the test block chain,

485
00:28:44.530 --> 00:28:49.300
and it has a value of 300 of 300 that's that,
that variable we coded up here.

486
00:28:49.630 --> 00:28:52.330
So super simple solidity contract.
I know,

487
00:28:52.480 --> 00:28:56.470
but it's a very easy way to get started to just have this thing run yourself,

488
00:28:56.710 --> 00:29:01.180
all this other stuff,
gas environment,
value,
the debugger,

489
00:29:01.240 --> 00:29:05.230
all this stuff we're going to get to.
But just for now,
be okay with saying,
okay,

490
00:29:05.260 --> 00:29:09.820
I get why we need web 3.0 I get what a blockchain is.

491
00:29:09.821 --> 00:29:12.970
Basically,
I get the,
the theory and blockchain is saying,

492
00:29:12.971 --> 00:29:15.820
let's take the Bitcoin blockchain and just put code in it so we can have

493
00:29:15.970 --> 00:29:17.440
decentralized computation.

494
00:29:17.680 --> 00:29:21.400
And I get that solidity is the language of ethereum that I can run smart

495
00:29:21.401 --> 00:29:25.390
contracts with that are censorship resistant.
And this,

496
00:29:25.391 --> 00:29:26.980
and this is an example of one.

497
00:29:27.250 --> 00:29:29.920
If you get that you're good and I can't wait to see you next time,

498
00:29:29.980 --> 00:29:32.560
please subscribe for more programming videos.
And for now,

499
00:29:32.650 --> 00:29:35.260
I've got to use a theory of more.
So thanks for watching.

