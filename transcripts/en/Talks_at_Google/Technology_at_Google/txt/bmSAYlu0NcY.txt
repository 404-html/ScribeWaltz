Speaker 1:          00:00:08       Okay. So, um, welcome mark. Good morning everyone. Now it's my pleasure to welcome professor Osterhout for the stocks at Google presentation. Now my name is Porter Aminata and I work and technical infrastructure cloud. A very quick intro to John to get things started here. Uh, John is the, uh, uh, is a professor of computer science at Stanford University. He spent before that, uh, 14 years in industry where he founded two companies, cryptics and electric cloud. And before that, 14 years as a professor at UC Berkeley. Anybody here who has taken a class with John before? So a bunch of his students as well. Uh, so he's a pretty distinguished or I'm not going to go through a list of his, uh, awards here. A member of the National Academy of Engineering got a ATM software system about a UC Berkeley distinguished teaching award to name a few here, a but more relevant to this talk.

Speaker 1:          00:01:02       John has built several influential systems. The sprite operating system tickled TK log structured file systems laugh, uh, and more recently a ram cloud. And, uh, and I think, uh, his bio says he has literally created like thousands of programming, student assignment and, and, and today we are going to hear the synthesis of all of John's firsthand knowledge, both from this research and teaching on a topic that's very close to us. How to, uh, how to design and how not to design software. Uh, there is a book here, I don't have it to show. Uh, can I, let me show it to the camera here. There is a book, a philosophy of software design numb. I, uh, I was pretty lucky to lead the pre print of this. It's a really good book and a, and hopefully he'll tell us a little bit more about that as well. And the last note, if you have questions, since this is being recorded, just raise your hand and we'll get the Mike to you and then you can ask questions. So welcome John.

Speaker 2:          00:01:57       Great. Thank you.

Speaker 3:          00:01:57       [inaudible]

Speaker 2:          00:02:03       first of all, I do not have an hour's worth of material prepared because there will be lots of questions. I'm happy to take them in line as we go. At some point, probably there'll be too many and we're running late, then I'll, I'll cut them off. But feel free to ask questions, you know, express a disbelief, argue, insult my mother, whatever you wish during the talk, but, but do make sure that the insults were on the mic. Okay. So people have been programming computers for more than 80 years now. And yet software design is still basically a black art. There's essentially no agreement on how to do software design or even what a good piece of software it looks like. You know, we talk a lot about software engineering and software tools and testing and processes, but we have almost no conversation about the fundamental act of designing software.

Speaker 2:          00:02:49       This is bugged me for a long time. So today I'd like to tell you about some things I've been doing to try and change that to start the conversation and to see if we can somehow create a more, a greater sense of design awareness in the software community. And that consists of a new course I developed at Stanford. And then based on that, a book on software design. Okay. So let's start with the basics. If you had to pick one idea, one concept fits the most important thing in all of computer science, one thing that threads through every aspect of computer science, from AI to systems to theory. First of all, what would you pick? Abstraction, sorry, testing or their ideas. Sorry, composition.

Speaker 2:          00:03:33       Sorry. Complexity. So I asked Don Knuth this question. He said layers of abstraction, which I would say is almost right. Although some would say by definition it's right. What I would say is problem decomposition. How do you take a complicated problem or system and chop it up into pieces that you can build relatively independently and yet, as far as I know, aside from what you're going to hear today, there is no course anywhere where that concept is one of the most important ideas in the course. We simply don't teach it. Second, we all know that some programmers are way, way more productive than others. Google, this coined the term, the 10 x programmer, and yet as far as I know, no one attempts to teach these skills either. And these ideas have been sitting in the back of my head and bugging me for a long time. How can we have these things that are so important? And yet we don't really make any attempt to teach people this stuff? You know, if you're a great programmer, somehow you've just figured out on your own.

Speaker 2:          00:04:39       So that leads to the question, can we do this? And there's three questions there. First isn't even possible, you know, is it, is this just an sort of innate skill that you're born with in your genes or is it something that can be taught? So first, let's do a quick survey. How many of you think this is something that's it's, you know, either you have it or you don't. You can't really teach it. It's just an innate skill. How many think that this could be taught in some way or another? Good. A few summers ago, I read a really great book by Geoff Colvin. Title talent is overrated. If you want to fund read Redis and are relatively quick read in which he goes through study after study that shows in these fields where we think of some people as being tremendously talented. In fact, the only thing that really differentiates the top performers from the average performers is how much they've practiced.

Speaker 2:          00:05:30       That's the one consistent correlating factor they could find. It's all about practice. So that got me thinking. I mean I believe it's got to be possible to teach this, but the second thing is who's going to do it? Well, unfortunately not most of today's faculty, the problem is typical faculty member writes a little bit of code is a Grad student never really gets any instruction. You throw out some crappy code for your dissertation and then you become a professor and then you decide coding is what graduate students do. So you stopped coding and you never write any more code. And so, uh, you know, the only way to become a great developer and learned design skills today is with tons of personal experience or trial and error. Faculty don't have that, so they can't teach their students. And so the whole process just continues over and over and over again.

Speaker 2:          00:06:17       But, uh, fortunately I'm not one of those faculty members, so maybe I have a better chance of doing this. So personally I love programming and the programming is one of, it's really one of the top two or three things I live for. You know, my family programming really bad golf game because I've fit a few things, like the things that drive my life. But if I don't write 5,000 lines of code a year, at least I feel like it hasn't been a great year for me. So I had over my career, I've probably written I think now 250 to 300,000 lines of code. So I had a chance to observe a lot. And again, as I've been doing it, I've been thinking about design stuff. So, so I thought maybe, you know, if anybody can do it in academia, I probably got about as good a shot as anybody.

Speaker 2:          00:06:58       And then the third question is, well, how do you do it? So I combined all these two threes, three things together. I finally decided only one way to find out, I'm just going to have to try it. You know, maybe I'll crash and burn, but I'll give it a try. So I created a new course at Stanford [inaudible] software design studio. It's not taught like a typical production course. It's taught more like the way you've learned English writing in high school with an iterative approach. So you know, in the way of their writings, you write something, your teacher marks it up, you get it back again, you rewrite the market up again. And so on of the whole process iterates several times. And it's that process of getting criticism, incorporating the criticism and learning and seeing how that makes things better. That's how you become a good writer.

Speaker 2:          00:07:41       So I thought we'll try the same idea in the class. And so that's the way it works now. Only have 10 weeks in a quarter system. So we could only do three iterations of this cycle. But the basic way it works is in the first couple of weeks of the course students in teams of two bill Volare just system they can possibly build in three weeks. That's typically about 2000 to 3000 lines of code. So you know it's still not not a huge system. Then after week three we go into code review phase that students read each code and write reviews and read every single line of code written by all of the students. This is sort of one of the limitations of the class right now, so I ended up reading 20 to 30,000 lines of code and that that week and then we do re code use in class where students will present pieces of their project and other students will critique it and then I do longer code reviews.

Speaker 2:          00:08:32       I read everybody's projects. I typically make 50 to a hundred comments on every team and then I meet with the teams individually for an hour and go over it with them. Then the second phase is they revise based on the code reviews. They actually add a little bit of additional functionality as well. And the second phase we do another round of code reviews and then the third phase they get a new project. They start from scratch again and we defined the do a third round of code. It is, and when they do this, the students get no ideas for me that how do we design, I just tell him what the system has to do. They have to start from scratch and figure everything out themselves. So they make lots of mistakes in the first phase, but, but that's part of the learning of the class. Got another question. Mike's coming here.

Speaker 3:          00:09:12       Okay.

Speaker 4:          00:09:13       What's your youtube video of the same topic you gave in that one? Phase three it was past the project took personal, the left and inherit someone else's code. Why did you change it?

Speaker 2:          00:09:23       Yeah. The first two times I taught the class, I actually scrambled the projects and the third phase and made people add on to somebody else's project. That was a good learning experience. But the problem is people end up spending a lot of time decoding other people's projects and being frustrated with it that that has some value. But they didn't spend as much time doing real design stuff. And so I finally decided if what I really want us to teach people design, I think they'll learn more if they get to start from scratch and do a new design project. So I change it. Then I made a change back and I'll try this for a while and see what works. Okay, so that's the basic idea of the course. Now you may be wondering, but so one of the magic secrets has, how do you do software design and, and by the way, what makes me think I know what the secrets are.

Speaker 2:          00:10:09       So first of all, I don't claim to know all the answers. I have some ideas that have kind of coalesced in my mind over the years, which I'm using in the course. And the book, I don't claim those are the end. Actually. I'm hoping more to use those to start a discussion and evolve them over time. But in the class there's about 10 high level ideas. They're very abstract, almost philosophical. Uh, I can't give you a recipe, you know, follow these 10 steps and you will produce a great design. I'm not sure that there is such a recipe. So instead of these vague ideas that I talk about a while, students are doing their first round of design, I'm not sure they sink in very well because they're so abstract. It's sort of probably hard to figure out how to apply them the way they work best. So that was one way to do the code reviews. Then I can show the students how they violated some of these principles and what the consequence was in their code and how they should change it. And then you can go back and apply the principles as they revise and then then I think the ideas start sinking in. So it's, it's sort of a question in backyard.

Speaker 4:          00:11:19       Yeah. I, I'm curious what you think about, uh, how does the sort of end to end principle and um, in sort of a sophomore design factor into this in terms of trying to push all the complexity to the edges of the system? Like the typical example of TCP, the check sum is at the, you know, is done end to end. It's not in the intermediate Roger stages. Um, and that was a design principle that they had. Uh Huh.

Speaker 2:          00:11:43       I think about that. I'm not sure that relates in a direct way to these principles, but I'll have to think about that so that these vague principles. Then the other thing I try and do is talk about red. So red flags are very specific things that if you see this sort of behavior or or pattern, you're probably in trouble. And actually I think for beginners in particular, red flags are really useful to people because even if you don't know how to design the right system, if you can see you're going wrong, then just try something else until eventually the red flags go away and you'll probably end up in a pretty decent place. So, so red flags are really, really more a very useful. So what I'd like to do is I'm going to talk about the four things that are in red, just to give you a sense of some of the ideas. Two of them are designed principles. Classes should be deep to find errors out of existence and two of them are more about mindset. I'll talk about those.

Speaker 5:          00:12:33       Okay.

Speaker 2:          00:12:34       So the first one is this notion that classes should be deep. This is really just another way of thinking about this idea that David, partly I of information hiding the David Parnas first put out in a paper and early 1970s. Uh, by the way, to me this paper is one of the two most important classic papers and all the software design and engineering it. Has Anybody here read this paper and classes? Great. It's still topical and relevant today. The last third, maybe not so much so, but the, the first part still in, we've got a great example and easy to read. So the way I think about it, think about a class as a rectangle and the area of the rectangle is the functionality of that class provides. So you can think of that's the benefit that the class provides to the rest of the system.

Speaker 2:          00:13:19       Then think about the top edge as that's the interface to the class. And by interface I, I mean everything someone has to have in their mind in order to use that class. It's not just the signatures for the functions, but things like side effects and dependencies and things like that. That's really the cost you think of. That's the complexity cost that this class imposes on the rest of the system. So we'd like that to be as small as possible. So ideally what you'd like is the greatest cost, sorry, greatest benefit, least cost. She was like the smallest interface and then the largest area. So the opposite of that, I call a shallow class. So that's something that has either not a whole lot of functionality or really, really complicated interface or both those classes, they just don't give us much leverage against complexity. In fact, in the worst case and the worst case, the additional overhead of the interface adds more complexity than what you've hidden underneath the interface. Instead, it's a net negative.

Speaker 2:          00:14:21       Well, we'd like to have, of course, the other side is a deep class, very simple interface with a very large amount of functionality underneath it. I mean, that's another way of thinking about abstraction, right? The idea of abstraction is we're trying to provide a simple way of thinking about something that's actually quite complicated underneath. So deep classes are good abstractions and this notion you can apply it to classes, you can apply it to methods within classes. You can apply it to interfaces in general or modules and the systems or subsystems. Anything like that that has an interface or implementation.

Speaker 5:          00:14:54       Yeah. Question, because

Speaker 2:          00:15:02       it seems important to give at least a few hints. The beginning, this is what I give them before, well, as concurrent while they're doing the first project, we don't have enough time for me to go through all the ideas before they start designing. So while they're designing, we're talking about this stuff in class.

Speaker 5:          00:15:18       Okay.

Speaker 2:          00:15:18       Here's a classical example of a shallow method, which I have to say I see distressingly often various essentially no information hiding and this method, in order to use it, you pretty much need to understand the complete implementation. And by the way, there's almost no implementation there. In fact, this is so bad that it takes more keystrokes to invoke the method then if you just did the body of the function yourself. So it's basically a complete loss. Just adding complexity and getting nothing back for it.

Speaker 5:          00:15:51       Yeah.

Speaker 2:          00:15:51       Another example of a, actually have a relatively shallow class. I see all the time as a class for list manipulation. This is very shallow. I mean lists are really easy to manipulate. It's two pointers. We didn't know. We know the pointers are hiding underneath there someplace anyhow, and so that's a, that's a very shallow class. Now you can't always eliminate shallow classes. You know, sometimes you end up with the best you can do is a shadow class. So I wouldn't say you should never ever have them, but a shallow class doesn't buy you much. From a design standpoint. It doesn't help you in the fight against complexity.

Speaker 5:          00:16:25       Okay.

Speaker 1:          00:16:29       See, I think one thing that is perhaps a bit subtle is that the size of the class is not the amount of code that is in it right now. It might be the amount of code that he eventually have to add or if you have to have multiple implementations of it. Right. So maybe this doesn't make sense in isolation, but perhaps there is something else which is there another implementation if it is maybe right now or in the future, which is going in storing stuff in a database or something like that. And so I kind of wonder if you disagree with that characterization that you need to keep track of the evolution of the class in mind when deciding on its depth.

Speaker 2:          00:17:07       Well, I agree with that. In fact, the whole idea behind the software design is we're doing things for the future. It's, we're doing things today to make it easier for us to develop in the future. And so you have to think a little bit ahead. Although question under, the classic problem with software is we can't visualize the future very well. So it's a dangerous to try and think too far ahead. But I agree with your concept in general. In this particular case though, the problem is that the interface was already so specialized that there's just probably not a lot of room for wiggle reminder that there are almost certainly anything you've changed or the implementation is probably also going to change the interface. And so again it, it, it's probably not going to help you, but you know, if you have reason to believe that we'll know.

Speaker 5:          00:17:46       Yep, Yep. Sure.

Speaker 2:          00:17:50       So the problem that leases, and by the way, I think this was one of the biggest mistakes people make too many, too small to shower classes. And the reason people do that is because they've been taught classes and methods should be small. How many of you at some time in some courts were taught your methods should be small? And how many of you have been given a number, like any method larger than an lines you should chop it up. How many of you have heard something like that said, okay, what's, tell me a small value of n you've heard 20 does anybody heard 10 I heard. I've heard 10 sometimes. So if you take this to the extreme, this results in what I call class situs class. Situs is when somebody says classes are good and somebody else thought what they heard was more classes are better and so in underclass hide is your goal is to have as many small classes as possible where each class adds the tiniest possible amount of new functionality to the previous classes.

Speaker 2:          00:18:56       If you want more functionality and that make another class for it. That's probably the best example of this and the world today is the Java Class Library. There's nothing in the Java language that requires this, but somehow this has just become the culture in the job of world. These tons of little tiny shallow interfaces like for example, I think that just bugged me about Java when I started partying. If I want to open a file and read serialized objects from it, I have to create three objects for that. First I have to create this file stream, but for some reason I don't get buffering. I'm going to fast. I want buffering. It's like, do you want to eat today? If I'm buffering, you have to create another object. And then if I want to see read serialize objects, you had another object on top of that. Each of these could throw exceptions that I have to catch it and they can, exceptions can come halfway through and have to clean up enormous amount of complexity for something that's really, really simple.

Speaker 2:          00:19:47       So I think they lost sight of the idea that first of all, in managing complexity, the common case matters a lot. You want to make the common case really, really simple. I shouldn't have to do all of this, you know? Okay, maybe I want to be able to not have buffering, but that should be an option that, you know, if I don't want buffering, that should be worth things get more complicated. Not, I have to remember to ask, especially for Bufferin. So to me it's not about length. Length is really not the fundamental issues. I don't have problems with methods that are hundreds of lines long, if they're relatively clean and if they have a, if they have a deep interface to them, it's abstraction. That's the most important thing. So rather than striving for length, you should first try and get these deep abstractions.

Speaker 2:          00:20:25       And then if you end up with something that's really big and long and then see if you can chop it up. But depth is more important. So what's an example of a deep interface? My favorite in the world, probably one of the most beautiful interface ever invented is the unix file io interface. Five functions falling over easy interfaces to every function. The only complexity is the, the flags and the permissions for opener a little bit funky, but everything else is very, very simple. And then think about what's hidden behind the simple interface. There's typically a hundreds of thousands of lines of code behind that that do everything from managing disk space to file caching to, you know, device drivers that enormous amounts of code and of course many other lower level interfaces behind this. But just this amazingly beautiful five functions. Now today, people look at this and they go, well, Duh.

Speaker 2:          00:21:18       Of course that's the way you design things, but it was not like this is anybody in this room actually programmed at the round the time Unix came out, only a few of us are old enough to have done that. Things were pretty horrible before that. Like for example have been pre unix file systems. There'll be a totally different set of kernel calls if you wanted to open a file for random access versus sequential access to different sets of critical different kinds of files, you have to declare your file random access or sequential when your units just had this amazingly simple interface. It's only a beautiful example. Okay, let me go to my second design principle, which is define errors out of existence. So we all know that exceptions are huge source of complexity in systems. For example, in the ramp cloud storage system, we thought we were building a low latency storage system figured out we need to be spending all of our time making things really fast and low latency.

Speaker 2:          00:22:17       But in fact 90% of our time went into doing crash recovery. So they're, they're a huge source of complexity. And the, again, the common wisdom kind of leads people astray. You're taught to program defensively just good. But people then think, I should be throwing lots of exceptions. The more exceptions I'm throwing, the better defense I'm doing. And as long as I building my module, catch all the errors and heave them up in the air is exceptions. I don't have to worry about where they land or who's going to deal with them. I've done my job effect the more than my throw the better program where I am. But then that just results in this explosion of exceptions that have to be caught and handled. And then the exceptions themselves create more bugs in a secondary exceptions and so on. So I would argue in general overall we should try to minimize the number of places where you have to handle exceptions.

Speaker 2:          00:23:08       You can't completely eliminate it, but try to minimize that. And the best case of all, which I found you can do surprisingly often, is simply to redefine the semantics. So if there is no error is no exception at all, that's the best. It's just gone completely. So let me give you three examples of that first one. When I was designing the tickle scripting language, many years ago, I introduced an unset command, which deletes one or more variables. When I was doing this, I thought that by the way, this classic mistake people, I thought, why in their right mind would anybody ever deleted variable that doesn't exist? That makes no sense. So I'm going to throw an exception for that. Well, it turns out people do that all the time. Uh, for example, you're halfway through a computation and you decide you just want to bail. So you want to clean up all the mess you might've made.

Speaker 2:          00:23:57       So you go through and delete every variable that you might have created, but you don't know which ones you actually got around to creating yet. And so some of them don't exist. So in practice, people complain about this all the time. And in fact, if you look at tickle code, I bet virtually every invocation of the unset command is wrapped in a catch command that will catch the exception and throw it away when it happens. So what I should have done, in fact, I, I don't know why I didn't fix it, once I found the problem, that was my second mistake. What I should've done was redefined the semantics so that unset makes a variable not exist. And if you think of it that way, oh well if the variable doesn't exist already, we're done clean, no harm, no foul. And so that's what I should have done, should not have thrown that exception.

Speaker 2:          00:24:44       Another example is file deletion in windows, at least in the early days, if you tried to delete a file when some process had the file open, that was not allowed. Anybody experienced this and the bidding used windows experiences. It's this horrible thing and then now you forgot, okay, who's got it open? And you start going around and killing programs to try and make it good, delete the file and you can't find which program has it open so fine. You just give it and you reboot and then it turns out and then it turns out that it's a system demon that has the file open. So when you reboot, it's still in use. You can't delete. So eunuchs had as a beautiful, really lovely solution that makes this error go away. In unix, if you delete a file while it's open, what happens is it deletes the file from the directory from the namespace.

Speaker 2:          00:25:33       It no longer appears anywhere in the file system, but the actual contents of the file still hanging around so that any process that's using the file can continue to access the file. And then when the last open instance of the file is closed, then find that cleans up and throws away everything else. It's a lovely solution because you could have made the other mistake, which is that I'm going to delete the file and now anybody doing Ohio on the file gets an error. That would probably be even worse because now every program would have to be written to handle the case where the file goes away in the middle of you're accessing it. So you're just had this beautiful solution where there's no errors on either side. It's just it just does the right thing. So when does the eventually realize this was a problem and I don't know where they are in the evolution of fixing it, but I know that the first stage they did is they had some special flag you could set, let's say delete the file, even if it's open or you could, maybe we open the file, then you can allow it to be deleted while it's open.

Speaker 2:          00:26:26       But they didn't get rid of the directory entry. They kept the directory entry around and so you couldn't recreate the file while it was open. So if you were, for example, trying to rebuild and the, you know, the binary was unused, she couldn't, you couldn't modify the, couldn't create a new version of the binary file because that directory entry was locked down, they still didn't get it right. So again, examples of why you just want to make these arrows go away. A third example, which is people often considered more controversial when I say this one is substrings. That's when Java, there's various methods and we'll extract a sub string out of a string. And these methods are very exception happy if either the indices is outside the range of the sub string and throws an exception. And I believe if they were kind of out of order, throws an exception, I find this huge pain.

Speaker 2:          00:27:11       I ended up typically having to write my own code to effectively clip my indices to the range of the string before I invoke the Java substring command. So I won't get these exceptions. Yeah, I consider this just a bad idea. Instead, it was so much simpler just to find some string so that it returns the overlap between the indices you've specified. And the available contents of the string. So if both of the indices are outside the range of the string and returns the empty string, you know, if they're in reverse order, clearly there can't be anything in the right order, it doesn't return and just does the clipping automatically. This would eliminate so much extra code people have to write. And also I suspect a lot of runtime exceptions that occur because people forgot to clip their indices to the range of the string before they invoke the command. So again, the overall idea here is to try and reduce the number of places where people have to deal with exceptions. The, the book talks about a few other ways of doing this, but the best case of all is just to define the exceptions away. Just make the normal behavior always do the right thing. And nobody's objecting on the Java subject. Usually somebody raises their hand and objects to that.

Speaker 3:          00:28:20       Yeah,

Speaker 6:          00:28:23       yeah. So not an objection, but a defining to the semantics perhaps is a more complete definition. I mean you, you could simply say, okay, whatever, whatever set of parameters you pass. A, you have a random behavior that are difficult to explain. But the examples you gave were very, very intuitive. Like when you define the overlap between the indexes and the available space or a, the tcl, et Cetera,

Speaker 2:          00:28:47       somebody want to argue that the Java sub string shed thrash options.

Speaker 3:          00:28:51       Microphone on here.

Speaker 2:          00:28:55       I know some of your thinking it. Sorry.

Speaker 3:          00:28:57       Okay.

Speaker 6:          00:28:59       Uh, it should, it should. I think it should throw runtime exception because like you can't, uh, it, uh, sometimes it could be just the wrong assumptions on client's side. Like they just done something wrong and they're, they're assuming that's correct range, but it's not, I think it should be run time exception.

Speaker 2:          00:29:18       This is part of the philosophy about we're going to try and keep you from making mistakes. Sorry, which it's a kind of a noble father. But the problem is that it's really hard to keep people from making mistakes. And so typically what happens when we try and do this as we introduced lots of complexity, which makes it hard to even do the right thing. And so I had in general, we want to make it really, really easy to do the common case, the right thing. Uh, we should have, yeah. Did you still have to do testing to catch mistakes? And so this isn't going to replace the need for unit tests, but in general, I think when you try and build systems that can keep people from making mistakes, you're usually create a whole lot of complexity for everybody.

Speaker 7:          00:29:55       So how do you distinguish between Java substring versus Java Dot. A string dot character at index? Should that one exception?

Speaker 5:          00:30:04       Yeah,

Speaker 7:          00:30:04       if the next is out of range,

Speaker 2:          00:30:07       good question. That one probably should because you can't really return a character, you know, what do you, uh, if you know, you could redefine a kind of, like I triple e 14 point did, where there were special values that represented the arithmetic errors and things like that. So if you have some sort of a no character that you couldn't return, that might make sense. But we don't really have that in our character sets. So, so in that case you really can't, I'm not sure what you would return if you're going to return something. So in that case you probably do have to throw an exception.

Speaker 5:          00:30:38       Awesome.

Speaker 7:          00:30:40       So one question. So when is it a good idea to actually throw exception? So they're intuitive cases. You want to eliminate exceptions as much as possible. Then how do you decide? No, I, there's nothing that I can do. My changing semantics doesn't work and I really have to throw an exception though.

Speaker 2:          00:30:54       Well, if you fundamentally can't carry out your contract with your color, if you can't implement your interface, then you sort of have to throw an exception. You know, like if you're reading frank doing a read operation and the re can't succeed because you've got an io error, you have to, that's information that you, you do have to reflect that back to the color. So you can't eliminate all except you know, some of the students in the class thought this was really a great idea and something basically you wrote no exception handlers when they were calling, cause I'm just defining them out of existence. I said, no, no. Some of them actually matter. You have to. And then a lot of software design I think is what matters and what doesn't matter. And ideally you'd like to make as little matter as possible. You'd like to be as to not depend on very many things, but you have to recognize the things that really are important and do matter.

Speaker 2:          00:31:36       And those you do have to reflect in the system. Yeah, yeah. Uh, do you have thoughts on exceptions versus extra status code or extra error code returning? Boy, that's a classic argument. Exceptions versus returned values. Now there are times when each makes sense. I believe exceptions actually provide the most value when you throw them farthest, if they're going a long way up the stack, that's where they provide the biggest benefit because you've made it unnecessary for a whole bunch of intermediate layers to deal with the situation. You can take it all the way back to the source and, and deal with it at the source. If you are catching exceptions and methods you call, you know there's not as much value for that compared to just getting a return value. It's not, it's not a whole lot different. And one of the problems with exceptions also they have, they all have clunky syntax and actually checking your return value is actually simpler syntactically than declaring an exception handler.

Speaker 2:          00:32:31       But, but you know a lot of times some of these exceptions you really will want them to propagate along ways. And so then even if the color is gonna gonna look at, you probably want to manifest it as an exception rather than return value and salt on crushing as a way of like avoiding good pricing. Good thoughts on crashing as a way. Yes. Yeah. Yeah. Actually crashing is a fine thing to do in certain situations. Like for example, in most programs I would argue you should not be trying to come out of memory exceptions. It's just hopelessly complicated to try and do that cause they're your depends so much on memory that for most applications if you want to have a memory of just crash, I mean print the message and crash. It almost never happens. Machines today have tons of memory anyhow. I think, Eh, you know, again, use with caution, but I think there's situations where just crashing as a fine thing, find a way to do it. It's that the alternative would create so much complexity that you probably wouldn't get it right in the first place and it doesn't go crashing anyway.

Speaker 1:          00:33:26       He, John, not this 17 cushions on the duty, so I'll just ask the top ranked one so that we don't run out of time. The question is from [inaudible] and I'm in the life development is often under various constraints. For example, tight. Could you need to experiment and be flexible about design, lack of Mitchell tools, library, et cetera. Uh, does your approach to software design philosophy change based on real world constraints?

Speaker 2:          00:33:49       Uh, yes. And actually that's a good leader. Let me move on to the next part of the talk, which I'm going to talk about that and I think I want to keep moving to, cause we're, we're starting to run a little tight on time. What about a couple of specific techniques or philosophies you can use, but I think one of the biggest obstacles to good design is mindset. Don't have the right mindset and you will just never produce a good design. I think there's two ways of approaching the program or design process, which I call it tactical and strategic. Unfortunately, most people take the wrong approach, which is the tactical approach, the tactical approach. Your goal is to get something working, you know, your next feature, fixing a bug, whatever, but that's your goals. Get something working. So you think, how can that be wrong?

Speaker 2:          00:34:36       That's isn't that the whole goal of building system? We want them to be working well. The problem with this approach is that when you do it, then you usually have the mindset that, well, I'll try and make it mostly clean, but if I have a little, if I had to take a couple of, you know, shortcuts are a little bit of clue just as long as I know to too many of them. If I get it working, that's what really counts. Uh, the problem with that is that those Kluge is build up really fast because not only are you doing it, but everybody else on your team is doing it. And then after awhile you start seeing, oh, I probably shouldn't have made that decision back there, but we've got our next deadline. We've got to hit. Uh, you know, I'll try and find time after that, that deadline.

Speaker 2:          00:35:15       But then by the time the deadlines done, you've introduced so many coaches, you realize that's going to take weeks to fix all of these and you don't have time for that. And so it just never happens. So the result of this inevitably is the system turns to spaghetti really, really fast. Uh, and the problem is that complexity isn't one mistake you make is not a single thing that makes us just some complicated, it's hundreds or thousands of mistakes made by many people over a period of time. And so, uh, so that means, first of all, you don't notice it as it's happening because it's just a bit at a time. But then even worse once it's happened, it's almost impossible to fix because there's no one thing you can go back and fix to fix the problem. It's thousands of things and Tundras of places and so it's just so overwhelming and never get to it.

Speaker 2:          00:36:01       So by the way, there's an extreme of the, the tactical programming person sort of personality type I call the tactical tornado. This is a person who turns out enormous amounts of pretty shotty code that kind of 80% works at a huge rate and leaves a wake of destruction behind them. And in many organizations, these people are considered heroes. This is who management goes to when we need the new feature for tomorrow. And they'll have a feature tomorrow that works for most of the day tomorrow. Anyhow, in fact, actually I want to give this talk. Somebody said, oh, is that what you mean by the 10 x programmers?

Speaker 2:          00:36:41       No. No. How many of you feel like you've been in the presence of one or more tactical tornadoes over your career? Yeah, every organization has them. I'm sure they're here at Google and unfortunately one of the things I hope to do is to provide a name for this so we can start calling them out and maybe educate management about how many of you feel like your management actually rewards tactical tornadoes. Yeah, that's even worse unfortunately. So, you know, the tactical approach is really, really easy to slide into. Very hard not to do that. But so the first thing you have to realize, if you want to do great design, you have to realize working code is not enough. That can't be the only goal. It's so table stakes. Of course things have to work, but that shouldn't be the real goal.

Speaker 2:          00:37:28       It's that you should take what I call a strategic approach, or the goal is a great design. That's the most important thing. Yes, it's got to work today. But we have to have a great design. Why do you want a great design? It's so that we can develop faster in the future. So it's really, it's really all about investing. Invest in good design today because most of the code we develop is going to be in the future. You know, that's, and so if we mess things up today, we're slowing ourselves down for the future. So you have to think about complexity. Try and find ways to drive complexity out of the system. And fundamentally, this is the hard part. You have to sweat the small stuff and you sort of have to have a zero tolerance approach. Don't let those little bits of lint creep in because if they do, then you're going to slide back into a tactical mode again.

Speaker 2:          00:38:11       You know? So if you program strategically, you're going to go slower at first, but presumably in the end and you'll end up going faster. I mean even with a strategic approach, here's, development was still slow down over time. Cause complexity, complexity is inevitable. We can't prevent it. We can only kind of slow growth as much as we can. But eventually you'll end up going to be faster. So the, the issue is you have to invest. If you're not willing to take a little bit of extra time today at least a little bit, you can't do good design, but in my opinion, it all pays back. You always get your investment back. Now the challenge is what are the parameters of these curves? Like how much slower or do I have to go initially? You know, when do I get to the point where the slopes are the same?

Speaker 2:          00:38:57       So I mean at least now running as fast as I was tactically, when do I actually catch up? So I'd actually have a net gain and then how much faster I go with the end. This unfortunately, I don't know of any quantitative answers to any of those questions. You know, I have opinions like my opinion is that the crossover period is somewhere in the six to 12 month range, roughly how long it takes you to forget about why you wrote that, that last chunk of code. But I don't have any data to back that up unfortunately. So that's the challenge because people, you know, people can see the cost today but they can't really estimate what the bit, when the benefit is going to come or how long in the future it's going to be. And so it's really easy just to optimize for this park down here.

Speaker 8:          00:39:40       Yeah. Just quick question. If you thought of the analyzing open source development and seeing whether or not you can observe this, I mean it would of course some judgment calls.

Speaker 2:          00:39:50       Gotcha. How are you doing? You can look at, look at the rate of commits or the new lines added. But the problem is you don't know how much effort went into those.

Speaker 8:          00:39:56       Yeah. So I think like when you storage device comes out and people were writing new file systems or something, you know, you could look at this across different classes and see how things happened.

Speaker 2:          00:40:05       That's a thought. I, I, it's hard. So the question is how much do you invest? Actually, let me, uh, let me charge for a, for a couple of more slides cause we're starting to run a little tight on time. So how much, what's the right amount to invest in? You know, if you look at most startups, honestly, they're mostly completely 100% tactical. They feel this tremendous pressure to get the products out. Yo, our financing is going to run out in six months, whatever evil we put in with our, you know, when we become famous and wealthy and do our IPO will be able to hire more engineers to clean up this mess. And so you know, they end up with is horrible spaghetti code basis. And unfortunately of course, once you get that it's, it's pretty much impossible to clean it up. I've never heard of anybody.

Speaker 2:          00:40:45       Maybe if you could go back and completely rewrite and you could do it, maybe there have been examples of that, but almost never happens. So to me, uh, Facebook is the poster child for this. They even built it into their company model, move quickly and to break things. And they did both of those. So in a sense, developers kind of like this, a fresh college hires could come in, they're super empowered, they push their first committed that are changing the website. In one week. That first week on the job feels like in a really empowering for them, but their, their code base was just a notorious mess. One summer, a couple of my graduate students went there for internships that came back and they just couldn't believe what they'd seen. And this was interesting because my students had been whining for the whole previous year about why do we have to write unit tests and write documentation and Linux doesn't have any unit tests and Lily's doesn't have any comments. Do we have to do this? I never heard that again after they came back from Facebook.

Speaker 2:          00:41:40       So Facebook has eventually realize this and this, or they changed their motto to move quickly with solid infrastructure. It's like, no, no, I meant to say what? It's not wood. So have you been able to fix it? I don't know. Now people hear this. They say, well, yeah, but Mark Zuckerberg is the fourth wealthiest person on the planet. How can this be a bad? How can this be a bad approach? And Chris, the answer you can, you know you can be successful with crappy code. You can be tactical and build companies that succeed. Facebook has done it, but I have two thoughts on this. One is you can also succeed with the other approach. And although I don't have a personal expense with either of these companies, my sense is that both Google and vmware took a much more stronger design culture approach, at least particularly in the early years.

Speaker 2:          00:42:26       You know, 2000 to 2010 those were the two companies known as silicon valleys. This is where the really great software developers go. They really care about design and they do really good coding. And the reason this matters is that if you have that culture, I think you're in a much better position to recruit the best programmers. And we know about this 10 x phenomenon. You know that the best way to get great products out fast is to get the best programmers. And so I think the strongest argument in favor of a good design culture is that it allows you to hire top people and that will give you an advantage. So you can do things the crappy way if you want, but that there's enough success stories to show that you can make this work. You can do the investment approach, but okay, but then again, okay, but how much to invest?

Speaker 2:          00:43:11       I would say, how much can you afford? And just ask yourself, what's the most we can afford at this stage in our lifetime to invest? I think in terms of maybe 10 or 20% something like that, I bet almost everybody you can afford to go 10% slower today realizing you're going to get it all back. It's not a sunk cost. It's all coming back to you in some, you know, six months to a few years are going to get it all back again. You can afford to do that and I think in terms of small steps, not heroics, you know you can't spend six months and completely designed the whole system from, you know, from first principles before you write any code that doesn't work. We know one of the problems with softwares, we can't visualize the way our systems are going to turn out.

Speaker 2:          00:43:53       You have to use as somewhat interruptive approach. So take I say think of it in terms of small steps. So when you're building new modules, take a little bit of time to design the interface, try and come up with deep classes, right? The documentation as you're going unit tests of course. And then whenever you make changes, you have to realize you can't get it right the first time. It's one of the rules of software. You just, you just can't. So assume every time you're in a system, you're going to have to be improving. Things always look for something you can make better. And one reason for this is you're probably making something worse when you go in also. So even if you just want to break even, you got to find something to improve. So just think of it, I'm just trying to at least break even. So

Speaker 5:          00:44:32       yeah.

Speaker 2:          00:44:34       So, uh, this was against the normal philosophy. I think oftentimes when people are changing existing code, they go for the, what's the smallest number of lines of code I can possibly change to do this? I think sometimes just because they're afraid, I don't understand this. I'm going to break something so I'll make the fewest lines have changed. So I'll just kind of directly access the global variable and other file rather than trying to find a clean interface for it. So don't do that. Try and find a clean way of doing things. And ideally in the best case, you'd like to end up where you would have ended up if you had built the whole system from the scratch, from scratch, knowing what you know today, that's what you're like, is this the way we would have done it if we'd built it from scratch? That's the ideal. Now you know you can't always do that. Sometimes that would be a refactoring is way beyond the scale of what you can do. So again, I, I would just say ask yourself at any, at any given point in time, am I doing the most I possibly can. Don't just give in and say, hey, the boss says we've got to get a release out tomorrow. So I'm just going to hack this thing in and make the boss happy. Ask, is this the best I could possibly do?

Speaker 6:          00:45:36       John, you didn't touch on Leering, which is often considered very good in software engineering, but it also has a challenge of performance of the code. When it executes. Often the functionalities are replicated in multiple layers and it's not clear how to distill that without mucking up the coat.

Speaker 2:          00:45:56       Uh, so what's your question now? Our layers. Good.

Speaker 6:          00:45:59       Yeah. So how do you deal with less demand for abstraction layers and the demand for performance? Both contracts,

Speaker 2:          00:46:05       but like we need layers for managing complexity. So in that sense they're good. They do have problems for performance. I think people do too many layers. I think so. Uh, I think that's a common mistake is to throw in lots of skinny layers again, rather than having a smaller number of meteor layers. That's one problem. The other thing is that fourth cases where performance matters. If you think a little bit about what your key performance metrics are, I believe you can often define your layers in a way that allows you to achieve very high performance even with layering. But you have to be thinking a little bit about the, at least the overall kind of gross level performance metrics while you're doing your system design.

Speaker 2:          00:46:44       Okay. So anyhow, I think, I think this investment thing is the biggest challenge particularly because a lot of managers I think don't really get it and they're pushing for the next feature, the next release and I don't know how to combat that except except to half the people that everybody recognizes that the great engineers in the company go to management and try and get management buy in. And I think it'd be great if companies could have sort of explicit, this is in our engineering philosophy, we will invest that sort of 10% we assume it roughly on average 10% of our resources are going towards making designs better, not just cranking out next features that, John,

Speaker 6:          00:47:15       I have looked at this for 20 years now, but the quantitative analyses that you're describing where the domain of the software engineering community for awhile, I wondering if you sort of poked into that space to see if they have a experimentation numbers, analyses that might be useful

Speaker 2:          00:47:30       or have they just dropped off the map? I haven't looked very carefully at partly because I'm sort of skeptical that it is possible to measure it in a meaningful way. So I haven't, but I would love to see numbers if there were some more believable, but I haven't looked enough to know. Okay. So, and just have a couple more slides and open up for questions. So is the course working? Uh, you know, it's hard to tell for sure. I mean, you can't become a great program in one quarter. It'll take still lots of experience for these people will have to come back and ask them once they've been out in industry awhile. This is just the sort of the first step in the process I think. But the class has a really fun energy to it. Really Fun. Then the students start off in the first round of code reviews and they're very tentative, kind of afraid to criticize each other and not really sure what they should be saying.

Speaker 2:          00:48:12       Uh, so the, the first rounds kind of tentative, then they meet with me and they get unloaded on and then they started, oh, okay, I can do that too. And so about the halfway through the second code of your, typically the tone of discussions changes where students are now being more critical of each other. Where these interesting arguments in class about whether one approach is more complicated than another. And it's really clear by the end of the quarter that the students are thinking about programming in a very different way than they thought about it before. So that's, I think that's really encouraging. I will have to say though, even if the students don't become better designers, actually I'm becoming a better designer. I'm teaching the class. It's really interesting for me. You know, you might think it's tedious reading 20,000 lines of code in a week, three times over a quarter and it does take some time.

Speaker 2:          00:48:56       But actually I learned a lot from that because the students were all doing the same thing and the same language. And so I can see different approaches and I can see kind of common mistakes that they make. And actually what's ended up happening is I've changed my view about a couple of design issues as a, as a result of teaching the course. And in particular the ones that bottom of the slide was I realized that uh, making classes just slightly general purpose, even though you're only going to use them in one place, actually mix them amazingly simpler and deeper. Hadn't realized that until I saw some student projects sex the second time I was teaching the course. So it's been really interesting for me to to see this and I feel like I'm learning more about the process of software design interest in getting better ideas for how to, how to teach it as I go.

Speaker 2:          00:49:41       Then as I've, as I've talked to people about the course, people kept saying, well, you should write a book on this, and I was on sabbatical last year, so I decided, okay, I will do that. So I have written this book. It's they're relatively small book 170 pages. Again, still fairly philosophical in nature more than prescriptive. So the hope is that I can reach more people because I can only teach 20 people here in the class, can't do more than that and ideally I'm hoping the book will kind of be a lightning rod that maybe we can kickstart a discussion. I hope people write to me and disagree with things in the book or suggest other design ideas or provide better examples. I'm also trying to define terms that people can use. One of the things I hope maybe the book can do is people can use that in design reviews, have ideas and ways of talking about design and design reviews.

Speaker 2:          00:50:28       Actually, I have a question for you. Uh, how many people who do design reviews, I assume almost everybody. Yeah. And how many of you in your design reviews, it's common for you to discuss design issues as opposed to coding style and bugs? How many of the commonly talk about design things? Good. Great. I'd like to see more of that. So I didn't have, the book's been out for a couple of months. Uh, if you read it, have thoughts or comments, I'd love to get your input on it. My view is this is just a first stab. If this actually ends up being a useful book, it'll probably be, it's kind of like software, you know, about version three, you know, we're really hits its stride. I'll need to get feedback and revise and fix things that are wrong and new ideas. So just to conclude, I really believe we can teach sophomore design.

Speaker 2:          00:51:10       I really, I really believe we can. Uh, my current approach unfortunately is woefully non-scalable. I haven't figured that out. We really need somebody with a lot of experience. I think reading the, the students code, I feel like some principals are emerging, you know, if you read the book and agree or disagree with me, I'd be curious to hear your, your take on that one. I hope to do in the future is just to somehow leverage this out into the community. I'd love to see just a greater sense of design awareness in the software community as a whole. Can we have the discussion? Can we make that an important part of our community? It's just sad that we don't really even have the discussion today. So I created a mailing list for discussion topics about the book. Hasn't been much traffic on it so far, but I hope there will be more in the future and I've got to hope to take ideas from people and and make the book better and better in the class better over time in the long, the long term goals be great. If five or 10 years from now we actually have a relatively robust set of principles that most developers agree a good for software design. So thanks for your attention and I'd be happy to take more questions.

Speaker 3:          00:52:14       Yep.

Speaker 7:          00:52:15       Let me get a few questions from the dirty out here. Okay.

Speaker 2:          00:52:20       Okay.

Speaker 7:          00:52:21       Doula testing considerations like unit testing or mocks, influence interfaces and abstractions,

Speaker 2:          00:52:27       testing considerations. Uh, I'm a huge fan of a plumbing unit. Tests are crucially important. I debated whether to try and teach them in the class. Actually I did a little bit at one time in the class, but it was just, it was too much of a distraction for the class. We only have 10 weeks and so I finally decided I needed for the class. I just got to focus on design. So I don't do unit testing in the class, but, but I'm a complete advocate of unit tests. I can't, can't imagine doing software without yelling at us.

Speaker 7:          00:52:52       So it was uh, I was, I was intrigued by your, uh, in the first part of the discussion when you said, uh, in the iterative process you actually dropped, um, have you initially had students build on other, other students code? To me that's a very, very [inaudible] problem and I'm just surprised that you, I mean, I wish you would teach that.

Speaker 2:          00:53:16       I agree with you. In a perfect world, that would be one of the things we do. And the problem is we've got 10 weeks, how do I use that 10 weeks? And I decided I want to try and do the most I can design. And so I just, I have to sacrifice other things. It's the same reason why unit tests and got thrown out because I felt like it was better for them to be thinking about more design issues than then unit testing issues. But I agree with your thoughts completely. Do you have tas for the course? Do we have tas? Yeah, me. Not right now because I, I've just worried that the tas would not be able to give a high enough level of feedback. I've started wondering if maybe students who have taken the course previously could ta, uh, I made so far actually the demand has not been more than my capacity and so I've been able to, to keep it small. If the demand grows, I may try and experiment to see if, if previous course participants can ta. But again, I worry and also for the first few offers, I want it to read all the code myself too because I wanted to learn from it as well. So

Speaker 6:          00:54:19       have you thought about using software engineers as tas? We read and write code every day.

Speaker 2:          00:54:25       Uh, I'm not opposed to it in principle, but I want to make sure students don't get mixed messages. And so particularly because the idea is I'm teaching the course are not ideas that are widely, and that's not necessarily widely spread in the community. Like the worst thing, what happened is if a software engineer comes in and says, no, this method is longer than 20 lines, you've got to break it up. So if, if I could find people that are sort of bought into the philosophy and maybe you know, if the book gets out there and more people buy, maybe we could do more of that.

Speaker 6:          00:54:57       Okay. One question from the Dory, the second highest rated one or threat, still a bad idea.

Speaker 2:          00:55:07       No. One of the interesting things when you, when the only form in which you publish something as a set of slides rather than a paper, which that was, I was just an invited talk and just next conference a long time ago. It's ease. Interesting. People can come back and interpret that at whole bunches of different ways over the years. So that was done in a very narrow context of the time where people were starting to introduce threads for things that didn't even need three as they were doing threading and on machines that didn't even have multiple processors on them. And so that was sort of that talk was a reaction to that. Threads are unavoidable for certain things. You just have to use them but, but they're still, you know, there's sort of the next worst alternative where the worst all sort of made navy in some cases not using threads incredibly hard to program. So I'm still not a fan of threads but they're kind of a fact of life. Yeah.

Speaker 6:          00:55:52       I a question on the tico language. I think the language is uh, uh, a very simple points itself but eventually not gained like larger scope. Who adoption. I want to ask, uh, in you are, because you are the language, a humanitarian like is there like high level issues in the language of design? You think you got it the wrong, which makes it whatever

Speaker 2:          00:56:21       happened to tickle? I think it would be your question. I don't want to diverge too much on that. I would say two things. First off, one of the things chicken wasn't best at was doing kind of simple interactive gooeys with TK. And when the web came along the web basically took that over and tickled did not make the transition to the web. So a lot of things people would have used tickle ticket for, they ended up doing in the web. Second thing is, is it really the right language? I'm not sure in retrospect that it's the right language. I actually, I built it for very different purpose. I built that as a, as more of a textual command language and you'd be typing commands to programs, almost like a shell language. And then I ended up getting used as a scripting language. It has a bunch of interesting properties, but, uh, I don't know if I were doing it again, I'm not sure I would design the same language, but I think that the biggest thing that happened is the kind of the web came along and tickled, did not effectively make the transition in the web.

Speaker 1:          00:57:13       Okay. So, uh, this a lot of really interesting questions both on the Dorian in the room. Uh, in the interest of time I'm going to do two more dirty questions and two more in the room and then now, uh, uh, John is going to stay down and hopefully answer more questions as well. Okay. So, uh, any uh, thoughts on the hiring process? So based on what you've observed and the question has, how would you change the hiring process, which is, so I've got them heavy. Can you share your experience when you ran your company

Speaker 2:          00:57:38       hiring process? That's actually, I'm not trying to release a software design, but I have a very strong opinion about hiring process, which is you should hire for slope, not y intercept I think. I think people when they hire, they do a pattern match of what this person has done. Try and find the person who has exactly done the job we want to do. Okay. I think that's the wrong way to hire. In general, I think you want to hire the person who, the fastest learner who has the fastest slope. I don't particularly care whether they've done the job I want to do because a particular startup, when things change so rapidly, uh, you know, things change. So I look, I look for people who are, they're really smart, fast learners, rather. Also, by the way, the person who has done this job five times before, you sort of wonder, well, why haven't they moved on to the next job? Oftentimes those people have kind of hit their plateau, whereas the person with the rapid slope has the potential. Yep.

Speaker 1:          00:58:25       Last question from the duty. What do you think about heightened slaw?

Speaker 2:          00:58:29       Sorry, remind me of a hieros liars.

Speaker 1:          00:58:32       I googled it and it taste with a sufficient number of users of an API. It does not matter what you promise in the contract. All observable behaviors of your system will be depended on by somebody.

Speaker 2:          00:58:46       Uh, I think there's truth to that. But yeah, over time what happens is that, so the application, they sink, they find every crevice and sink their roots under that they will discover. So, so unless you're very careful with your API Apis, yeah. I think that's probably true. Sad, but true. Hi.

Speaker 1:          00:59:03       Uh, have you observed any change in the simplicity of the complexity of the software design based on the choice of languages and supporting ecosystem?

Speaker 2:          00:59:12       Oh, a good question. Are there some language that's somehow lend themselves to better design than other languages? No, there probably are. I think that's mostly secondary. So second order thing but for example, I'd rather it today I'd rather put them in c plus plus and c because I liked them. The object oriented features and c plus plus. Now C plus plus is sort of a, a big beast of a language with a horrible learning curve. But, but I appreciate the power of it. But honestly I think the design principles are fairly universal. You can use them in any language. You know that that simple file system interface for Unix was done in c with no object oriented stuff and that people that say, oh no actually you notice it's actually object oriented cause it was a file descriptor that gets passed around and the object oriented was really crucial to that. I say no, they just found a really sweet interface. So I haven't found one language that somehow is dramatically better than others for design, but I don't think people have opinions. I'd be curious to hear other opinions about that.

Speaker 1:          01:00:07       So, uh, back to hiring, you mentioned we should hire on slope, northern y intercept and I radically agree. How do I estimate this, measure that, right? Especially, no, I do that. You need at least two points, right? In an interview I get only one and I'm terrified of hiring more tactical tornadoes.

Speaker 2:          01:00:28       I don't know. You know, so I will tell you what correlated best for me, but it's sort of crazy. I found in mice worth people worked out best were the ones where I just really enjoyed my conversation with them during the interview. And that's sort of weird. I feel kind of funny saying that because that means somehow somebody sucked up to me and I liked them and hire them. I don't think that's it because I'm a pretty sensitive meter for suck upness and, and that really pisses me off. So, but, and I don't, and people have also pointed out, but that's if you take that out too, that's kind of a risk. They were just hiring more people like yourself, and so you're not going to do diversity very well. So I have no idea what to make of that or whether it's even a good idea, but that, that's the one thing that seemed to correlate in my experience. Okay. So let's think a John once again, no.

Speaker 3:          01:01:15       [inaudible].