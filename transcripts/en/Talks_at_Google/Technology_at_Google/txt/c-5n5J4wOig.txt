Speaker 1:          00:10          Cool.

Speaker 2:          00:11          Thank you for coming out today and to listen to an old guy talk about an even older computer. Um, we are here to talk about the Enac. Most people in our field, of course I've heard of it. Most people don't know much about what it is. You may have heard it was the first computer or you may have heard it wasn't the first computer, or you may have heard the patent got invalidated because they stole all the ideas. Um, the reality is that, uh, it is a very rich history and it is a very interesting machine and it was a very, very influential machine. Now we're not going to really go into all of the history aspects of it. Today. We're going to talk more technical terms about it. In particular, we're gonna focus on this simulator that I wrote. The, um, the motivation was simply, I wanted to understand how the eniac worked and I felt the best way to do that was right.

Speaker 2:          01:06          A simulator of it, and to get down to as low level as I could get. And so that's what we're going to be talking about today. So let's see if the clicker works. Ah, so this gives you kind of the usual rundown of what the ENIAC was all about. The story essentially is during World War II, as artillery manufacturers are producing new guns, new propellants, new shells, we need to calculate the tables so that when you're in the field, you're not solving differential equations to figure out where to point the gun. You want to have a stable that says, okay, if I'm shooting in that direction, the wind is blowing that way. It's that far away. And the humidity is this, I need to point the gun there. And these tables took a tremendous amount of computation. And of course the way you compute something is with a computer.

Speaker 2:          02:03          Except the thing is that in the 1940s the word computer was a job title. These were people doing computing the US government for both this purpose and for the purposes of code breaking, sought to hire as many mathematicians as they possibly could. Yet with a war going on, of course, all of the young men who had just been studying mathematics work off at the front. So we have this wonderful competition between divisions of the government to hire all of the young woman who had been studying mathematics and they're doing these calculations mostly by hand on adding machines. And one of the researchers at University of Pennsylvania named John Mark Lee came up with the idea of essentially building a machine that was strapped together, a whole bunch of adding machines and he recognized that it would be even faster if you use vacuum tubes. And so this was the birth of the ENAC being a war.

Speaker 2:          03:04          You make a proposal to the government that can help and they say, great, have some money and go do it. Um, whether or not they could have gotten the money in peacetime is another question. But it began in 1943, um, by early 1944 they had some prototype stuff running. By the summer of 1944 they pretty much had it worked out what they were going to do and had turned over a lot of the work to other engineers and technicians for building it. It wasn't until late 1945, however, that the machine was completely finished. So it didn't actually get used during World War II. But interestingly, the first task it took at had was a project that was also sparked by World War II. The Manhattan project at Los Alamos had some heavy calculations they wanted done and so they came out during the winter of 1945 and use the act to do some of those calculations.

Speaker 2:          04:04          One of the interesting points about it that a lot of people will make is that you couldn't program it the way we're used to programming modern computers. You had to rewire the machine to programs. And that was true as it was initially built. But here's the thing, if I can wire a solution to any problem, why can't I wire a solution to the problem of being a CPU? And that's what they did. So in 1948, they implemented a CPU on a traditional in sequential instruction execution CPU. And it was used that way until his retirement in 1945 and 1955. So this is actually going to come back and be something important in a minute. Uh, as you might guess, it changed the balance of performance on the machine quite a bit to do this. All right, so this is the famous picture of the Aniak that was taken as part of the publicity.

Speaker 2:          05:06          This was taken and released in the press release when it was dedicated and announced to the public in early 46. And you can see in the picture that this goes back a long distance into the room. You've got, uh, some people standing around and give you a sense of scale. Um, the whole machine looks something like this. Now obviously this is a bit too small for most of you to see, but if you want to come and take a look at it after the talk, you're welcome to. This is a small three d printed model of the ENAC. Um, and these stand up pieces that the soldiers standing by in that picture or the switch panels that were originally put on for function tables and that's where the instructions were stored when it was later a run as a conventional computer. Right here we have punched card input, an output, the only io on the machine, no screens, no mice.

Speaker 2:          06:03          Um, these are the two guys that really kind of led the project. Uh, the first one that I mentioned before was John Mark Lee on the left. He was a physicist at the University of Pennsylvania and he was very interested in a variety of kinds of problems that were extremely numerically difficult problems. One of his big interest was weather. How do you predict the weather? Well, we know the differential equations for fluid mechanics, but if you're going to do a 24 hour forecast by hand, it's going to take you a lot more than 24 hours to do it. Um, so this is one of his motivators in this.

Speaker 2:          06:45          The fell on the right. J Presper Eckert was a graduate student at Penn when they met. In fact, Eckert was teaching a sort of a workshop on electronics that McCully took and Eckert was, let's face it, an engineering genius. He was one of the top electrical engineers. You can imagine. He invented all sorts of cool ideas and really put it on extremely solid footing. And it was one of the few reasons that machine was successful. Um, we have these wonderful statistics that always get quoted. And the second one on that list, it had about 18,000 vacuum tubes. That was more than anything before it. In fact, when they first proposed the machine, they had proposed a slightly smaller version that we'll have about 5,000 tubes. The government folks went to the experts, mostly MIT, and said, what do you think of this proposal? And the response was, there's no way that machine will ever run.

Speaker 2:          07:50          The tubes will burn out too fast. But Eckert realized the mechanisms that were involved in a tube burning out and was able to design around it, it was able to operate the tubes in a way that would minimize their burnout. And furthermore to extend the usage life of it as their parameters changed over time. So these kinds of design characteristics, really what Eq or brought to it, um, as you can see it had the blazingly fast clock of 100 kilohertz. Okay. Now that's not gigahertz. It's megahertz a kilo. Hertz is 1000000th of a Gigahertz, gives you some sense of the speed of this machine. It took about 200 microsecond student edition. That's why we often will hear quoted the figure 5,000 admissions per second as we're going to see that's not the most accurate way to look at it because it was a very parallel machine. Um, these last three points here. I really love those. Um, being someone who grew up in a world of five volt TTL, thinking about a computer that uses 150 kilowatts of power with 29 distinct power supplies in [inaudible] 78 different DC voltage levels is kind of frightening. Especially when you look at the schematics and all the numbers are three digit numbers. You know, it's like this one's negative 290 volts and this is positive 540 volts. And it's like, okay, I'm used to five volts that I can touch and be safe.

Speaker 2:          09:28          But this obviously was a quite a beast of a machine.

Speaker 1:          09:32          Uh,

Speaker 2:          09:35          the basic architecture of it is consisting of these units. Now what you have, and you may have seen a little bit of this in the picture, are these racks that go around the room. Now they're not quite our standard modern 19 inch racks, but these rocks are roughly two feet wide. So they're a little bit wider than our typical 19 attracts. They're about eight feet tall and there's 40 of them. So if you spread this thing out, you would have a wall 80 feet long by eight feet tall. And each one of these racks is a unit of the machine. It has some functionality relative to the whole machine. And this is kind of an inventory of those units. The bulk of the actual computation is all taking place in the accumulators and that's what we're going to focus most on today. But we also have a high speed multiplier that took three racks.

Speaker 2:          10:31          It was built around good old fashion multiplication tables. The same ones you learned in second grade because it was a base 10 machine worked in decimal. Uh, there was a divider square ruder, the function tables that I mentioned before which were connected to these switch panels and then the interfaces to the io devices, the punch cards. Now this is how the machine was laid out from kind of a top down view and you really can't read it very well. But these are the labeling of all of the units over here. We have the initiating and cycling units. The initiating unit, its primary role was two fold. One was to control the sequencing of power when you started it up and it was also a to sort of synchronize the initialization of a program and the, uh, interaction with cards, both punching and reading. The next unit, the cycling unit is basically the clock. Um, we have the master program where I'll say a little bit about, and then around here are intermixed, the accumulators, the multiplier divider, square reader. And so on. This space inside of it

Speaker 2:          11:50          was 32 by feet. Um, now they rearranged the layout slightly when they moved it to its prominent location in Aberdeen, Maryland. And they had a newly constructed space for it when they moved it, it was one of the few spaces in the area that had air conditioning. So late in the life of the Anyak. People started dragging their desks in there during the summer and using it as office space. You know, no matter how impressive there's still going to be good old human nature coming into play. Um, now some of the things about it that were really unusual from our modern eye is that there was no concept of memory. The way we think about it, we think in terms of the larger ray of individually addressable locations that are reading right, the enact did not have that. The only volatile memory you had available wore the accumulators.

Speaker 1:          12:53          Okay.

Speaker 2:          12:53          So you basically had 2010 digit numbers as your volatile memory. So to kind of think in terms of how it was like programming this machine. Think in terms of restricting yourself to 20 integer variables.

Speaker 1:          13:12          Yeah.

Speaker 2:          13:13          If you can't solve atomic bomb problems with 20 integer variables, you're not good enough to program the ENIAC. Okay. That's a little overstated. But yeah, kind of get the audio. Um, the other big thing about it that I like to point out is how parallel it was. All 20 of those accumulators could be operating simultaneously. So even though a single addition, we'll take one 5000th of a second, you could be doing 20 of them at the same time. So it was a very, very parallel machine. In fact, I love this quote by Lemmer. This was a highly parallel machine before von Neumann spoiled it. And this reference is to the conversion to sequential and instruction set execution because vanadium, and it was actually one of the key drivers behind making that conversion. Lehmer had used the machine for some interesting number theory stuff and had really taken a lot of advantage of its parallelism.

Speaker 2:          14:10          And so he was kind of disappointed when they switched it up. And made it purely sequential. Um, the other thing that I'll point out, and this may not mean much to some of the younger folks in the audience, but this basically is like a data flow machine. Okay. Now if you go back to kind of the seventies eighties timeframe, that was one of the big buzzwords in the industry was data flow and that that was going to save us from all of the problems that we had with various bottlenecks. And it was the new thing. Well it wasn't really all that new because the ENIAC was a data flow machine. And the idea of data for, if you're not familiar with it, is each unit, when it completes an operation, it sends a signal that can initiate the next operation. So in effect, you do an addition, not when the instructions say, but when the two data values that you're adding become available. So it's driven by the availability of the data, not by the instructions. And that's the way the ENIAC was operated. So the parallelism of course is a big deal because I'm trying to understand how the machine works. I'm trying to get a feel for what was it like to program, what were the traps involved for programmers when they were dealing with it? We're all used to the problems involved with parallelism.

Speaker 3:          15:30          Okay.

Speaker 2:          15:30          The easiest way to make a programmer cringe is to say it's a timing problem. Um, anytime concurrency gets involved, we all shut her and, and, and kind of grit our teeth and go, okay, I can get, I can do this. Um, so I wanted to get a feel for what that was like on the ENIAC. Well, obviously if I really wanted to truly get the experience, I would need to build some parallel hardware for it. And while it's still one of my to do list items, it didn't seem all that practical for a first approach. Of course I could just write code, ordinary sequential code. It just sequentially go through each one of the units doing what they do. But I went ahead and decided to kind of take the middle ground and go ahead and use the concurrency we have available in a lot of our languages and to hopefully take advantage of whatever parallelism, the hardware your underlying it gives me.

Speaker 2:          16:28          And so that made it a very natural fit for uh, the go routines in the language go. Um, you know, of course I could use conventional p threads or something like that, but, um, it goes model is quite clean and uh, I liked the idea of having the portability that it would also give me. So that was one of the motivating factors there. So what happens is each of these units in the machine is simulated by usually to go routines that are operating in parallel. And the way that works is the two routines are handling different sets of input. Now to give you a little bit of sense of what we're getting at here, remember we said You rewire the machine to program it.

Speaker 3:          17:16          Okay.

Speaker 2:          17:16          So that means that if I want this adder to be adding a value that comes from over here somewhere, I've got to have a cabling connection that brings the data from the source to the destination. That data as it's coming in over some kind of a terminal on the destination is just going to be a sequence of pulses. And so these pulses are the inputs to the units.

Speaker 3:          17:43          Okay?

Speaker 2:          17:44          There are pulses that indicate begin an operation and then that are pulses didn't indicate data. Those are the controlling data pulses that go into one of the go routines. That routine doesn't do very much except set some state variables for the unit. Kind of represents the internal flip flops of the unit and in fact, if you go through and read some of the technical documentation and you look at the source code, you'll see a few places where there are variables that are named after certain circuits in the uh, original. The other go routine is taking the input from the clock, which is another series of pulses. Originally, I implemented this as one routine per unit and I realized I had a little bit of a problem because the result of a clock signal could turn into a control signal that I would transmit that would come right back into one of my other inputs and unless my communications channels had some buffers in them, I would have deadlock and if I put buffers in it, how can I be sure that things were synchronizing the way they were really meant to. So I went ahead and split into two the two units for that reason.

Speaker 2:          19:04          As I said, that pulses are transmitted. Now this is another bit of Eckerd's genius. He said, I'm going to make all the pulses the same control pulses, data, pulses, Kwok pulses. They're all going to have the same shape, the same characteristics.

Speaker 3:          19:25          Okay.

Speaker 2:          19:26          The idea is that there's no reason I can't use some data as a control signal

Speaker 2:          19:33          and when you open up that possibility, you get the possibility of conditional co flow of control and that's what makes it touring complete. So those fit very naturally into a channel model of communication. In fact, the way it's set up is that messages over the channels represent pulses. In the case of the control lines where there's only one signal being transmitted for a given line, it's just a one or a zero in the message. In the case of data, the terminals are actually 11 lines. You've got 10 digit lines and assign. Similarly, the clock trunk has uh, uh, 10 or 11 signals. So those, um, I decided rather than create the skew that would be involved with sending a different message for each pulse, I basically take the 11 lines and treat them as bits of a word and just transmitted an integer. So that becomes the way in which the data transmission has emulated. And again, the idea is to get as close to the way the real machine worked so that in looking its behavior, I could understand what was going on with real machine. And if I have a little bit of time, I'll mention some of the results that came out of all of that.

Speaker 2:          20:57          So here's the clock. It's a rather interesting clock and a lot of ways, um, remember I said it was a hundred kilohertz basic clock. So each of these time units here is uh, 10 microseconds. A sequence of 20 of them can constituent now constitutes, that's the word I'm looking for. Uh, a period that's known as an addition time. That's why we say that additions take 200 microseconds and in that we have a set of pulses. Here's 10 pulses that kind of fits. Since we're using base 10, there's interleaved between them, a set of nine pulses and we'll see how that's used in a minute. We've got four sets of signals here with one, two, with two and one with four. It turns out that with those I can construct any digit I want. If I want the digit five, I turn on the four and the one or the two twos in the one got a few options. And uh, there's this one prime Paul, that's kind of special. We probably won't have time to get into the details of it, but the really interesting one in this is this pulse right up in the top. It's labeled the central programming pulse. This is kind of what we would think of as the clock in more modern terms. This is the rate at which operations are taking place. So the thing that initiates an ad, the thing that starts a multiply, it's always going to be synchronized with that central programming pulse.

Speaker 2:          22:37          So in the simulator, uh, basically what I've got is a set of channels that go directly from the cycling unit, the clock generator to each of the units in the machine that consumes clock. And so, uh, that's done is a real simple little a fan out kind of routine that just says, okay, I'm going to receive a message. I've got a list of places to send it and I'm just going to send it all of them. Uh, and it turns out there's also some handshaking I'll explain in a minute.

Speaker 2:          23:12          So here's an example of the way in which we connect the signals. Now this particular photograph was taken from an exhibit at Fort Sill in Oklahoma. They have a subset of the Enac on display there. Unfortunately they haven't exactly hooked it up in a way that is real. They've just plugged a bunch of wires in and Gee, look, and one of the things that is kind of inaccurate is the mixing of these different types of trays in practice. The ones with these individual connectors, the ones that have the alternating black and white backgrounds, those would run across the tops of the control panels. I'm sorry, take that back. Those weren't across the bottom of the machine. The other ones with these multi pin connectors would run across the tops of the control panels. The multi pin connector ones were where you carry data and then the ones with individual pins like these war where you cared. Control signals.

Speaker 1:          24:25          Yeah.

Speaker 2:          24:25          Now the interesting thing is these are buses. You can plug lots of different connections into one of these things that ties to all of these other connections.

Speaker 1:          24:37          Okay.

Speaker 2:          24:38          A bunch of them might be transmitters and you get basically get sort of a wire or behavior. Uh, they might be receivers, in which case they're just getting whatever one of the transmitters is doing. So the fact that these configurations aren't fixed, that the programmer can choose whatever they want for the configuration means I've got to have a fairly general mechanism in the simulator to allow you to sort of connect as many transmitters and receivers as you want to one of these buses. And so that little structure turns out to have been kind of a fun part of the project where I end up with this collection of these trays. And so kind of matching the physical machine there as an implementation. I think it's 10 or 20 of each type of cray. And within the tray what you do is you have an array of connections that have been connected to it, identified as transmitters, and then you just simultaneously listen for message on all of those channels.

Speaker 2:          25:47          Any one that you get, you then turn around and pass it on to all of the receivers that you got. And so when you have the commands that do the configuration saying plug wire from here to here, that goes into the trays as here I'm a transmitter to this and here I'm a receiver to this. Now there's one aspect of this that is slightly different than the original. In the original, the wires in principle could carry signals in both directions. That was never really used that way and so I figured it was safe to go ahead and in the simulator treat each one of the channels as unidirectional.

Speaker 1:          26:31          Okay,

Speaker 2:          26:31          so this is kind of the discussion about how those trunks work. Now let me mention the handshaking in the original machine, when the clocking unit, the cycling unit transmitted, say a central programming pulse throughout the machine, then of course each unit would respond to that. It would potentially as a result, send out other signals now,

Speaker 3:          26:59          okay.

Speaker 2:          27:00          The design of the machine was such that before the next pulse, the next cycle of about a hundred kilohertz clock, we could rely on all of the circuits having finished what they were doing with that first pulse.

Speaker 2:          27:16          If you're writing code running on a timesharing operating system, it ain't so predictable. And in fact that turned out to be an issue that I ran into on some platforms. It seemed to run quite stable. Lee on other platforms, it would fail tests and digging in. I was finding things like, oh, this signal was happening before this signal, when it should be the other way around. So I swallowed hard and said, okay, I'll go ahead and implement a handshaking mechanisms. So the idea is that if I receive a clock signal, I'm not going to send back the acknowledgement until I have finished with anything I'm sending and gotten the acknowledgements for those and then I'll be able to send my acknowledgement back. So that ends up actually throttling the speed of the simulator a bit. And some people are a little surprised to find that the simulator actually runs slightly slower than the original machine. Um, yes, the original machine was quite slow, but this simulator is even slower. Um, but again it gets down to that working at a very low level. Okay. So how did the accumulators work? As I said, this is where most of the computation takes place and the way it is set up is each accumulators source 10 decimal digits

Speaker 2:          28:47          and it does so by using a 10 stage ring counter and the ring counters were implemented in these in modules that would plug into the back here. And so you would have on the machine a vertical line of 10, the on lamps, one of which was illuminated. That was the value of that digit. Okay. Then you had 10 of those columns next to each other. It was the 10 digit number. And then we also had a sign, a plus or minus sign. And of course you look at that and think, Aha, they're doing sign magnitude. Nope, they're actually, they've got a sign and they're doing Ken's compliment. It's kind of a weird combination. Um, but of course that means, you know, white tooth compliment additions don't have to pay attention to sign. They do the right thing. The inputs to the accumulators are labeled by these Greek letters Alpha through epsilon. Um, each one of those represents a channel over which I can take these 10 digits and parallel and add to whatever is in the cumulate are currently, the outputs are labeled a, an s, the output is an additive output and the output is a subtractive output. The idea is that if I want to add, I'll transmit on the edit of output and whoever receives it, we'll get that added to their current value. If I'm subtracting, I'll, I'll put on the s output and then whoever receives it will get the difference and the way it does it is by sending the number as it's stored on the AI output and sending the compliment or the number over the SL put.

Speaker 3:          30:40          Okay.

Speaker 2:          30:42          For each of 12 different operations you can trigger on an accumulator, you've got switches that let you set what that operation is going to do and basically you can either say, I'm going to receive on one of the inputs or I'm going to output on one or both of the outputs or, and you got to love this. They've got to know op.

Speaker 2:          31:10          It turns out that no op is actually used fairly often on the enac. Um, you've got a couple of other controls, uh, one of which says if I'm transmitting, do I clear the accumulator after, um, that same control if I'm receiving, I actually get an extra one added in and that has to do with the nines versus tens compliment may remember and go all the way back to your freshman year in college when you were taught about ones and twos complement once complement your football, the bits for twos complement, you'll flip all the bits and add one. Same sort of thing happens with nine and tens compliment to get from nine's complement to tens complement. You just add one. And so that correct setting is about adding an extra one for that. The other thing we've got is a nice little repeat mechanism still. If I want to add three x to y, then I don't have to set it up as three separate operations. I can set it up as one operation, which x is transmitted three times and why receives three times. So small integer coefficients in your equations don't actually have to go through the multiplier. You only need the multiplier when you're multiplying two variables together.

Speaker 2:          32:31          So here's how the whole thing works. This gets us into those pulses I was talking about. These are two lines from the clocking diagram with the group of 10 and the group of nine. Now if I think about a digit, say its value is for, then I want to transmit four pulses out the ace side for that digit. I want to send the nine's complement of that, which would be five pulses out the s side. The reality is I'm always going to be sending mine pulses. It's just which of them are going out the a in which are going out the yes. So the cleverness is, well what we'll do is we'll take the value in that digit, feed 10 pulses into it that causes the ring counter to go all the way back around to where it started and in the process of doing so, at some point it's going to go from nine to zero. And what happens when we go from nine to zero, we set a carry and it turns out that if you think about it for a second, the carry is exactly when I need to switch from out putting on one of the terminals to switching to the other. So we start out sending out the esport. As soon as the carry hits, we switched and send the rest of the nine pulses out the port. And this is how we read information from the accumulators. It was easy enough to figure out how to make an ad, but how do you read the information out? That wasn't as obvious.

Speaker 1:          34:06          Okay.

Speaker 2:          34:06          People were used to using these sorts of counters. In fact, Eckert had a lot of experience. People doing nuclear research had these decade counters that they were using for measuring radiation. But of course the information that you got out of the counter was always a human being. Looking at the lights,

Speaker 2:          34:26          how do you pull the information out and use it somewhere else? This really clever approach is what they used. And what I'm going to do right now is in the simulator illustrate that in operation. So here is an image of the simulator. Uh, what I've done is I've sort of zoomed in on one section of the machine. Um, depending on what you're doing with it, this view of the whole machine is a little bit more impressive, especially when the lights are moving and doing all sorts of fun stuff. But right now we're going to be looking at just a few parts of the machine. In particular. The leftmost unit in this figures, the divider square ruder, and then immediately to its right are a set of seven accumulators. And the first three of those accumulators are what we're going to be using right now. The other thing I'll point out here is that in the lower left hand corner of this image is a representation of a control box.

Speaker 2:          35:25          In fact, it's got some uh, photographic remnant of the real thing and this is what the control box look like. This is a three d printed reproduction of it. Uh, this one is actually set up to be able to plug it into a simulator running on raspberry Pi and actually control the INAC. The neat thing about this was it really showed a great deal of foresight into the questions of debugging. One of the most important things that this lets you do is single step the machine. In fact, you, this switch lets you control what level of granularity you're single stepping is doing and it had a long enough cord, you could walk around the whole machine so you could walk up to any accumulator and just sit there and go, ah Ha, here's the mistake. So what I'm going to be doing right now is doing the on screen version of that right down here. And so this is how I'm going to be controlling it right now. I've got the clocking mode set that every time I hit the pulse button, one addition time's worth of activities going to take place. So initially all hit the initialize button, which sends out a pulse that is meant to start the first stage of the computation. And in this case, the first stages are loading some values in. Now if you look carefully, the first accumulator, that second panel here now has a couple of values in it that weren't there before. The first digit is moved up one place and there's this next digit over here has moved up five. So we've stored the number 15 in this accumulator.

Speaker 2:          37:17          I'm going to hit another pulse. What's going to happen is in parallel when a load of value into both of these,

Speaker 2:          37:25          and in this case the value loaded into each of those is 27 so we've got 15 in the first accumulator, 27 and the other two. And what I'm going to do now is go through that step by step of how it transmits from one place to another. The additive output's going to go into one of the other accumulators and the subtractive into the other. So I'm going to simultaneously be computing the sum of 15 and 27 and the difference of 15 and 27 so let me switch the clock now to the single pulse mode. And we now begin this sequence. So here, if you look at the one on the left, all of the positions have moved up one spot. That's one of those 10 pulses. And as we're going through those 10 pulses, you see that some of the things are also causing things to climb on the other two accumulators. And the lights underneath are the carry lights. So they tell you when it's going from one to the other. Once we've resolved all of the caries, we now have in the second accumulator a psalm of 42 and in the third accumulator, the difference 12th.

Speaker 2:          38:38          So when you're operating the enac, that's basically the way you're doing arithmetic is you're counting pulses on a percentage basis.

Speaker 3:          38:50          And if

Speaker 2:          38:53          you can't figure out what went wrong, you've got your debugger. Actually, kind of like this kind of a debugger, which we had this on real computers or modern computers, I should say. Uh, I sometimes tell folks that a special my students that it's not a real computer if there's not blinking lights. I mean let's face it, we haven't had good computer since the PDP 11 heavily. Um, okay. So the next piece of this that I want to mention is the master programmer. The idea here is that yes, it's fairly easy to build a sequence of operations where the output terminal from one operation triggers the next operation. But how do you go about doing repetition? How do you do conditional operations? The master programmer is the equipment they put in for that purpose.

Speaker 2:          39:56          Now it's not as completely general as we usually think of in terms of a typical store program types. Sarah scenario where you've got a jump instruction and you can organize them however you want, but it was very flexible. It contained 10 counters of six stages each. These calendars, these six stage counters represented phases of a computation. And so every time you advance that, you would go to the next phase of the computation. For each one of those phases, you had counters that you could set to be a simple limit on how many iterations to perform total of 20 digits worth of counters. And you could kind of reassign them to different state, a different ones of the six stage counters as needed. So you could really build these very complex nested loop structures if you want it.

Speaker 3:          40:55          Okay.

Speaker 2:          40:56          Another neat thing that happens is we have these, uh, interesting cabling structures here, but we have special adapter cables that will take one of those multi pin connectors and break it out into 11 of the individual control connectors. And since the pole shapes are exactly the same, we can take a digit output and use it as control.

Speaker 2:          41:25          So for example, if I take the sign output, I can use that to discriminate between positive and negative. Okay. So the conditional values that they used, in fact, the term they used in the manual was magnitude discrimination, was to determine the comparison of two magnitudes. And it was typically, or one of the most common forms was in terms of the sign, was it positive or negative? So by introducing a data signal into the control structure, you could generate a control pulse only if a certain result was negative or only if it was non negative. And by doing that you got conditional branching.

Speaker 2:          42:10          And that of course as we know, turned out to be the key thing. Once you had that you had Turing completeness and that's why they were able then to look at building a, an instruction set decoder. Well in fact they actually had some clever use of the master programmer in the original thoughts for the instruction said decoding where they would use what amount of to the 60 different outputs from the stages as innocence, the instruction decoding. So if you were, had gotten an instruction set of 60 or fewer instructions, you can implement it directly on the existing hardware. Now it turns out what they actually did in practice was they decided they wanted a more rich instruction set. So they added another component that would take a two digit number and break it out to 100 connections. And they called that the converter units. So that's what was actually deployed. Um, the other neat thing about this is that if I take instead of a sign a digit and feed it into one of these six stage counters, I basically get what any old fortran folks in here, what we call a computer go.

Speaker 2:          43:27          Essentially, you take the value of this integer and it selects one of six possible actions. Uh, there's an example in the technical manual that, uh, takes a pair of the six stage counters and divides it into two groups of five. And the Ben, you've got now 10 options from a single digit. So one example of using this is calculating, say a table of squares. And I'm not going to go through a lot of the detail of this. I'll just suggest that if you take a look at the slides later and you want to kind of figure out how this works, we're not actually squaring anything. We're just using everybody's favorite relation from uh, high school x plus one squared is x squared plus two x plus one and neat little things like two x. Well, we just use the repeat mechanism on the accumulators to do that. Um, okay. At this by the way, is how you would wire up that problem. This is in effect your source code.

Speaker 1:          44:37          Okay.

Speaker 2:          44:40          The switch settings are indicated by values in these boxes and then the wiring is indicated on the top and bottom, the data trunks up here and the controlled trucks down here. And this is the way in which you would typically specify a program. They had a few other variations on this, but this was a very direct one because now you can take that walk into the machine room and wired up.

Speaker 2:          45:11          And one of the ways this was frequently done was one person was standing in the middle of the room with the papers and call out accumulator, a 12 program, three switch setting alpha and there would be a person standing at that accumulator and turn the switch and you would have this whole room full of people programming the machine that way. Um, as you might guess, bugs in the form of plugging in the wrong cable or setting the wrong switch. Those were pretty common. Um, okay. I've already really kind of mentioned this, so I don't want to spend too much time on that. I do want to mention a little bit about, um, how this user interface came about that, uh, I showed you what you saw was just the graphical part of it. There's actually also a command line interface, which is really from the codes perspective, the main interface and it's a very primitive sort of a thing. You know, I am an old timer in that regard.

Speaker 2:          46:15          Why type three characters, if I can type one, let's face it, there's nothing wrong with a variable called high. Um, so it's got a very simple single letter commands and abbreviations to refer to the unit. So for example, if I'm going to set a switch setting, the command is s I'll specify which switch and then a value. And so you get this nice little three fields in the line, which looks a lot like assembly language. In fact, I was comparing notes and discussing, uh, this work with another person who had done in any acts simulator and he liked that format. So he converted his to use it. And between the two of us, we started calling it the Enac Assembly language. Um, so it turns out then if you want to have a configuration file that wires up the whole setting, it's just a file you read that look like commands that the user's stocked.

Speaker 2:          47:10          So nothing special in terms of configuration files. Uh, so how's the graphical stuff done? Well, a long time ago I reached the point where I decided I was done dealing with graphical libraries. Every one of them is different. None of them are any good. I'm going to let tcl TK do the for me. So all I do is create a child process running wish, which is the windowing shell from tcl TK. I set up a couple of pipes, one that becomes it standard input. When that becomes the standard output, when I want to do something on the screen, I just shoot commands down and that happens on the screen. When somebody pushes a button on the screen, it just sends back a message that happens to be exactly the same format as what would happen if you type the command at the command line window.

Speaker 2:          48:01          The beauty of this is it's completely portable, TCPA, tcl. Tk has been poured to virtually everything and I don't have to think about anybody else's graphical environment. I don't have to think about anything. It does it all for me. So this has kind of become my standard way of doing graphics. The other thing that's kind of interesting about this is where did these images come from? There's no actual photograph of the machine that looks like that, but there are lots of photographs of different bits of the machine. So I actually went through scoured many hundreds of photographs and found like the best photograph of this part right here in this part right here in this part right here. And then pasted them together into units and then a wrote a custom ray tracer degenerate the depth.

Speaker 2:          48:58          So that's how that's perspective image came about. All right, let's see. Believe, yeah, here's a couple of examples of it running. My favorite one is the one on the right. If you remember a little device called the chip a few years ago, it was a Kickstarter or they ended up closing up a little arm machine. That's it. Running on it little pocket thing. I meant to bring it with me and forgot. Now I promised this to kind of come full circle, so I need to talk about one more connection between going the ENIAC and it starts with this guy right here, Harry Husky. Husky is probably one of the most influential and least known figures in the history of computing. He only passed away recently at the age of 101

Speaker 2:          49:51          his role on the any ACC was as the designer of the interface units between the [inaudible] and the punch cards. Carden punch later after the design work had been done in the machine was under construction. The team begins working on their follow on project, the Ed Vac, and he was a part of that. After the war, he took a sabbatical and he went to England where he was at the national physical laboratory. And if you've followed the history of Alan Turing, you'll know that's where he went after Bletchley Park. Well. Husky was intrigued at some of touring's architectural ideas for building computers and he pushed the folks that, uh, NPL to build a sort of small pilot version of this work. Well, a project kind of started in fizzled while he was there, but after he left, that same project got resurrected and produced the machine that we now know today as the pilot.

Speaker 2:          50:51          Nice, very interesting architecture if you study it. After that, he comes back to the u s he goes out to California and is the lead engineer on the development of a machine called the Swhack. The Standards Western Automatic Computer National Bureau of standards built two machines in these early days and he was the lead for the one on the west coast. After that, he joined the faculty at the University of California Berkeley. Now, while he was at Berkeley, he had several notable students. One of his phd students was Nicholas feared the person who then went on to do the languages. Pascal Modular Oberon, one of his master's students was this fellow right here, Ken Thompson, who of course, as we know, went on to work on the multex project at bell labs. Then when bell labs dropped out of Multex, he said, let me find something interesting to work on. And as he puts it, he found the little used PDP seven. He was going to do space exploration type stuff. We'll space war games and decided now I need to build me a little operating system. And that was Unix. And of course, we all know from there he had, uh, developed the language, be Dennis Richie added types to make it see before he retired, Ken was working for Google as one of the key developers on goat. So that's how it actually comes all the way full circle. All right. Any questions?

Speaker 2:          52:34          All right, well, I think we've used right at an hour, so thank you very much. And uh, have good rest of the day.

Speaker 1:          52:41          [inaudible].