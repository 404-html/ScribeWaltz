WEBVTT

1
00:00:10.790 --> 00:00:11.340
Cool.

2
00:00:11.340 --> 00:00:15.060
<v 0>Thank you for coming out today and to listen to an old guy talk about an even</v>

3
00:00:15.061 --> 00:00:19.560
older computer.
Um,
we are here to talk about the Enac.

4
00:00:19.590 --> 00:00:22.110
Most people in our field,
of course I've heard of it.

5
00:00:23.040 --> 00:00:24.900
Most people don't know much about what it is.

6
00:00:24.990 --> 00:00:29.160
You may have heard it was the first computer or you may have heard it wasn't the

7
00:00:29.161 --> 00:00:29.994
first computer,

8
00:00:30.450 --> 00:00:34.470
or you may have heard the patent got invalidated because they stole all the

9
00:00:34.471 --> 00:00:39.430
ideas.
Um,
the reality is that,
uh,

10
00:00:39.450 --> 00:00:44.310
it is a very rich history and it is a very interesting machine and it was a
very,

11
00:00:44.311 --> 00:00:45.570
very influential machine.

12
00:00:46.260 --> 00:00:51.260
Now we're not going to really go into all of the history aspects of it.

13
00:00:51.271 --> 00:00:54.510
Today.
We're going to talk more technical terms about it.
In particular,

14
00:00:54.511 --> 00:00:58.460
we're gonna focus on this simulator that I wrote.
The,
um,

15
00:00:58.890 --> 00:01:00.360
the motivation was simply,

16
00:01:00.570 --> 00:01:05.570
I wanted to understand how the eniac worked and I felt the best way to do that

17
00:01:06.150 --> 00:01:11.010
was right.
A simulator of it,
and to get down to as low level as I could get.

18
00:01:11.670 --> 00:01:13.920
And so that's what we're going to be talking about today.

19
00:01:14.970 --> 00:01:17.400
So let's see if the clicker works.
Ah,

20
00:01:18.150 --> 00:01:23.150
so this gives you kind of the usual rundown of what the ENIAC was all about.

21
00:01:25.110 --> 00:01:28.440
The story essentially is during World War II,

22
00:01:29.100 --> 00:01:33.930
as artillery manufacturers are producing new guns,
new propellants,
new shells,

23
00:01:35.070 --> 00:01:38.910
we need to calculate the tables so that when you're in the field,

24
00:01:39.180 --> 00:01:42.030
you're not solving differential equations to figure out where to point the gun.

25
00:01:43.230 --> 00:01:46.680
You want to have a stable that says,
okay,
if I'm shooting in that direction,

26
00:01:46.681 --> 00:01:50.940
the wind is blowing that way.
It's that far away.
And the humidity is this,

27
00:01:50.941 --> 00:01:52.200
I need to point the gun there.

28
00:01:53.280 --> 00:01:57.270
And these tables took a tremendous amount of computation.

29
00:01:58.500 --> 00:02:01.440
And of course the way you compute something is with a computer.

30
00:02:03.750 --> 00:02:07.890
Except the thing is that in the 1940s the word computer was a job title.

31
00:02:09.630 --> 00:02:14.630
These were people doing computing the US government for both this purpose and

32
00:02:16.381 --> 00:02:19.020
for the purposes of code breaking,

33
00:02:19.140 --> 00:02:22.260
sought to hire as many mathematicians as they possibly could.

34
00:02:23.430 --> 00:02:25.110
Yet with a war going on,
of course,

35
00:02:25.530 --> 00:02:28.890
all of the young men who had just been studying mathematics work off at the

36
00:02:28.891 --> 00:02:29.724
front.

37
00:02:29.790 --> 00:02:33.630
So we have this wonderful competition between divisions of the government to

38
00:02:33.631 --> 00:02:37.770
hire all of the young woman who had been studying mathematics and they're doing

39
00:02:37.771 --> 00:02:41.520
these calculations mostly by hand on adding machines.

40
00:02:43.050 --> 00:02:46.950
And one of the researchers at University of Pennsylvania named John Mark Lee

41
00:02:48.000 --> 00:02:51.690
came up with the idea of essentially building a machine that was strapped

42
00:02:51.691 --> 00:02:52.111
together,

43
00:02:52.111 --> 00:02:57.111
a whole bunch of adding machines and he recognized that it would be even faster

44
00:02:57.631 --> 00:03:01.480
if you use vacuum tubes.
And so this was the birth of the ENAC

45
00:03:03.430 --> 00:03:08.110
being a war.
You make a proposal to the government that can help and they say,

46
00:03:08.290 --> 00:03:11.720
great,
have some money and go do it.
Um,

47
00:03:11.830 --> 00:03:14.530
whether or not they could have gotten the money in peacetime is another
question.

48
00:03:14.860 --> 00:03:17.550
But it began in 1943,
um,

49
00:03:18.550 --> 00:03:22.210
by early 1944 they had some prototype stuff running.

50
00:03:22.211 --> 00:03:26.350
By the summer of 1944 they pretty much had it worked out what they were going to

51
00:03:26.351 --> 00:03:30.910
do and had turned over a lot of the work to other engineers and technicians for

52
00:03:30.911 --> 00:03:35.560
building it.
It wasn't until late 1945,

53
00:03:35.561 --> 00:03:37.480
however,
that the machine was completely finished.

54
00:03:39.070 --> 00:03:42.160
So it didn't actually get used during World War II.

55
00:03:42.940 --> 00:03:44.080
But interestingly,

56
00:03:44.800 --> 00:03:49.800
the first task it took at had was a project that was also sparked by World War

57
00:03:51.430 --> 00:03:52.263
II.

58
00:03:52.780 --> 00:03:57.100
The Manhattan project at Los Alamos had some heavy calculations they wanted done

59
00:03:57.460 --> 00:04:01.600
and so they came out during the winter of 1945 and use the act to do some of

60
00:04:01.601 --> 00:04:02.470
those calculations.

61
00:04:04.600 --> 00:04:08.830
One of the interesting points about it that a lot of people will make is that

62
00:04:09.340 --> 00:04:12.760
you couldn't program it the way we're used to programming modern computers.

63
00:04:13.270 --> 00:04:15.490
You had to rewire the machine to programs.

64
00:04:16.930 --> 00:04:21.010
And that was true as it was initially built.
But here's the thing,

65
00:04:21.310 --> 00:04:24.670
if I can wire a solution to any problem,

66
00:04:25.600 --> 00:04:28.930
why can't I wire a solution to the problem of being a CPU?

67
00:04:30.820 --> 00:04:33.610
And that's what they did.
So in 1948,

68
00:04:34.060 --> 00:04:39.060
they implemented a CPU on a traditional in sequential instruction execution CPU.

69
00:04:41.500 --> 00:04:45.370
And it was used that way until his retirement in 1945 and 1955.

70
00:04:46.830 --> 00:04:50.530
So this is actually going to come back and be something important in a minute.

71
00:04:51.010 --> 00:04:53.950
Uh,
as you might guess,

72
00:04:54.040 --> 00:04:59.040
it changed the balance of performance on the machine quite a bit to do this.

73
00:05:00.540 --> 00:05:01.031
All right,

74
00:05:01.031 --> 00:05:05.380
so this is the famous picture of the Aniak that was taken as part of the

75
00:05:05.381 --> 00:05:06.214
publicity.

76
00:05:06.610 --> 00:05:10.900
This was taken and released in the press release when it was dedicated and

77
00:05:10.901 --> 00:05:13.240
announced to the public in early 46.

78
00:05:14.680 --> 00:05:19.660
And you can see in the picture that this goes back a long distance into the
room.

79
00:05:20.080 --> 00:05:24.870
You've got,
uh,
some people standing around and give you a sense of scale.
Um,

80
00:05:26.140 --> 00:05:29.560
the whole machine looks something like this.

81
00:05:29.561 --> 00:05:32.290
Now obviously this is a bit too small for most of you to see,

82
00:05:32.530 --> 00:05:35.020
but if you want to come and take a look at it after the talk,
you're welcome to.

83
00:05:35.200 --> 00:05:39.040
This is a small three d printed model of the ENAC.
Um,

84
00:05:39.070 --> 00:05:44.070
and these stand up pieces that the soldiers standing by in that picture or the

85
00:05:44.651 --> 00:05:48.760
switch panels that were originally put on for function tables and that's where

86
00:05:48.761 --> 00:05:53.410
the instructions were stored when it was later a run as a conventional computer.

87
00:05:54.250 --> 00:05:58.430
Right here we have punched card input,
an output,
the only io on the machine,

88
00:05:59.300 --> 00:06:03.610
no screens,
no mice.
Um,

89
00:06:04.520 --> 00:06:08.240
these are the two guys that really kind of led the project.
Uh,

90
00:06:08.270 --> 00:06:11.420
the first one that I mentioned before was John Mark Lee on the left.

91
00:06:11.750 --> 00:06:15.890
He was a physicist at the University of Pennsylvania and he was very interested

92
00:06:15.891 --> 00:06:20.750
in a variety of kinds of problems that were extremely numerically difficult

93
00:06:20.751 --> 00:06:24.500
problems.
One of his big interest was weather.

94
00:06:25.820 --> 00:06:28.790
How do you predict the weather?
Well,

95
00:06:29.300 --> 00:06:31.790
we know the differential equations for fluid mechanics,

96
00:06:34.070 --> 00:06:37.280
but if you're going to do a 24 hour forecast by hand,

97
00:06:37.370 --> 00:06:40.810
it's going to take you a lot more than 24 hours to do it.
Um,

98
00:06:40.880 --> 00:06:43.250
so this is one of his motivators in this.

99
00:06:45.680 --> 00:06:46.910
The fell on the right.

100
00:06:47.600 --> 00:06:52.600
J Presper Eckert was a graduate student at Penn when they met.

101
00:06:53.380 --> 00:06:54.050
In fact,

102
00:06:54.050 --> 00:06:59.050
Eckert was teaching a sort of a workshop on electronics that McCully took and

103
00:07:02.240 --> 00:07:04.910
Eckert was,
let's face it,
an engineering genius.

104
00:07:05.690 --> 00:07:08.660
He was one of the top electrical engineers.
You can imagine.

105
00:07:08.661 --> 00:07:13.661
He invented all sorts of cool ideas and really put it on extremely solid

106
00:07:13.881 --> 00:07:18.320
footing.
And it was one of the few reasons that machine was successful.
Um,

107
00:07:18.350 --> 00:07:20.900
we have these wonderful statistics that always get quoted.

108
00:07:22.010 --> 00:07:24.290
And the second one on that list,

109
00:07:24.890 --> 00:07:27.410
it had about 18,000 vacuum tubes.

110
00:07:28.460 --> 00:07:31.430
That was more than anything before it.
In fact,

111
00:07:31.431 --> 00:07:33.080
when they first proposed the machine,

112
00:07:33.560 --> 00:07:37.160
they had proposed a slightly smaller version that we'll have about 5,000 tubes.

113
00:07:38.090 --> 00:07:42.770
The government folks went to the experts,
mostly MIT,

114
00:07:43.790 --> 00:07:47.330
and said,
what do you think of this proposal?
And the response was,

115
00:07:47.870 --> 00:07:51.500
there's no way that machine will ever run.
The tubes will burn out too fast.

116
00:07:53.360 --> 00:07:58.360
But Eckert realized the mechanisms that were involved in a tube burning out and

117
00:07:58.821 --> 00:08:00.380
was able to design around it,

118
00:08:01.490 --> 00:08:05.450
it was able to operate the tubes in a way that would minimize their burnout.

119
00:08:06.020 --> 00:08:11.020
And furthermore to extend the usage life of it as their parameters changed over

120
00:08:12.471 --> 00:08:15.530
time.
So these kinds of design characteristics,

121
00:08:15.531 --> 00:08:19.040
really what Eq or brought to it,
um,

122
00:08:19.220 --> 00:08:23.510
as you can see it had the blazingly fast clock of 100 kilohertz.

123
00:08:24.770 --> 00:08:27.950
Okay.
Now that's not gigahertz.

124
00:08:28.640 --> 00:08:30.830
It's megahertz a kilo.

125
00:08:30.840 --> 00:08:34.910
Hertz is 1000000th of a Gigahertz,

126
00:08:35.970 --> 00:08:38.180
gives you some sense of the speed of this machine.

127
00:08:38.810 --> 00:08:41.300
It took about 200 microsecond student edition.

128
00:08:41.360 --> 00:08:46.130
That's why we often will hear quoted the figure 5,000 admissions per second as

129
00:08:46.131 --> 00:08:50.060
we're going to see that's not the most accurate way to look at it because it was

130
00:08:50.061 --> 00:08:54.950
a very parallel machine.
Um,
these last three points here.
I really love those.

131
00:08:54.990 --> 00:08:59.250
Um,
being someone who grew up in a world of five volt TTL,

132
00:09:01.170 --> 00:09:05.940
thinking about a computer that uses 150 kilowatts of power with 29 distinct

133
00:09:05.941 --> 00:09:09.780
power supplies in [inaudible] 78 different DC voltage levels is kind of

134
00:09:09.781 --> 00:09:10.614
frightening.

135
00:09:10.860 --> 00:09:13.920
Especially when you look at the schematics and all the numbers are three digit

136
00:09:13.921 --> 00:09:15.120
numbers.
You know,

137
00:09:15.121 --> 00:09:19.980
it's like this one's negative 290 volts and this is positive 540 volts.

138
00:09:19.981 --> 00:09:22.140
And it's like,
okay,

139
00:09:22.800 --> 00:09:25.950
I'm used to five volts that I can touch and be safe.

140
00:09:28.590 --> 00:09:32.040
But this obviously was a quite a beast of a machine.

141
00:09:32.760 --> 00:09:33.593
<v 1>Uh,</v>

142
00:09:35.020 --> 00:09:39.430
<v 0>the basic architecture of it is consisting of these units.</v>

143
00:09:39.431 --> 00:09:43.360
Now what you have,
and you may have seen a little bit of this in the picture,

144
00:09:43.810 --> 00:09:46.720
are these racks that go around the room.

145
00:09:47.050 --> 00:09:50.710
Now they're not quite our standard modern 19 inch racks,

146
00:09:50.920 --> 00:09:52.900
but these rocks are roughly two feet wide.

147
00:09:53.650 --> 00:09:56.150
So they're a little bit wider than our typical 19 attracts.

148
00:09:56.230 --> 00:09:59.410
They're about eight feet tall and there's 40 of them.

149
00:10:00.700 --> 00:10:02.170
So if you spread this thing out,

150
00:10:02.171 --> 00:10:06.550
you would have a wall 80 feet long by eight feet tall.

151
00:10:08.260 --> 00:10:12.600
And each one of these racks is a unit of the machine.

152
00:10:12.601 --> 00:10:16.330
It has some functionality relative to the whole machine.

153
00:10:16.510 --> 00:10:18.940
And this is kind of an inventory of those units.

154
00:10:19.510 --> 00:10:24.430
The bulk of the actual computation is all taking place in the accumulators and

155
00:10:24.431 --> 00:10:26.350
that's what we're going to focus most on today.

156
00:10:26.830 --> 00:10:30.520
But we also have a high speed multiplier that took three racks.

157
00:10:31.900 --> 00:10:34.960
It was built around good old fashion multiplication tables.

158
00:10:36.100 --> 00:10:40.660
The same ones you learned in second grade because it was a base 10 machine

159
00:10:41.170 --> 00:10:44.980
worked in decimal.
Uh,
there was a divider square ruder,

160
00:10:46.360 --> 00:10:49.820
the function tables that I mentioned before which were connected to these switch

161
00:10:49.821 --> 00:10:50.654
panels

162
00:10:52.000 --> 00:10:55.900
and then the interfaces to the io devices,
the punch cards.

163
00:10:57.310 --> 00:11:02.310
Now this is how the machine was laid out from kind of a top down view and you

164
00:11:02.891 --> 00:11:04.300
really can't read it very well.

165
00:11:04.301 --> 00:11:08.680
But these are the labeling of all of the units over here.

166
00:11:08.681 --> 00:11:13.150
We have the initiating and cycling units.
The initiating unit,

167
00:11:13.600 --> 00:11:15.790
its primary role was two fold.

168
00:11:15.791 --> 00:11:20.140
One was to control the sequencing of power when you started it up and it was

169
00:11:20.141 --> 00:11:25.141
also a to sort of synchronize the initialization of a program and the,

170
00:11:26.770 --> 00:11:30.340
uh,
interaction with cards,
both punching and reading.

171
00:11:31.210 --> 00:11:34.750
The next unit,
the cycling unit is basically the clock.
Um,

172
00:11:34.960 --> 00:11:37.660
we have the master program where I'll say a little bit about,

173
00:11:38.140 --> 00:11:42.610
and then around here are intermixed,
the accumulators,

174
00:11:42.611 --> 00:11:45.190
the multiplier divider,
square reader.
And so on.

175
00:11:46.780 --> 00:11:48.400
This space inside of it

176
00:11:50.030 --> 00:11:53.800
was 32 by feet.

177
00:11:56.140 --> 00:12:00.910
Um,
now they rearranged the layout slightly when they moved it to its prominent

178
00:12:00.911 --> 00:12:02.800
location in Aberdeen,
Maryland.

179
00:12:04.450 --> 00:12:08.620
And they had a newly constructed space for it when they moved it,

180
00:12:09.490 --> 00:12:12.580
it was one of the few spaces in the area that had air conditioning.

181
00:12:14.530 --> 00:12:17.200
So late in the life of the Anyak.

182
00:12:17.410 --> 00:12:20.950
People started dragging their desks in there during the summer and using it as

183
00:12:20.951 --> 00:12:24.820
office space.
You know,

184
00:12:24.880 --> 00:12:28.690
no matter how impressive there's still going to be good old human nature coming

185
00:12:28.691 --> 00:12:30.410
into play.
Um,

186
00:12:31.030 --> 00:12:34.840
now some of the things about it that were really unusual from our modern eye is

187
00:12:34.841 --> 00:12:37.930
that there was no concept of memory.
The way we think about it,

188
00:12:39.340 --> 00:12:43.810
we think in terms of the larger ray of individually addressable locations that

189
00:12:43.811 --> 00:12:47.350
are reading right,
the enact did not have that.

190
00:12:48.790 --> 00:12:52.180
The only volatile memory you had available wore the accumulators.

191
00:12:53.230 --> 00:12:53.810
<v 1>Okay.</v>

192
00:12:53.810 --> 00:12:58.810
<v 0>So you basically had 2010 digit numbers as your volatile memory.</v>

193
00:13:00.950 --> 00:13:05.950
So to kind of think in terms of how it was like programming this machine.

194
00:13:06.530 --> 00:13:11.060
Think in terms of restricting yourself to 20 integer variables.

195
00:13:12.490 --> 00:13:13.323
<v 1>Yeah.</v>

196
00:13:13.440 --> 00:13:16.890
<v 0>If you can't solve atomic bomb problems with 20 integer variables,</v>

197
00:13:18.270 --> 00:13:22.740
you're not good enough to program the ENIAC.
Okay.
That's a little overstated.

198
00:13:22.741 --> 00:13:25.950
But yeah,
kind of get the audio.
Um,

199
00:13:26.280 --> 00:13:30.120
the other big thing about it that I like to point out is how parallel it was.

200
00:13:31.500 --> 00:13:34.530
All 20 of those accumulators could be operating simultaneously.

201
00:13:36.180 --> 00:13:39.570
So even though a single addition,
we'll take one 5000th of a second,

202
00:13:39.690 --> 00:13:44.400
you could be doing 20 of them at the same time.
So it was a very,

203
00:13:44.401 --> 00:13:47.820
very parallel machine.
In fact,
I love this quote by Lemmer.

204
00:13:48.150 --> 00:13:51.120
This was a highly parallel machine before von Neumann spoiled it.

205
00:13:52.410 --> 00:13:56.190
And this reference is to the conversion to sequential and instruction set

206
00:13:56.191 --> 00:13:58.390
execution because vanadium,

207
00:13:58.440 --> 00:14:02.400
and it was actually one of the key drivers behind making that conversion.

208
00:14:03.480 --> 00:14:07.500
Lehmer had used the machine for some interesting number theory stuff and had

209
00:14:07.501 --> 00:14:09.780
really taken a lot of advantage of its parallelism.

210
00:14:10.320 --> 00:14:12.930
And so he was kind of disappointed when they switched it up.

211
00:14:12.931 --> 00:14:16.560
And made it purely sequential.
Um,

212
00:14:16.590 --> 00:14:18.420
the other thing that I'll point out,

213
00:14:18.810 --> 00:14:22.350
and this may not mean much to some of the younger folks in the audience,

214
00:14:22.530 --> 00:14:25.290
but this basically is like a data flow machine.
Okay.

215
00:14:25.291 --> 00:14:27.900
Now if you go back to kind of the seventies eighties timeframe,

216
00:14:28.230 --> 00:14:32.730
that was one of the big buzzwords in the industry was data flow and that that

217
00:14:32.731 --> 00:14:35.880
was going to save us from all of the problems that we had with various

218
00:14:35.881 --> 00:14:40.320
bottlenecks.
And it was the new thing.

219
00:14:40.950 --> 00:14:44.310
Well it wasn't really all that new because the ENIAC was a data flow machine.

220
00:14:45.360 --> 00:14:48.810
And the idea of data for,
if you're not familiar with it,
is each unit,

221
00:14:48.960 --> 00:14:50.460
when it completes an operation,

222
00:14:50.461 --> 00:14:54.620
it sends a signal that can initiate the next operation.
So in effect,

223
00:14:54.980 --> 00:14:58.040
you do an addition,
not when the instructions say,

224
00:14:58.041 --> 00:15:01.190
but when the two data values that you're adding become available.

225
00:15:02.240 --> 00:15:06.050
So it's driven by the availability of the data,
not by the instructions.

226
00:15:07.100 --> 00:15:09.770
And that's the way the ENIAC was operated.

227
00:15:11.540 --> 00:15:16.540
So the parallelism of course is a big deal because I'm trying to understand how

228
00:15:17.661 --> 00:15:20.990
the machine works.
I'm trying to get a feel for what was it like to program,

229
00:15:21.740 --> 00:15:25.490
what were the traps involved for programmers when they were dealing with it?

230
00:15:26.180 --> 00:15:28.880
We're all used to the problems involved with parallelism.

231
00:15:30.110 --> 00:15:30.830
<v 2>Okay.</v>

232
00:15:30.830 --> 00:15:34.400
<v 0>The easiest way to make a programmer cringe is to say it's a timing problem.</v>

233
00:15:36.620 --> 00:15:41.260
Um,
anytime concurrency gets involved,
we all shut her and,
and,

234
00:15:41.261 --> 00:15:46.220
and kind of grit our teeth and go,
okay,
I can get,
I can do this.
Um,

235
00:15:46.250 --> 00:15:50.660
so I wanted to get a feel for what that was like on the ENIAC.
Well,

236
00:15:50.840 --> 00:15:55.310
obviously if I really wanted to truly get the experience,

237
00:15:55.311 --> 00:15:57.170
I would need to build some parallel hardware for it.

238
00:15:58.460 --> 00:16:02.390
And while it's still one of my to do list items,

239
00:16:03.370 --> 00:16:06.170
it didn't seem all that practical for a first approach.

240
00:16:07.250 --> 00:16:10.310
Of course I could just write code,
ordinary sequential code.

241
00:16:10.311 --> 00:16:13.100
It just sequentially go through each one of the units doing what they do.

242
00:16:14.450 --> 00:16:17.600
But I went ahead and decided to kind of take the middle ground and go ahead and

243
00:16:17.601 --> 00:16:22.601
use the concurrency we have available in a lot of our languages and to hopefully

244
00:16:23.691 --> 00:16:27.770
take advantage of whatever parallelism,
the hardware your underlying it gives me.

245
00:16:28.550 --> 00:16:32.700
And so that made it a very natural fit for uh,

246
00:16:32.840 --> 00:16:36.230
the go routines in the language go.
Um,
you know,

247
00:16:36.231 --> 00:16:39.860
of course I could use conventional p threads or something like that,
but,
um,

248
00:16:40.420 --> 00:16:43.420
it goes model is quite clean and uh,

249
00:16:43.790 --> 00:16:46.460
I liked the idea of having the portability that it would also give me.

250
00:16:46.461 --> 00:16:48.860
So that was one of the motivating factors there.

251
00:16:49.070 --> 00:16:54.070
So what happens is each of these units in the machine is simulated by usually to

252
00:16:57.200 --> 00:16:59.900
go routines that are operating in parallel.

253
00:17:01.550 --> 00:17:06.550
And the way that works is the two routines are handling different sets of input.

254
00:17:08.000 --> 00:17:11.990
Now to give you a little bit of sense of what we're getting at here,

255
00:17:11.991 --> 00:17:14.750
remember we said You rewire the machine to program it.

256
00:17:16.080 --> 00:17:16.310
<v 2>Okay.</v>

257
00:17:16.310 --> 00:17:21.310
<v 0>So that means that if I want this adder to be adding a value that comes from</v>

258
00:17:21.981 --> 00:17:22.910
over here somewhere,

259
00:17:22.911 --> 00:17:27.530
I've got to have a cabling connection that brings the data from the source to

260
00:17:27.531 --> 00:17:28.364
the destination.

261
00:17:31.180 --> 00:17:36.180
That data as it's coming in over some kind of a terminal on the destination is

262
00:17:36.221 --> 00:17:37.990
just going to be a sequence of pulses.

263
00:17:39.220 --> 00:17:42.130
And so these pulses are the inputs to the units.

264
00:17:43.560 --> 00:17:44.393
<v 2>Okay?</v>

265
00:17:44.630 --> 00:17:49.500
<v 0>There are pulses that indicate begin an operation and then that are pulses</v>

266
00:17:49.510 --> 00:17:50.370
didn't indicate data.

267
00:17:50.700 --> 00:17:55.290
Those are the controlling data pulses that go into one of the go routines.

268
00:17:56.730 --> 00:18:01.530
That routine doesn't do very much except set some state variables for the unit.

269
00:18:02.910 --> 00:18:07.500
Kind of represents the internal flip flops of the unit and in fact,

270
00:18:07.770 --> 00:18:12.660
if you go through and read some of the technical documentation and you look at

271
00:18:12.661 --> 00:18:13.494
the source code,

272
00:18:13.560 --> 00:18:16.560
you'll see a few places where there are variables that are named after certain

273
00:18:16.561 --> 00:18:18.750
circuits in the uh,
original.

274
00:18:20.760 --> 00:18:25.590
The other go routine is taking the input from the clock,

275
00:18:26.910 --> 00:18:29.730
which is another series of pulses.
Originally,

276
00:18:29.731 --> 00:18:34.440
I implemented this as one routine per unit and I realized I had a little bit of

277
00:18:34.441 --> 00:18:39.441
a problem because the result of a clock signal could turn into a control signal

278
00:18:39.481 --> 00:18:42.690
that I would transmit that would come right back into one of my other inputs

279
00:18:45.040 --> 00:18:50.040
and unless my communications channels had some buffers in them,

280
00:18:50.950 --> 00:18:54.040
I would have deadlock and if I put buffers in it,

281
00:18:55.840 --> 00:18:59.200
how can I be sure that things were synchronizing the way they were really meant

282
00:18:59.201 --> 00:19:02.020
to.
So I went ahead and split into two the two units for that reason.

283
00:19:04.700 --> 00:19:06.770
As I said,
that pulses are transmitted.

284
00:19:07.380 --> 00:19:11.060
Now this is another bit of Eckerd's genius.
He said,

285
00:19:12.260 --> 00:19:17.180
I'm going to make all the pulses the same control pulses,
data,

286
00:19:17.181 --> 00:19:20.900
pulses,
Kwok pulses.
They're all going to have the same shape,

287
00:19:21.470 --> 00:19:22.760
the same characteristics.

288
00:19:25.400 --> 00:19:26.040
<v 2>Okay.</v>

289
00:19:26.040 --> 00:19:31.040
<v 0>The idea is that there's no reason I can't use some data as a control signal</v>

290
00:19:33.750 --> 00:19:35.790
and when you open up that possibility,

291
00:19:36.600 --> 00:19:41.600
you get the possibility of conditional co flow of control and that's what makes

292
00:19:43.081 --> 00:19:43.914
it touring complete.

293
00:19:44.820 --> 00:19:49.800
So those fit very naturally into a channel model of communication.

294
00:19:50.700 --> 00:19:55.200
In fact,
the way it's set up is that messages over the channels represent pulses.

295
00:19:56.280 --> 00:20:00.180
In the case of the control lines where there's only one signal being transmitted

296
00:20:00.181 --> 00:20:04.680
for a given line,
it's just a one or a zero in the message.

297
00:20:05.520 --> 00:20:10.020
In the case of data,
the terminals are actually 11 lines.

298
00:20:10.080 --> 00:20:14.820
You've got 10 digit lines and assign.
Similarly,

299
00:20:14.821 --> 00:20:18.900
the clock trunk has uh,
uh,
10 or 11 signals.

300
00:20:19.320 --> 00:20:21.030
So those,
um,

301
00:20:21.360 --> 00:20:26.360
I decided rather than create the skew that would be involved with sending a

302
00:20:27.511 --> 00:20:29.190
different message for each pulse,

303
00:20:30.180 --> 00:20:33.900
I basically take the 11 lines and treat them as bits of a word and just

304
00:20:33.901 --> 00:20:34.800
transmitted an integer.

305
00:20:35.400 --> 00:20:40.350
So that becomes the way in which the data transmission has emulated.
And again,

306
00:20:40.351 --> 00:20:45.351
the idea is to get as close to the way the real machine worked so that in

307
00:20:46.561 --> 00:20:49.960
looking its behavior,
I could understand what was going on with real machine.

308
00:20:51.490 --> 00:20:52.720
And if I have a little bit of time,

309
00:20:52.721 --> 00:20:55.570
I'll mention some of the results that came out of all of that.

310
00:20:57.940 --> 00:20:58.900
So here's the clock.

311
00:21:00.730 --> 00:21:04.260
It's a rather interesting clock and a lot of ways,
um,

312
00:21:05.410 --> 00:21:08.260
remember I said it was a hundred kilohertz basic clock.

313
00:21:08.261 --> 00:21:12.220
So each of these time units here is uh,

314
00:21:12.250 --> 00:21:13.330
10 microseconds.

315
00:21:14.440 --> 00:21:18.400
A sequence of 20 of them can constituent now constitutes,

316
00:21:18.430 --> 00:21:22.450
that's the word I'm looking for.
Uh,
a period that's known as an addition time.

317
00:21:23.410 --> 00:21:28.410
That's why we say that additions take 200 microseconds and in that we have a set

318
00:21:30.641 --> 00:21:35.290
of pulses.
Here's 10 pulses that kind of fits.

319
00:21:35.291 --> 00:21:38.500
Since we're using base 10,
there's interleaved between them,

320
00:21:38.501 --> 00:21:41.140
a set of nine pulses and we'll see how that's used in a minute.

321
00:21:41.890 --> 00:21:46.870
We've got four sets of signals here with one,
two,
with two and one with four.

322
00:21:47.490 --> 00:21:50.620
It turns out that with those I can construct any digit I want.

323
00:21:51.700 --> 00:21:55.330
If I want the digit five,
I turn on the four and the one

324
00:21:57.070 --> 00:21:59.920
or the two twos in the one got a few options.
And

325
00:22:01.630 --> 00:22:05.680
uh,
there's this one prime Paul,
that's kind of special.

326
00:22:05.740 --> 00:22:07.960
We probably won't have time to get into the details of it,

327
00:22:08.260 --> 00:22:11.560
but the really interesting one in this is this pulse right up in the top.

328
00:22:12.190 --> 00:22:14.560
It's labeled the central programming pulse.

329
00:22:16.450 --> 00:22:20.830
This is kind of what we would think of as the clock in more modern terms.

330
00:22:20.890 --> 00:22:24.190
This is the rate at which operations are taking place.

331
00:22:24.700 --> 00:22:26.800
So the thing that initiates an ad,

332
00:22:27.280 --> 00:22:29.710
the thing that starts a multiply,

333
00:22:30.370 --> 00:22:33.850
it's always going to be synchronized with that central programming pulse.

334
00:22:37.540 --> 00:22:40.090
So in the simulator,
uh,

335
00:22:40.120 --> 00:22:45.120
basically what I've got is a set of channels that go directly from the cycling

336
00:22:46.751 --> 00:22:47.140
unit,

337
00:22:47.140 --> 00:22:52.000
the clock generator to each of the units in the machine that consumes clock.

338
00:22:53.500 --> 00:22:55.000
And so,
uh,

339
00:22:55.150 --> 00:22:59.260
that's done is a real simple little a fan out kind of routine that just says,

340
00:22:59.350 --> 00:23:00.940
okay,
I'm going to receive a message.

341
00:23:01.120 --> 00:23:04.120
I've got a list of places to send it and I'm just going to send it all of them.

342
00:23:04.590 --> 00:23:08.500
Uh,
and it turns out there's also some handshaking I'll explain in a minute.

343
00:23:12.060 --> 00:23:16.980
So here's an example of the way in which we connect the signals.

344
00:23:19.200 --> 00:23:24.200
Now this particular photograph was taken from an exhibit at Fort Sill in

345
00:23:25.651 --> 00:23:30.030
Oklahoma.
They have a subset of the Enac on display there.

346
00:23:30.720 --> 00:23:35.280
Unfortunately they haven't exactly hooked it up in a way that is real.

347
00:23:36.270 --> 00:23:39.090
They've just plugged a bunch of wires in and Gee,
look,

348
00:23:41.130 --> 00:23:46.130
and one of the things that is kind of inaccurate is the mixing of these

349
00:23:46.851 --> 00:23:50.930
different types of trays
in practice.

350
00:23:51.320 --> 00:23:53.750
The ones with these individual connectors,

351
00:23:53.751 --> 00:23:58.160
the ones that have the alternating black and white backgrounds,

352
00:23:59.450 --> 00:24:04.450
those would run across the tops of the control panels.
I'm sorry,

353
00:24:04.550 --> 00:24:06.620
take that back.
Those weren't across the bottom of the machine.

354
00:24:07.040 --> 00:24:12.040
The other ones with these multi pin connectors would run across the tops of the

355
00:24:13.370 --> 00:24:14.203
control panels.

356
00:24:14.830 --> 00:24:19.580
The multi pin connector ones were where you carry data and then the ones with

357
00:24:19.581 --> 00:24:23.540
individual pins like these war where you cared.
Control signals.

358
00:24:25.400 --> 00:24:25.990
<v 1>Yeah.</v>

359
00:24:25.990 --> 00:24:29.410
<v 0>Now the interesting thing is these are buses.</v>

360
00:24:31.030 --> 00:24:34.720
You can plug lots of different connections into one of these things that ties to

361
00:24:34.721 --> 00:24:35.920
all of these other connections.

362
00:24:37.370 --> 00:24:38.070
<v 1>Okay.</v>

363
00:24:38.070 --> 00:24:42.380
<v 0>A bunch of them might be transmitters and you get basically get sort of a wire</v>

364
00:24:42.410 --> 00:24:46.340
or behavior.
Uh,
they might be receivers,

365
00:24:46.341 --> 00:24:49.610
in which case they're just getting whatever one of the transmitters is doing.

366
00:24:50.900 --> 00:24:55.900
So the fact that these configurations aren't fixed,

367
00:24:56.510 --> 00:25:01.220
that the programmer can choose whatever they want for the configuration means

368
00:25:01.221 --> 00:25:05.270
I've got to have a fairly general mechanism in the simulator to allow you to

369
00:25:05.271 --> 00:25:08.660
sort of connect as many transmitters and receivers as you want to one of these

370
00:25:08.661 --> 00:25:09.494
buses.

371
00:25:09.950 --> 00:25:13.460
And so that little structure turns out to have been kind of a fun part of the

372
00:25:13.461 --> 00:25:18.461
project where I end up with this collection of these trays.

373
00:25:21.290 --> 00:25:26.290
And so kind of matching the physical machine there as an implementation.

374
00:25:26.841 --> 00:25:28.880
I think it's 10 or 20 of each type of cray.

375
00:25:30.770 --> 00:25:35.770
And within the tray what you do is you have an array of connections that have

376
00:25:38.211 --> 00:25:40.490
been connected to it,
identified as transmitters,

377
00:25:41.930 --> 00:25:46.100
and then you just simultaneously listen for message on all of those channels.

378
00:25:47.250 --> 00:25:48.620
Any one that you get,

379
00:25:49.040 --> 00:25:53.510
you then turn around and pass it on to all of the receivers that you got.

380
00:25:53.900 --> 00:25:58.190
And so when you have the commands that do the configuration saying plug wire

381
00:25:58.191 --> 00:25:59.060
from here to here,

382
00:25:59.780 --> 00:26:04.780
that goes into the trays as here I'm a transmitter to this and here I'm a

383
00:26:05.151 --> 00:26:06.080
receiver to this.

384
00:26:07.280 --> 00:26:12.280
Now there's one aspect of this that is slightly different than the original.

385
00:26:14.000 --> 00:26:18.620
In the original,
the wires in principle could carry signals in both directions.

386
00:26:20.270 --> 00:26:24.890
That was never really used that way and so I figured it was safe to go ahead and

387
00:26:24.891 --> 00:26:29.150
in the simulator treat each one of the channels as unidirectional.

388
00:26:31.420 --> 00:26:31.770
<v 1>Okay,</v>

389
00:26:31.770 --> 00:26:36.060
<v 0>so this is kind of the discussion about how those trunks work.</v>

390
00:26:37.920 --> 00:26:42.540
Now let me mention the handshaking
in the original machine,

391
00:26:43.560 --> 00:26:47.850
when the clocking unit,
the cycling unit transmitted,

392
00:26:47.910 --> 00:26:50.520
say a central programming pulse throughout the machine,

393
00:26:51.300 --> 00:26:55.680
then of course each unit would respond to that.
It would potentially as a result,

394
00:26:55.681 --> 00:26:58.890
send out other signals now,

395
00:26:59.680 --> 00:27:00.020
<v 2>okay.</v>

396
00:27:00.020 --> 00:27:04.730
<v 0>The design of the machine was such that before the next pulse,</v>

397
00:27:04.760 --> 00:27:07.070
the next cycle of about a hundred kilohertz clock,

398
00:27:07.580 --> 00:27:11.120
we could rely on all of the circuits having finished what they were doing with

399
00:27:11.121 --> 00:27:11.990
that first pulse.

400
00:27:16.710 --> 00:27:19.530
If you're writing code running on a timesharing operating system,

401
00:27:19.890 --> 00:27:20.910
it ain't so predictable.

402
00:27:22.980 --> 00:27:27.900
And in fact that turned out to be an issue that I ran into on some platforms.

403
00:27:27.960 --> 00:27:31.050
It seemed to run quite stable.
Lee on other platforms,

404
00:27:31.500 --> 00:27:34.620
it would fail tests and digging in.

405
00:27:35.250 --> 00:27:37.740
I was finding things like,
oh,

406
00:27:38.190 --> 00:27:40.680
this signal was happening before this signal,

407
00:27:40.830 --> 00:27:42.240
when it should be the other way around.

408
00:27:43.920 --> 00:27:48.780
So I swallowed hard and said,
okay,

409
00:27:49.080 --> 00:27:51.380
I'll go ahead and implement a handshaking mechanisms.

410
00:27:51.840 --> 00:27:55.740
So the idea is that if I receive a clock signal,

411
00:27:57.360 --> 00:28:01.020
I'm not going to send back the acknowledgement until I have finished with

412
00:28:01.021 --> 00:28:06.021
anything I'm sending and gotten the acknowledgements for those and then I'll be

413
00:28:06.481 --> 00:28:07.710
able to send my acknowledgement back.

414
00:28:07.950 --> 00:28:11.790
So that ends up actually throttling the speed of the simulator a bit.

415
00:28:12.810 --> 00:28:17.400
And some people are a little surprised to find that the simulator actually runs

416
00:28:17.401 --> 00:28:21.040
slightly slower than the original machine.
Um,

417
00:28:22.650 --> 00:28:27.630
yes,
the original machine was quite slow,
but this simulator is even slower.

418
00:28:28.080 --> 00:28:31.440
Um,
but again it gets down to that working at a very low level.

419
00:28:33.390 --> 00:28:37.500
Okay.
So how did the accumulators work?
As I said,

420
00:28:37.501 --> 00:28:42.450
this is where most of the computation takes place and the way it is set up is

421
00:28:42.480 --> 00:28:45.390
each accumulators source 10 decimal digits

422
00:28:47.490 --> 00:28:51.750
and it does so by using a 10 stage ring counter and the ring counters were

423
00:28:51.810 --> 00:28:56.040
implemented in these in modules that would plug into the back here.

424
00:28:56.400 --> 00:29:01.400
And so you would have on the machine a vertical line of 10,

425
00:29:01.801 --> 00:29:06.490
the on lamps,
one of which was illuminated.
That was the value of that digit.
Okay.

426
00:29:07.200 --> 00:29:11.760
Then you had 10 of those columns next to each other.
It was the 10 digit number.

427
00:29:12.150 --> 00:29:14.910
And then we also had a sign,
a plus or minus sign.

428
00:29:15.960 --> 00:29:19.410
And of course you look at that and think,
Aha,
they're doing sign magnitude.

429
00:29:20.820 --> 00:29:23.070
Nope,
they're actually,

430
00:29:23.130 --> 00:29:26.040
they've got a sign and they're doing Ken's compliment.

431
00:29:27.750 --> 00:29:30.990
It's kind of a weird combination.
Um,

432
00:29:32.490 --> 00:29:34.190
but of course that means,
you know,

433
00:29:34.200 --> 00:29:38.700
white tooth compliment additions don't have to pay attention to sign.

434
00:29:39.780 --> 00:29:40.613
They do the right thing.

435
00:29:42.400 --> 00:29:46.210
The inputs to the accumulators are labeled by these Greek letters Alpha through

436
00:29:46.211 --> 00:29:48.400
epsilon.
Um,

437
00:29:49.090 --> 00:29:54.090
each one of those represents a channel over which I can take these 10 digits and

438
00:29:55.241 --> 00:29:59.770
parallel and add to whatever is in the cumulate are currently,

439
00:30:02.280 --> 00:30:04.860
the outputs are labeled a,
an s,

440
00:30:05.400 --> 00:30:09.780
the output is an additive output and the output is a subtractive output.

441
00:30:10.590 --> 00:30:13.290
The idea is that if I want to add,

442
00:30:13.770 --> 00:30:17.310
I'll transmit on the edit of output and whoever receives it,

443
00:30:17.670 --> 00:30:22.210
we'll get that added to their current value.
If I'm subtracting,
I'll,

444
00:30:22.220 --> 00:30:27.220
I'll put on the s output and then whoever receives it will get the difference

445
00:30:28.110 --> 00:30:33.110
and the way it does it is by sending the number as it's stored on the AI output

446
00:30:33.871 --> 00:30:36.240
and sending the compliment or the number over the SL put.

447
00:30:40.540 --> 00:30:41.373
<v 2>Okay.</v>

448
00:30:42.050 --> 00:30:47.050
<v 0>For each of 12 different operations you can trigger on an accumulator,</v>

449
00:30:48.110 --> 00:30:53.030
you've got switches that let you set what that operation is going to do and

450
00:30:53.090 --> 00:30:54.620
basically you can either say,

451
00:30:54.621 --> 00:30:59.570
I'm going to receive on one of the inputs or I'm going to output on one or both

452
00:30:59.571 --> 00:31:03.530
of the outputs or,
and you got to love this.

453
00:31:05.020 --> 00:31:05.870
They've got to know op.

454
00:31:10.170 --> 00:31:14.730
It turns out that no op is actually used fairly often on the enac.
Um,

455
00:31:16.890 --> 00:31:21.210
you've got a couple of other controls,
uh,
one of which says if I'm transmitting,

456
00:31:21.211 --> 00:31:24.370
do I clear the accumulator after,
um,

457
00:31:25.410 --> 00:31:27.690
that same control if I'm receiving,

458
00:31:27.691 --> 00:31:32.691
I actually get an extra one added in and that has to do with the nines versus

459
00:31:33.031 --> 00:31:38.031
tens compliment may remember and go all the way back to your freshman year in

460
00:31:38.941 --> 00:31:43.730
college when you were taught about ones and twos complement once complement your

461
00:31:43.740 --> 00:31:47.250
football,
the bits for twos complement,
you'll flip all the bits and add one.

462
00:31:47.700 --> 00:31:52.100
Same sort of thing happens with nine and tens compliment to get from nine's

463
00:31:52.110 --> 00:31:54.030
complement to tens complement.
You just add one.

464
00:31:54.630 --> 00:31:59.630
And so that correct setting is about adding an extra one for that.

465
00:32:00.540 --> 00:32:03.930
The other thing we've got is a nice little repeat mechanism still.

466
00:32:03.931 --> 00:32:06.570
If I want to add three x to y,

467
00:32:08.070 --> 00:32:11.520
then I don't have to set it up as three separate operations.

468
00:32:11.730 --> 00:32:13.770
I can set it up as one operation,

469
00:32:13.771 --> 00:32:17.730
which x is transmitted three times and why receives three times.

470
00:32:18.780 --> 00:32:23.780
So small integer coefficients in your equations don't actually have to go

471
00:32:24.121 --> 00:32:24.954
through the multiplier.

472
00:32:25.920 --> 00:32:28.800
You only need the multiplier when you're multiplying two variables together.

473
00:32:31.560 --> 00:32:34.770
So here's how the whole thing works.

474
00:32:35.160 --> 00:32:37.380
This gets us into those pulses I was talking about.

475
00:32:38.370 --> 00:32:43.370
These are two lines from the clocking diagram with the group of 10 and the group

476
00:32:43.371 --> 00:32:46.340
of nine.
Now if I think about a digit,

477
00:32:47.540 --> 00:32:49.190
say its value is for,

478
00:32:51.530 --> 00:32:56.420
then I want to transmit four pulses out the ace side for that digit.

479
00:32:57.710 --> 00:33:00.440
I want to send the nine's complement of that,

480
00:33:00.770 --> 00:33:04.040
which would be five pulses out the s side.

481
00:33:04.520 --> 00:33:07.220
The reality is I'm always going to be sending mine pulses.

482
00:33:07.370 --> 00:33:11.060
It's just which of them are going out the a in which are going out the yes.

483
00:33:12.650 --> 00:33:14.270
So the cleverness is,

484
00:33:14.690 --> 00:33:18.380
well what we'll do is we'll take the value in that digit,

485
00:33:19.310 --> 00:33:23.660
feed 10 pulses into it that causes the ring counter to go all the way back

486
00:33:23.661 --> 00:33:27.080
around to where it started and in the process of doing so,

487
00:33:27.081 --> 00:33:28.940
at some point it's going to go from nine to zero.

488
00:33:29.930 --> 00:33:33.620
And what happens when we go from nine to zero,
we set a carry

489
00:33:35.690 --> 00:33:37.700
and it turns out that if you think about it for a second,

490
00:33:37.701 --> 00:33:42.650
the carry is exactly when I need to switch from out putting on one of the

491
00:33:42.651 --> 00:33:47.600
terminals to switching to the other.
So we start out sending out the esport.

492
00:33:48.200 --> 00:33:49.700
As soon as the carry hits,

493
00:33:49.790 --> 00:33:52.910
we switched and send the rest of the nine pulses out the port.

494
00:33:53.840 --> 00:33:57.680
And this is how we read information from the accumulators.

495
00:33:58.200 --> 00:34:00.650
It was easy enough to figure out how to make an ad,

496
00:34:00.980 --> 00:34:05.060
but how do you read the information out?
That wasn't as obvious.

497
00:34:06.200 --> 00:34:06.480
<v 1>Okay.</v>

498
00:34:06.480 --> 00:34:09.390
<v 0>People were used to using these sorts of counters.
In fact,</v>

499
00:34:09.660 --> 00:34:11.280
Eckert had a lot of experience.

500
00:34:12.450 --> 00:34:17.130
People doing nuclear research had these decade counters that they were using for

501
00:34:17.430 --> 00:34:18.480
measuring radiation.

502
00:34:19.530 --> 00:34:23.430
But of course the information that you got out of the counter was always a human

503
00:34:23.431 --> 00:34:24.810
being.
Looking at the lights,

504
00:34:26.720 --> 00:34:29.050
how do you pull the information out and use it somewhere else?

505
00:34:30.100 --> 00:34:32.650
This really clever approach is what they used.

506
00:34:33.070 --> 00:34:38.070
And what I'm going to do right now is in the simulator illustrate that in

507
00:34:39.521 --> 00:34:43.820
operation.
So here is an image of the simulator.
Uh,

508
00:34:43.900 --> 00:34:48.700
what I've done is I've sort of zoomed in on one section of the machine.
Um,

509
00:34:49.690 --> 00:34:51.490
depending on what you're doing with it,

510
00:34:51.700 --> 00:34:55.150
this view of the whole machine is a little bit more impressive,

511
00:34:55.390 --> 00:34:58.030
especially when the lights are moving and doing all sorts of fun stuff.

512
00:34:58.330 --> 00:35:02.350
But right now we're going to be looking at just a few parts of the machine.

513
00:35:02.351 --> 00:35:06.570
In particular.
The leftmost unit in this figures,

514
00:35:06.580 --> 00:35:07.980
the divider square ruder,

515
00:35:07.990 --> 00:35:12.370
and then immediately to its right are a set of seven accumulators.

516
00:35:12.520 --> 00:35:15.670
And the first three of those accumulators are what we're going to be using right

517
00:35:15.671 --> 00:35:16.504
now.

518
00:35:17.650 --> 00:35:21.670
The other thing I'll point out here is that in the lower left hand corner of

519
00:35:21.671 --> 00:35:26.260
this image is a representation of a control box.
In fact,

520
00:35:26.261 --> 00:35:28.210
it's got some uh,

521
00:35:28.420 --> 00:35:33.420
photographic remnant of the real thing and this is what the control box look

522
00:35:34.961 --> 00:35:39.120
like.
This is a three d printed reproduction of it.

523
00:35:39.870 --> 00:35:44.250
Uh,
this one is actually set up to be able to plug it into a simulator running on

524
00:35:44.260 --> 00:35:47.550
raspberry Pi and actually control the INAC.

525
00:35:48.300 --> 00:35:53.300
The neat thing about this was it really showed a great deal of foresight into

526
00:35:54.211 --> 00:35:55.500
the questions of debugging.

527
00:35:57.030 --> 00:36:00.420
One of the most important things that this lets you do is single step the

528
00:36:00.421 --> 00:36:03.030
machine.
In fact,
you,

529
00:36:03.120 --> 00:36:07.530
this switch lets you control what level of granularity you're single stepping is

530
00:36:07.531 --> 00:36:10.620
doing
and it had a long enough cord,

531
00:36:10.621 --> 00:36:13.980
you could walk around the whole machine so you could walk up to any accumulator

532
00:36:14.310 --> 00:36:18.390
and just sit there and go,
ah Ha,
here's the mistake.

533
00:36:19.710 --> 00:36:24.710
So what I'm going to be doing right now is doing the on screen version of that

534
00:36:27.480 --> 00:36:32.040
right down here.
And so this is how I'm going to be controlling it
right now.

535
00:36:32.041 --> 00:36:35.820
I've got the clocking mode set that every time I hit the pulse button,

536
00:36:36.030 --> 00:36:39.510
one addition time's worth of activities going to take place.

537
00:36:41.670 --> 00:36:44.940
So initially all hit the initialize button,

538
00:36:44.941 --> 00:36:49.560
which sends out a pulse that is meant to start the first stage of the

539
00:36:49.561 --> 00:36:52.470
computation.
And in this case,

540
00:36:52.650 --> 00:36:57.650
the first stages are loading some values in.

541
00:36:57.720 --> 00:37:01.080
Now if you look carefully,
the first accumulator,

542
00:37:01.110 --> 00:37:05.970
that second panel here now has a couple of values in it that weren't there

543
00:37:05.971 --> 00:37:06.804
before.

544
00:37:07.620 --> 00:37:11.970
The first digit is moved up one place and there's this next digit over here has

545
00:37:11.971 --> 00:37:15.690
moved up five.
So we've stored the number 15 in this accumulator.

546
00:37:17.490 --> 00:37:18.660
I'm going to hit another pulse.

547
00:37:18.720 --> 00:37:22.950
What's going to happen is in parallel when a load of value into both of these,

548
00:37:25.420 --> 00:37:30.420
and in this case the value loaded into each of those is 27 so we've got 15 in

549
00:37:31.361 --> 00:37:33.520
the first accumulator,
27 and the other two.

550
00:37:33.940 --> 00:37:38.770
And what I'm going to do now is go through that step by step of how it transmits

551
00:37:38.771 --> 00:37:40.120
from one place to another.

552
00:37:41.650 --> 00:37:44.830
The additive output's going to go into one of the other accumulators and the

553
00:37:44.831 --> 00:37:46.000
subtractive into the other.

554
00:37:46.270 --> 00:37:50.440
So I'm going to simultaneously be computing the sum of 15 and 27 and the

555
00:37:50.441 --> 00:37:55.441
difference of 15 and 27 so let me switch the clock now to the single pulse mode.

556
00:37:58.030 --> 00:38:02.230
And we now begin this sequence.
So here,

557
00:38:02.680 --> 00:38:06.310
if you look at the one on the left,
all of the positions have moved up one spot.

558
00:38:06.340 --> 00:38:08.770
That's one of those 10 pulses.

559
00:38:09.370 --> 00:38:11.590
And as we're going through those 10 pulses,

560
00:38:12.010 --> 00:38:16.990
you see that some of the things are also causing things to climb on the other

561
00:38:16.991 --> 00:38:17.980
two accumulators.

562
00:38:18.730 --> 00:38:22.090
And the lights underneath are the carry lights.

563
00:38:22.780 --> 00:38:25.120
So they tell you when it's going from one to the other.

564
00:38:25.510 --> 00:38:27.610
Once we've resolved all of the caries,

565
00:38:28.420 --> 00:38:33.420
we now have in the second accumulator a psalm of 42 and in the third

566
00:38:34.061 --> 00:38:35.620
accumulator,
the difference 12th.

567
00:38:38.030 --> 00:38:40.580
So when you're operating the enac,

568
00:38:40.610 --> 00:38:42.830
that's basically the way you're doing arithmetic

569
00:38:44.510 --> 00:38:48.260
is you're counting pulses on a percentage basis.

570
00:38:50.940 --> 00:38:51.900
<v 2>And if</v>

571
00:38:53.640 --> 00:38:56.520
<v 0>you can't figure out what went wrong,
you've got your debugger.</v>

572
00:38:59.640 --> 00:39:01.350
Actually,
kind of like this kind of a debugger,

573
00:39:02.580 --> 00:39:06.720
which we had this on real computers or modern computers,
I should say.

574
00:39:07.430 --> 00:39:08.200
Uh,

575
00:39:08.200 --> 00:39:12.360
I sometimes tell folks that a special my students that it's not a real computer

576
00:39:12.361 --> 00:39:16.230
if there's not blinking lights.
I mean let's face it,

577
00:39:16.950 --> 00:39:19.020
we haven't had good computer since the PDP 11 heavily.

578
00:39:22.290 --> 00:39:23.310
Um,
okay.

579
00:39:25.260 --> 00:39:28.500
So the next piece of this that I want to mention is the master programmer.

580
00:39:29.790 --> 00:39:33.540
The idea here is that yes,

581
00:39:33.570 --> 00:39:38.570
it's fairly easy to build a sequence of operations where the output terminal

582
00:39:38.641 --> 00:39:42.030
from one operation triggers the next operation.

583
00:39:43.050 --> 00:39:45.720
But how do you go about doing repetition?

584
00:39:46.980 --> 00:39:49.350
How do you do conditional operations?

585
00:39:51.060 --> 00:39:54.690
The master programmer is the equipment they put in for that purpose.

586
00:39:56.630 --> 00:40:01.340
Now it's not as completely general as we usually think of in terms of a typical

587
00:40:01.341 --> 00:40:02.420
store program types.

588
00:40:02.421 --> 00:40:06.590
Sarah scenario where you've got a jump instruction and you can organize them

589
00:40:06.591 --> 00:40:10.670
however you want,
but it was very flexible.

590
00:40:11.600 --> 00:40:16.280
It contained 10 counters of six stages each.

591
00:40:17.240 --> 00:40:18.440
These calendars,

592
00:40:18.470 --> 00:40:22.790
these six stage counters represented phases of a computation.

593
00:40:23.930 --> 00:40:25.460
And so every time you advance that,

594
00:40:25.461 --> 00:40:30.410
you would go to the next phase of the computation.
For each one of those phases,

595
00:40:30.830 --> 00:40:35.830
you had counters that you could set to be a simple limit on how many iterations

596
00:40:36.561 --> 00:40:37.394
to perform

597
00:40:40.480 --> 00:40:42.910
total of 20 digits worth of counters.

598
00:40:42.970 --> 00:40:45.760
And you could kind of reassign them to different state,

599
00:40:45.790 --> 00:40:48.280
a different ones of the six stage counters as needed.

600
00:40:49.060 --> 00:40:53.190
So you could really build these very complex nested loop structures if you want

601
00:40:53.191 --> 00:40:54.024
it.

602
00:40:55.730 --> 00:40:56.563
<v 2>Okay.</v>

603
00:40:56.730 --> 00:40:58.860
<v 0>Another neat thing that happens is</v>

604
00:41:01.440 --> 00:41:06.090
we have these,
uh,
interesting cabling structures here,

605
00:41:06.600 --> 00:41:10.350
but we have special adapter cables that will take one of those multi pin

606
00:41:10.351 --> 00:41:15.351
connectors and break it out into 11 of the individual control connectors.

607
00:41:16.920 --> 00:41:19.290
And since the pole shapes are exactly the same,

608
00:41:20.310 --> 00:41:22.650
we can take a digit output and use it as control.

609
00:41:25.410 --> 00:41:27.600
So for example,
if I take the sign output,

610
00:41:29.430 --> 00:41:32.580
I can use that to discriminate between positive and negative.
Okay.

611
00:41:34.400 --> 00:41:37.190
So the conditional values that they used,
in fact,

612
00:41:37.191 --> 00:41:40.040
the term they used in the manual was magnitude discrimination,

613
00:41:41.060 --> 00:41:45.620
was to determine the comparison of two magnitudes.
And it was typically,

614
00:41:45.621 --> 00:41:48.110
or one of the most common forms was in terms of the sign,

615
00:41:48.350 --> 00:41:49.550
was it positive or negative?

616
00:41:51.080 --> 00:41:56.080
So by introducing a data signal into the control structure,

617
00:41:58.820 --> 00:42:03.820
you could generate a control pulse only if a certain result was negative or only

618
00:42:04.371 --> 00:42:08.870
if it was non negative.
And by doing that you got conditional branching.

619
00:42:10.970 --> 00:42:15.380
And that of course as we know,
turned out to be the key thing.

620
00:42:16.370 --> 00:42:21.370
Once you had that you had Turing completeness and that's why they were able then

621
00:42:21.381 --> 00:42:24.740
to look at building a,
an instruction set decoder.

622
00:42:25.070 --> 00:42:29.360
Well in fact they actually had some clever use of the master programmer in the

623
00:42:30.050 --> 00:42:34.490
original thoughts for the instruction said decoding where they would use what

624
00:42:34.491 --> 00:42:39.491
amount of to the 60 different outputs from the stages as innocence,

625
00:42:41.390 --> 00:42:43.970
the instruction decoding.
So if you were,

626
00:42:44.260 --> 00:42:46.850
had gotten an instruction set of 60 or fewer instructions,

627
00:42:47.090 --> 00:42:49.280
you can implement it directly on the existing hardware.

628
00:42:50.640 --> 00:42:55.640
Now it turns out what they actually did in practice was they decided they wanted

629
00:42:55.701 --> 00:42:57.140
a more rich instruction set.

630
00:42:57.770 --> 00:43:01.760
So they added another component that would take a two digit number and break it

631
00:43:01.761 --> 00:43:05.780
out to 100 connections.
And they called that the converter units.

632
00:43:06.110 --> 00:43:09.710
So that's what was actually deployed.
Um,

633
00:43:09.890 --> 00:43:13.790
the other neat thing about this is that if I take instead of a sign a digit and

634
00:43:13.791 --> 00:43:16.460
feed it into one of these six stage counters,

635
00:43:17.330 --> 00:43:21.590
I basically get what any old fortran folks in here,

636
00:43:23.110 --> 00:43:27.710
what we call a computer go.
Essentially,

637
00:43:27.711 --> 00:43:32.630
you take the value of this integer and it selects one of six possible actions.

638
00:43:33.740 --> 00:43:37.550
Uh,
there's an example in the technical manual that,
uh,

639
00:43:37.670 --> 00:43:42.670
takes a pair of the six stage counters and divides it into two groups of five.

640
00:43:43.100 --> 00:43:46.760
And the Ben,
you've got now 10 options from a single digit.

641
00:43:49.790 --> 00:43:53.360
So one example of using this is calculating,

642
00:43:53.361 --> 00:43:54.830
say a table of squares.

643
00:43:56.930 --> 00:43:59.000
And I'm not going to go through a lot of the detail of this.

644
00:43:59.001 --> 00:44:02.470
I'll just suggest that if you take a look at the slides later and you want to

645
00:44:02.780 --> 00:44:06.800
kind of figure out how this works,
we're not actually squaring anything.

646
00:44:06.830 --> 00:44:09.920
We're just using everybody's favorite relation from uh,

647
00:44:10.340 --> 00:44:15.340
high school x plus one squared is x squared plus two x plus one and neat little

648
00:44:16.581 --> 00:44:18.860
things like two x.
Well,

649
00:44:18.861 --> 00:44:22.670
we just use the repeat mechanism on the accumulators to do that.

650
00:44:23.840 --> 00:44:27.530
Um,
okay.

651
00:44:27.560 --> 00:44:31.220
At this by the way,
is how you would wire up that problem.

652
00:44:33.690 --> 00:44:36.090
This is in effect your source code.

653
00:44:37.730 --> 00:44:38.563
<v 1>Okay.</v>

654
00:44:40.090 --> 00:44:45.090
<v 0>The switch settings are indicated by values in these boxes and then the wiring</v>

655
00:44:46.331 --> 00:44:50.000
is indicated
on the top and bottom,

656
00:44:50.001 --> 00:44:53.600
the data trunks up here and the controlled trucks down here.

657
00:44:55.340 --> 00:45:00.340
And this is the way in which you would typically specify a program.

658
00:45:01.730 --> 00:45:03.740
They had a few other variations on this,

659
00:45:03.920 --> 00:45:07.850
but this was a very direct one because now you can take that walk into the

660
00:45:07.851 --> 00:45:09.650
machine room and wired up.

661
00:45:11.710 --> 00:45:15.100
And one of the ways this was frequently done was one person was standing in the

662
00:45:15.101 --> 00:45:19.520
middle of the room with the papers and call out accumulator,

663
00:45:19.521 --> 00:45:20.950
a 12 program,

664
00:45:20.951 --> 00:45:24.700
three switch setting alpha and there would be a person standing at that

665
00:45:24.790 --> 00:45:28.090
accumulator and turn the switch and you would have this whole room full of

666
00:45:28.091 --> 00:45:30.910
people programming the machine that way.

667
00:45:33.110 --> 00:45:35.980
Um,
as you might guess,

668
00:45:36.730 --> 00:45:41.730
bugs in the form of plugging in the wrong cable or setting the wrong switch.

669
00:45:42.340 --> 00:45:46.900
Those were pretty common.
Um,
okay.

670
00:45:46.960 --> 00:45:48.460
I've already really kind of mentioned this,

671
00:45:48.461 --> 00:45:50.710
so I don't want to spend too much time on that.

672
00:45:50.740 --> 00:45:53.130
I do want to mention a little bit about,
um,

673
00:45:53.260 --> 00:45:56.590
how this user interface came about that,
uh,
I showed you

674
00:45:58.210 --> 00:46:01.090
what you saw was just the graphical part of it.

675
00:46:01.540 --> 00:46:03.400
There's actually also a command line interface,

676
00:46:03.401 --> 00:46:05.260
which is really from the codes perspective,

677
00:46:05.261 --> 00:46:09.700
the main interface and it's a very primitive sort of a thing.

678
00:46:10.630 --> 00:46:13.750
You know,
I am an old timer in that regard.

679
00:46:15.940 --> 00:46:19.420
Why type three characters,
if I can type one,
let's face it,

680
00:46:20.230 --> 00:46:23.530
there's nothing wrong with a variable called high.
Um,

681
00:46:24.310 --> 00:46:29.080
so it's got a very simple single letter commands and abbreviations to refer to

682
00:46:29.081 --> 00:46:31.450
the unit.
So for example,
if I'm going to set a switch setting,

683
00:46:32.080 --> 00:46:36.550
the command is s I'll specify which switch and then a value.

684
00:46:36.790 --> 00:46:39.910
And so you get this nice little three fields in the line,

685
00:46:40.450 --> 00:46:43.750
which looks a lot like assembly language.
In fact,

686
00:46:45.100 --> 00:46:48.070
I was comparing notes and discussing,
uh,

687
00:46:48.130 --> 00:46:52.870
this work with another person who had done in any acts simulator and he liked

688
00:46:52.871 --> 00:46:56.350
that format.
So he converted his to use it.
And between the two of us,

689
00:46:56.351 --> 00:47:00.490
we started calling it the Enac Assembly language.
Um,

690
00:47:00.820 --> 00:47:04.480
so it turns out then if you want to have a configuration file that wires up the

691
00:47:04.481 --> 00:47:05.560
whole setting,

692
00:47:06.580 --> 00:47:09.610
it's just a file you read that look like commands that the user's stocked.

693
00:47:10.480 --> 00:47:13.750
So nothing special in terms of configuration files.
Uh,

694
00:47:13.751 --> 00:47:17.020
so how's the graphical stuff done?
Well,

695
00:47:17.380 --> 00:47:20.980
a long time ago I reached the point where I decided I was done dealing with

696
00:47:20.981 --> 00:47:25.330
graphical libraries.
Every one of them is different.
None of them are any good.

697
00:47:27.310 --> 00:47:29.440
I'm going to let tcl TK do the for me.

698
00:47:30.730 --> 00:47:34.480
So all I do is create a child process running wish,

699
00:47:34.510 --> 00:47:39.310
which is the windowing shell from tcl TK.
I set up a couple of pipes,

700
00:47:39.820 --> 00:47:42.820
one that becomes it standard input.
When that becomes the standard output,

701
00:47:43.600 --> 00:47:45.100
when I want to do something on the screen,

702
00:47:45.101 --> 00:47:49.090
I just shoot commands down and that happens on the screen.

703
00:47:49.780 --> 00:47:51.670
When somebody pushes a button on the screen,

704
00:47:52.030 --> 00:47:56.860
it just sends back a message that happens to be exactly the same format as what

705
00:47:56.861 --> 00:47:58.840
would happen if you type the command at the command line window.

706
00:48:01.590 --> 00:48:06.450
The beauty of this is it's completely portable,
TCPA,

707
00:48:07.410 --> 00:48:09.570
tcl.
Tk has been poured to virtually everything

708
00:48:11.070 --> 00:48:15.540
and I don't have to think about anybody else's graphical environment.

709
00:48:15.840 --> 00:48:18.690
I don't have to think about anything.
It does it all for me.

710
00:48:19.110 --> 00:48:22.800
So this has kind of become my standard way of doing graphics.

711
00:48:23.220 --> 00:48:27.270
The other thing that's kind of interesting about this is where did these images

712
00:48:27.271 --> 00:48:28.104
come from?

713
00:48:30.690 --> 00:48:34.080
There's no actual photograph of the machine that looks like that,

714
00:48:35.370 --> 00:48:39.060
but there are lots of photographs of different bits of the machine.

715
00:48:40.980 --> 00:48:45.570
So I actually went through scoured many hundreds of photographs and found like

716
00:48:45.690 --> 00:48:49.620
the best photograph of this part right here in this part right here in this part

717
00:48:49.621 --> 00:48:50.454
right here.

718
00:48:50.520 --> 00:48:55.380
And then pasted them together into units and then a wrote a custom ray tracer

719
00:48:55.400 --> 00:48:56.370
degenerate the depth.

720
00:48:58.710 --> 00:49:01.830
So that's how that's perspective image came about.

721
00:49:03.600 --> 00:49:08.250
All right,
let's see.
Believe,
yeah,

722
00:49:08.310 --> 00:49:10.530
here's a couple of examples of it running.

723
00:49:10.800 --> 00:49:12.420
My favorite one is the one on the right.

724
00:49:12.900 --> 00:49:16.050
If you remember a little device called the chip a few years ago,

725
00:49:16.380 --> 00:49:20.430
it was a Kickstarter or they ended up closing up a little arm machine.

726
00:49:21.420 --> 00:49:23.130
That's it.
Running on it little pocket thing.

727
00:49:23.190 --> 00:49:24.600
I meant to bring it with me and forgot.

728
00:49:25.350 --> 00:49:27.600
Now I promised this to kind of come full circle,

729
00:49:28.290 --> 00:49:32.490
so I need to talk about one more connection between going the ENIAC and it

730
00:49:32.491 --> 00:49:36.360
starts with this guy right here,
Harry Husky.

731
00:49:37.350 --> 00:49:42.030
Husky is probably one of the most influential and least known figures in the

732
00:49:42.031 --> 00:49:42.864
history of computing.

733
00:49:44.670 --> 00:49:48.270
He only passed away recently at the age of 101

734
00:49:51.620 --> 00:49:56.620
his role on the any ACC was as the designer of the interface units between the

735
00:49:56.631 --> 00:49:59.690
[inaudible] and the punch cards.
Carden punch

736
00:50:02.150 --> 00:50:06.740
later after the design work had been done in the machine was under construction.

737
00:50:06.741 --> 00:50:09.950
The team begins working on their follow on project,
the Ed Vac,

738
00:50:10.100 --> 00:50:13.130
and he was a part of that.
After the war,

739
00:50:13.550 --> 00:50:17.870
he took a sabbatical and he went to England where he was at the national

740
00:50:17.871 --> 00:50:18.800
physical laboratory.

741
00:50:19.760 --> 00:50:23.180
And if you've followed the history of Alan Turing,

742
00:50:23.360 --> 00:50:27.470
you'll know that's where he went after Bletchley Park.
Well.

743
00:50:27.500 --> 00:50:32.120
Husky was intrigued at some of touring's architectural ideas for building

744
00:50:32.121 --> 00:50:35.540
computers and he pushed the folks that,
uh,

745
00:50:35.600 --> 00:50:40.430
NPL to build a sort of small pilot version of this work.

746
00:50:41.660 --> 00:50:46.010
Well,
a project kind of started in fizzled while he was there,

747
00:50:46.011 --> 00:50:46.910
but after he left,

748
00:50:47.330 --> 00:50:50.540
that same project got resurrected and produced the machine that we now know

749
00:50:50.541 --> 00:50:51.860
today as the pilot.
Nice,

750
00:50:53.510 --> 00:50:57.680
very interesting architecture if you study it.
After that,

751
00:50:57.681 --> 00:51:02.681
he comes back to the u s he goes out to California and is the lead engineer on

752
00:51:04.491 --> 00:51:06.590
the development of a machine called the Swhack.

753
00:51:07.190 --> 00:51:10.400
The Standards Western Automatic Computer National Bureau of standards built two

754
00:51:10.401 --> 00:51:14.630
machines in these early days and he was the lead for the one on the west coast.

755
00:51:16.040 --> 00:51:19.400
After that,
he joined the faculty at the University of California Berkeley.

756
00:51:20.810 --> 00:51:24.290
Now,
while he was at Berkeley,
he had several notable students.

757
00:51:25.460 --> 00:51:30.460
One of his phd students was Nicholas feared the person who then went on to do

758
00:51:30.651 --> 00:51:33.950
the languages.
Pascal Modular Oberon,

759
00:51:35.420 --> 00:51:37.970
one of his master's students was this fellow right here,

760
00:51:40.430 --> 00:51:42.860
Ken Thompson,
who of course,
as we know,

761
00:51:42.861 --> 00:51:46.490
went on to work on the multex project at bell labs.

762
00:51:47.870 --> 00:51:51.650
Then when bell labs dropped out of Multex,
he said,

763
00:51:52.100 --> 00:51:55.040
let me find something interesting to work on.
And as he puts it,

764
00:51:55.041 --> 00:51:56.960
he found the little used PDP seven.

765
00:51:57.170 --> 00:52:01.070
He was going to do space exploration type stuff.
We'll space war games

766
00:52:02.570 --> 00:52:07.280
and decided now I need to build me a little operating system.
And that was Unix.

767
00:52:07.910 --> 00:52:12.470
And of course,
we all know from there he had,
uh,
developed the language,

768
00:52:12.471 --> 00:52:17.471
be Dennis Richie added types to make it see before he retired,

769
00:52:18.501 --> 00:52:21.680
Ken was working for Google as one of the key developers on goat.

770
00:52:22.520 --> 00:52:27.050
So that's how it actually comes all the way full circle.
All right.
Any questions?

771
00:52:34.260 --> 00:52:38.440
All right,
well,
I think we've used right at an hour,

772
00:52:38.441 --> 00:52:41.230
so thank you very much.
And uh,
have good rest of the day.

773
00:52:41.980 --> 00:52:44.330
<v 1>[inaudible].</v>

