WEBVTT

1
00:00:08.680 --> 00:00:11.020
Okay.
So,
um,
welcome mark.
Good morning everyone.

2
00:00:11.030 --> 00:00:15.250
Now it's my pleasure to welcome professor Osterhout for the stocks at Google

3
00:00:15.251 --> 00:00:15.830
presentation.

4
00:00:15.830 --> 00:00:20.350
Now my name is Porter Aminata and I work and technical infrastructure cloud.

5
00:00:20.830 --> 00:00:25.210
A very quick intro to John to get things started here.
Uh,
John is the,
uh,
uh,

6
00:00:25.220 --> 00:00:29.950
is a professor of computer science at Stanford University.
He spent before that,

7
00:00:30.000 --> 00:00:33.580
uh,
14 years in industry where he founded two companies,

8
00:00:33.581 --> 00:00:36.280
cryptics and electric cloud.
And before that,

9
00:00:36.281 --> 00:00:39.190
14 years as a professor at UC Berkeley.

10
00:00:39.430 --> 00:00:42.400
Anybody here who has taken a class with John before?

11
00:00:42.750 --> 00:00:45.040
So a bunch of his students as well.
Uh,

12
00:00:45.100 --> 00:00:48.560
so he's a pretty distinguished or I'm not going to go through a list of his,
uh,

13
00:00:48.580 --> 00:00:49.480
awards here.

14
00:00:49.900 --> 00:00:54.550
A member of the National Academy of Engineering got a ATM software system about

15
00:00:55.060 --> 00:00:58.870
a UC Berkeley distinguished teaching award to name a few here,

16
00:00:59.220 --> 00:01:01.020
a but more relevant to this talk.

17
00:01:02.010 --> 00:01:04.690
John has built several influential systems.

18
00:01:04.890 --> 00:01:09.760
The sprite operating system tickled TK log structured file systems laugh,

19
00:01:10.260 --> 00:01:14.160
uh,
and more recently a ram cloud.
And,
uh,
and I think,
uh,

20
00:01:14.200 --> 00:01:17.410
his bio says he has literally created like thousands of programming,

21
00:01:17.411 --> 00:01:19.810
student assignment and,
and,

22
00:01:19.811 --> 00:01:23.430
and today we are going to hear the synthesis of all of John's firsthand

23
00:01:23.440 --> 00:01:23.771
knowledge,

24
00:01:23.771 --> 00:01:27.700
both from this research and teaching on a topic that's very close to us.
How to,

25
00:01:27.701 --> 00:01:31.650
uh,
how to design and how not to design software.
Uh,

26
00:01:31.870 --> 00:01:35.350
there is a book here,
I don't have it to show.
Uh,
can I,

27
00:01:35.500 --> 00:01:38.110
let me show it to the camera here.
There is a book,

28
00:01:38.120 --> 00:01:40.700
a philosophy of software design numb.
I,
uh,

29
00:01:40.760 --> 00:01:45.310
I was pretty lucky to lead the pre print of this.
It's a really good book and a,

30
00:01:45.311 --> 00:01:47.290
and hopefully he'll tell us a little bit more about that as well.

31
00:01:47.410 --> 00:01:51.730
And the last note,
if you have questions,
since this is being recorded,

32
00:01:51.940 --> 00:01:54.730
just raise your hand and we'll get the Mike to you and then you can ask

33
00:01:54.731 --> 00:01:56.470
questions.
So welcome John.

34
00:01:57.000 --> 00:01:57.780
<v 2>Great.
Thank you.</v>

35
00:01:57.780 --> 00:02:02.780
<v 0>[inaudible]</v>

36
00:02:03.000 --> 00:02:03.391
<v 2>first of all,</v>

37
00:02:03.391 --> 00:02:06.360
I do not have an hour's worth of material prepared because there will be lots of

38
00:02:06.361 --> 00:02:09.870
questions.
I'm happy to take them in line as we go.
At some point,

39
00:02:09.871 --> 00:02:11.470
probably there'll be too many and we're running late,
then I'll,

40
00:02:11.471 --> 00:02:14.790
I'll cut them off.
But feel free to ask questions,
you know,
express a disbelief,

41
00:02:14.850 --> 00:02:18.490
argue,
insult my mother,
whatever you wish during the talk,
but,

42
00:02:18.500 --> 00:02:23.400
but do make sure that the insults were on the mic.
Okay.

43
00:02:23.550 --> 00:02:26.610
So people have been programming computers for more than 80 years now.

44
00:02:26.640 --> 00:02:30.300
And yet software design is still basically a black art.

45
00:02:31.350 --> 00:02:35.520
There's essentially no agreement on how to do software design or even what a

46
00:02:35.521 --> 00:02:37.560
good piece of software it looks like.
You know,

47
00:02:37.561 --> 00:02:42.210
we talk a lot about software engineering and software tools and testing and

48
00:02:42.211 --> 00:02:43.044
processes,

49
00:02:43.470 --> 00:02:48.470
but we have almost no conversation about the fundamental act of designing

50
00:02:48.721 --> 00:02:50.610
software.
This is bugged me for a long time.

51
00:02:51.180 --> 00:02:54.360
So today I'd like to tell you about some things I've been doing to try and

52
00:02:54.361 --> 00:02:59.260
change that to start the conversation and to see if we can somehow create a
more,

53
00:02:59.261 --> 00:03:02.020
a greater sense of design awareness in the software community.

54
00:03:02.021 --> 00:03:04.330
And that consists of a new course I developed at Stanford.

55
00:03:04.600 --> 00:03:08.140
And then based on that,
a book on software design.
Okay.

56
00:03:08.141 --> 00:03:09.310
So let's start with the basics.

57
00:03:10.450 --> 00:03:13.150
If you had to pick one idea,

58
00:03:13.600 --> 00:03:16.840
one concept fits the most important thing in all of computer science,

59
00:03:16.841 --> 00:03:19.330
one thing that threads through every aspect of computer science,

60
00:03:19.331 --> 00:03:21.990
from AI to systems to theory.
First of all,
what would you pick?

61
00:03:23.890 --> 00:03:27.940
Abstraction,
sorry,
testing or their ideas.

62
00:03:29.380 --> 00:03:33.920
Sorry,
composition.
Sorry.

63
00:03:34.720 --> 00:03:37.870
Complexity.
So I asked Don Knuth this question.

64
00:03:38.050 --> 00:03:42.010
He said layers of abstraction,
which I would say is almost right.

65
00:03:42.520 --> 00:03:44.920
Although some would say by definition it's right.

66
00:03:46.390 --> 00:03:48.700
What I would say is problem decomposition.

67
00:03:49.450 --> 00:03:53.680
How do you take a complicated problem or system and chop it up into pieces that

68
00:03:53.681 --> 00:03:58.210
you can build relatively independently and yet,
as far as I know,

69
00:03:58.840 --> 00:04:00.310
aside from what you're going to hear today,

70
00:04:00.550 --> 00:04:05.020
there is no course anywhere where that concept is one of the most important

71
00:04:05.021 --> 00:04:09.490
ideas in the course.
We simply don't teach it.
Second,

72
00:04:10.240 --> 00:04:14.290
we all know that some programmers are way,
way more productive than others.

73
00:04:14.291 --> 00:04:16.900
Google,
this coined the term,
the 10 x programmer,

74
00:04:17.680 --> 00:04:19.870
and yet as far as I know,

75
00:04:19.930 --> 00:04:22.690
no one attempts to teach these skills either.

76
00:04:23.290 --> 00:04:27.070
And these ideas have been sitting in the back of my head and bugging me for a

77
00:04:27.071 --> 00:04:29.800
long time.
How can we have these things that are so important?

78
00:04:30.400 --> 00:04:34.020
And yet we don't really make any attempt to teach people this stuff?
You know,

79
00:04:34.030 --> 00:04:37.030
if you're a great programmer,
somehow you've just figured out on your own.

80
00:04:39.550 --> 00:04:44.050
So that leads to the question,
can we do this?
And there's three questions there.

81
00:04:44.500 --> 00:04:47.710
First isn't even possible,
you know,
is it,

82
00:04:47.950 --> 00:04:52.300
is this just an sort of innate skill that you're born with in your genes or is

83
00:04:52.301 --> 00:04:55.120
it something that can be taught?
So first,
let's do a quick survey.

84
00:04:55.450 --> 00:04:57.930
How many of you think this is something that's it's,
you know,

85
00:04:57.940 --> 00:04:59.920
either you have it or you don't.
You can't really teach it.

86
00:04:59.950 --> 00:05:01.180
It's just an innate skill.

87
00:05:03.640 --> 00:05:08.110
How many think that this could be taught in some way or another?
Good.

88
00:05:08.200 --> 00:05:11.860
A few summers ago,
I read a really great book by Geoff Colvin.

89
00:05:11.890 --> 00:05:13.360
Title talent is overrated.

90
00:05:13.720 --> 00:05:17.860
If you want to fund read Redis and are relatively quick read in which he goes

91
00:05:17.861 --> 00:05:22.090
through study after study that shows in these fields where we think of some

92
00:05:22.091 --> 00:05:25.150
people as being tremendously talented.
In fact,

93
00:05:25.151 --> 00:05:28.540
the only thing that really differentiates the top performers from the average

94
00:05:28.541 --> 00:05:30.400
performers is how much they've practiced.

95
00:05:30.520 --> 00:05:33.700
That's the one consistent correlating factor they could find.

96
00:05:33.701 --> 00:05:36.190
It's all about practice.
So that got me thinking.

97
00:05:36.250 --> 00:05:39.310
I mean I believe it's got to be possible to teach this,

98
00:05:40.270 --> 00:05:43.960
but the second thing is who's going to do it?
Well,

99
00:05:44.020 --> 00:05:46.630
unfortunately not most of today's faculty,

100
00:05:47.190 --> 00:05:50.320
the problem is typical faculty member writes a little bit of code is a Grad

101
00:05:50.321 --> 00:05:51.970
student never really gets any instruction.

102
00:05:51.971 --> 00:05:55.150
You throw out some crappy code for your dissertation and then you become a

103
00:05:55.151 --> 00:05:58.310
professor and then you decide coding is what graduate students do.

104
00:05:58.311 --> 00:06:02.810
So you stopped coding and you never write any more code.
And so,
uh,
you know,

105
00:06:02.811 --> 00:06:06.200
the only way to become a great developer and learned design skills today is with

106
00:06:06.201 --> 00:06:10.190
tons of personal experience or trial and error.
Faculty don't have that,

107
00:06:10.430 --> 00:06:12.170
so they can't teach their students.

108
00:06:12.650 --> 00:06:16.400
And so the whole process just continues over and over and over again.

109
00:06:17.330 --> 00:06:21.350
But,
uh,
fortunately I'm not one of those faculty members,

110
00:06:21.351 --> 00:06:23.570
so maybe I have a better chance of doing this.

111
00:06:23.750 --> 00:06:27.380
So personally I love programming and the programming is one of,

112
00:06:27.530 --> 00:06:29.900
it's really one of the top two or three things I live for.
You know,

113
00:06:29.901 --> 00:06:34.590
my family programming really bad golf game because I've fit a few things,

114
00:06:34.600 --> 00:06:36.650
like the things that drive my life.

115
00:06:36.680 --> 00:06:38.900
But if I don't write 5,000 lines of code a year,

116
00:06:38.901 --> 00:06:42.740
at least I feel like it hasn't been a great year for me.
So I had over my career,

117
00:06:42.741 --> 00:06:46.250
I've probably written I think now 250 to 300,000 lines of code.

118
00:06:46.550 --> 00:06:49.910
So I had a chance to observe a lot.
And again,
as I've been doing it,

119
00:06:49.911 --> 00:06:53.090
I've been thinking about design stuff.
So,
so I thought maybe,
you know,

120
00:06:53.091 --> 00:06:57.200
if anybody can do it in academia,
I probably got about as good a shot as anybody.

121
00:06:58.050 --> 00:07:01.160
And then the third question is,
well,
how do you do it?

122
00:07:02.030 --> 00:07:04.790
So I combined all these two threes,
three things together.

123
00:07:04.810 --> 00:07:08.120
I finally decided only one way to find out,
I'm just going to have to try it.

124
00:07:08.150 --> 00:07:10.550
You know,
maybe I'll crash and burn,
but I'll give it a try.

125
00:07:11.450 --> 00:07:15.350
So I created a new course at Stanford [inaudible] software design studio.

126
00:07:16.100 --> 00:07:18.430
It's not taught like a typical production course.

127
00:07:18.431 --> 00:07:23.270
It's taught more like the way you've learned English writing in high school with

128
00:07:23.271 --> 00:07:25.760
an iterative approach.
So you know,
in the way of their writings,

129
00:07:25.761 --> 00:07:28.430
you write something,
your teacher marks it up,
you get it back again,

130
00:07:28.431 --> 00:07:29.900
you rewrite the market up again.

131
00:07:30.140 --> 00:07:32.480
And so on of the whole process iterates several times.

132
00:07:32.690 --> 00:07:35.060
And it's that process of getting criticism,

133
00:07:35.870 --> 00:07:39.500
incorporating the criticism and learning and seeing how that makes things
better.

134
00:07:39.620 --> 00:07:40.850
That's how you become a good writer.

135
00:07:41.600 --> 00:07:44.540
So I thought we'll try the same idea in the class.

136
00:07:45.280 --> 00:07:48.830
And so that's the way it works now.
Only have 10 weeks in a quarter system.

137
00:07:48.831 --> 00:07:51.950
So we could only do three iterations of this cycle.

138
00:07:52.160 --> 00:07:55.280
But the basic way it works is in the first couple of weeks of the course

139
00:07:55.760 --> 00:08:00.260
students in teams of two bill Volare just system they can possibly build in

140
00:08:00.261 --> 00:08:04.400
three weeks.
That's typically about 2000 to 3000 lines of code.

141
00:08:04.401 --> 00:08:06.530
So you know it's still not not a huge system.

142
00:08:07.490 --> 00:08:12.350
Then after week three we go into code review phase that students read each code

143
00:08:12.410 --> 00:08:16.820
and write reviews and read every single line of code written by all of the

144
00:08:16.821 --> 00:08:20.030
students.
This is sort of one of the limitations of the class right now,

145
00:08:20.031 --> 00:08:25.031
so I ended up reading 20 to 30,000 lines of code and that that week and then we

146
00:08:25.101 --> 00:08:28.820
do re code use in class where students will present pieces of their project and

147
00:08:28.821 --> 00:08:32.450
other students will critique it and then I do longer code reviews.

148
00:08:32.540 --> 00:08:33.890
I read everybody's projects.

149
00:08:33.891 --> 00:08:37.430
I typically make 50 to a hundred comments on every team and then I meet with the

150
00:08:37.431 --> 00:08:40.100
teams individually for an hour and go over it with them.

151
00:08:40.700 --> 00:08:43.520
Then the second phase is they revise based on the code reviews.

152
00:08:43.550 --> 00:08:46.050
They actually add a little bit of additional functionality as well.

153
00:08:46.051 --> 00:08:49.730
And the second phase we do another round of code reviews and then the third

154
00:08:49.731 --> 00:08:51.050
phase they get a new project.

155
00:08:51.080 --> 00:08:54.440
They start from scratch again and we defined the do a third round of code.
It is,

156
00:08:55.050 --> 00:08:58.740
and when they do this,
the students get no ideas for me that how do we design,

157
00:08:58.830 --> 00:09:00.480
I just tell him what the system has to do.

158
00:09:00.720 --> 00:09:03.900
They have to start from scratch and figure everything out themselves.

159
00:09:03.901 --> 00:09:06.570
So they make lots of mistakes in the first phase,
but,

160
00:09:06.600 --> 00:09:09.480
but that's part of the learning of the class.
Got another question.

161
00:09:09.810 --> 00:09:10.643
Mike's coming here.

162
00:09:12.010 --> 00:09:12.843
<v 0>Okay.</v>

163
00:09:13.350 --> 00:09:16.650
<v 3>What's your youtube video of the same topic you gave in that one?</v>

164
00:09:17.160 --> 00:09:19.930
Phase three it was past the project took personal,

165
00:09:19.931 --> 00:09:22.950
the left and inherit someone else's code.
Why did you change it?

166
00:09:23.120 --> 00:09:24.800
<v 2>Yeah.
The first two times I taught the class,</v>

167
00:09:24.801 --> 00:09:27.740
I actually scrambled the projects and the third phase and made people add on to

168
00:09:27.741 --> 00:09:31.160
somebody else's project.
That was a good learning experience.

169
00:09:31.161 --> 00:09:35.870
But the problem is people end up spending a lot of time decoding other people's

170
00:09:35.871 --> 00:09:38.660
projects and being frustrated with it that that has some value.

171
00:09:39.050 --> 00:09:41.660
But they didn't spend as much time doing real design stuff.

172
00:09:41.990 --> 00:09:45.110
And so I finally decided if what I really want us to teach people design,

173
00:09:45.111 --> 00:09:48.770
I think they'll learn more if they get to start from scratch and do a new design

174
00:09:48.771 --> 00:09:51.020
project.
So I change it.

175
00:09:51.021 --> 00:09:55.970
Then I made a change back and I'll try this for a while and see what works.
Okay,

176
00:09:55.971 --> 00:10:00.350
so that's the basic idea of the course.
Now you may be wondering,

177
00:10:00.351 --> 00:10:03.470
but so one of the magic secrets has,

178
00:10:03.471 --> 00:10:06.590
how do you do software design and,
and by the way,

179
00:10:06.591 --> 00:10:10.550
what makes me think I know what the secrets are.
So first of all,

180
00:10:10.820 --> 00:10:12.290
I don't claim to know all the answers.

181
00:10:12.291 --> 00:10:17.240
I have some ideas that have kind of coalesced in my mind over the years,

182
00:10:17.570 --> 00:10:20.060
which I'm using in the course.
And the book,
I don't claim those are the end.

183
00:10:20.061 --> 00:10:20.331
Actually.

184
00:10:20.331 --> 00:10:24.230
I'm hoping more to use those to start a discussion and evolve them over time.

185
00:10:25.010 --> 00:10:29.150
But in the class there's about 10 high level ideas.

186
00:10:29.360 --> 00:10:32.450
They're very abstract,
almost philosophical.
Uh,

187
00:10:32.451 --> 00:10:34.630
I can't give you a recipe,
you know,

188
00:10:34.640 --> 00:10:37.160
follow these 10 steps and you will produce a great design.

189
00:10:37.190 --> 00:10:38.720
I'm not sure that there is such a recipe.

190
00:10:39.260 --> 00:10:43.580
So instead of these vague ideas that I talk about a while,

191
00:10:43.581 --> 00:10:46.070
students are doing their first round of design,

192
00:10:46.910 --> 00:10:50.060
I'm not sure they sink in very well because they're so abstract.

193
00:10:50.061 --> 00:10:53.840
It's sort of probably hard to figure out how to apply them the way they work

194
00:10:53.841 --> 00:10:55.550
best.
So that was one way to do the code reviews.

195
00:10:55.580 --> 00:11:00.580
Then I can show the students how they violated some of these principles and what

196
00:11:00.741 --> 00:11:03.500
the consequence was in their code and how they should change it.

197
00:11:03.620 --> 00:11:08.090
And then you can go back and apply the principles as they revise and then then I

198
00:11:08.091 --> 00:11:11.590
think the ideas start sinking in.
So it's,

199
00:11:11.591 --> 00:11:13.610
it's sort of a question in backyard.

200
00:11:19.570 --> 00:11:22.320
<v 3>Yeah.
I,
I'm curious what you think about,
uh,</v>

201
00:11:22.390 --> 00:11:24.850
how does the sort of end to end principle and um,

202
00:11:25.260 --> 00:11:28.660
in sort of a sophomore design factor into this in terms of trying to push all

203
00:11:28.661 --> 00:11:31.210
the complexity to the edges of the system?

204
00:11:33.290 --> 00:11:36.670
Like the typical example of TCP,
the check sum is at the,
you know,

205
00:11:36.671 --> 00:11:40.540
is done end to end.
It's not in the intermediate Roger stages.
Um,

206
00:11:40.600 --> 00:11:43.000
and that was a design principle that they had.
Uh Huh.

207
00:11:43.150 --> 00:11:43.931
<v 2>I think about that.</v>

208
00:11:43.931 --> 00:11:46.250
I'm not sure that relates in a direct way to these principles,

209
00:11:46.270 --> 00:11:50.440
but I'll have to think about that so that these vague principles.

210
00:11:50.710 --> 00:11:53.080
Then the other thing I try and do is talk about red.

211
00:11:53.500 --> 00:11:57.670
So red flags are very specific things that if you see this sort of behavior or

212
00:11:57.720 --> 00:12:00.010
or pattern,
you're probably in trouble.

213
00:12:00.340 --> 00:12:02.080
And actually I think for beginners in particular,

214
00:12:02.081 --> 00:12:06.160
red flags are really useful to people because even if you don't know how to

215
00:12:06.161 --> 00:12:08.500
design the right system,
if you can see you're going wrong,

216
00:12:08.710 --> 00:12:12.730
then just try something else until eventually the red flags go away and you'll

217
00:12:12.731 --> 00:12:16.000
probably end up in a pretty decent place.
So,
so red flags are really,

218
00:12:16.120 --> 00:12:17.230
really more a very useful.

219
00:12:18.400 --> 00:12:22.120
So what I'd like to do is I'm going to talk about the four things that are in

220
00:12:22.121 --> 00:12:24.010
red,
just to give you a sense of some of the ideas.

221
00:12:24.310 --> 00:12:25.960
Two of them are designed principles.

222
00:12:25.990 --> 00:12:29.530
Classes should be deep to find errors out of existence and two of them are more

223
00:12:29.531 --> 00:12:31.150
about mindset.
I'll talk about those.

224
00:12:33.970 --> 00:12:34.540
<v 4>Okay.</v>

225
00:12:34.540 --> 00:12:38.110
<v 2>So the first one is this notion that classes should be deep.</v>

226
00:12:38.920 --> 00:12:42.760
This is really just another way of thinking about this idea that David,

227
00:12:42.761 --> 00:12:46.420
partly I of information hiding the David Parnas first put out in a paper and

228
00:12:46.421 --> 00:12:48.550
early 1970s.
Uh,
by the way,

229
00:12:48.970 --> 00:12:52.520
to me this paper is one of the two most important classic papers and all the

230
00:12:52.521 --> 00:12:56.110
software design and engineering it.
Has Anybody here read this paper and classes?

231
00:12:56.830 --> 00:13:01.210
Great.
It's still topical and relevant today.
The last third,
maybe not so much so,

232
00:13:01.211 --> 00:13:04.360
but the,
the first part still in,
we've got a great example and easy to read.

233
00:13:05.440 --> 00:13:06.820
So the way I think about it,

234
00:13:07.020 --> 00:13:12.020
think about a class as a rectangle and the area of the rectangle is the

235
00:13:12.431 --> 00:13:14.140
functionality of that class provides.

236
00:13:14.170 --> 00:13:18.280
So you can think of that's the benefit that the class provides to the rest of

237
00:13:18.281 --> 00:13:19.114
the system.

238
00:13:19.900 --> 00:13:24.400
Then think about the top edge as that's the interface to the class.

239
00:13:24.401 --> 00:13:25.340
And by interface I,

240
00:13:25.341 --> 00:13:30.341
I mean everything someone has to have in their mind in order to use that class.

241
00:13:30.640 --> 00:13:33.130
It's not just the signatures for the functions,

242
00:13:33.131 --> 00:13:36.070
but things like side effects and dependencies and things like that.

243
00:13:37.540 --> 00:13:39.100
That's really the cost you think of.

244
00:13:39.101 --> 00:13:44.101
That's the complexity cost that this class imposes on the rest of the system.

245
00:13:45.250 --> 00:13:46.900
So we'd like that to be as small as possible.

246
00:13:47.830 --> 00:13:51.900
So ideally what you'd like is the greatest cost,
sorry,
greatest benefit,

247
00:13:51.920 --> 00:13:56.650
least cost.
She was like the smallest interface and then the largest area.

248
00:13:56.980 --> 00:13:59.290
So the opposite of that,
I call a shallow class.

249
00:14:00.100 --> 00:14:03.520
So that's something that has either not a whole lot of functionality or really,

250
00:14:03.521 --> 00:14:06.880
really complicated interface or both those classes,

251
00:14:06.881 --> 00:14:10.000
they just don't give us much leverage against complexity.
In fact,

252
00:14:10.001 --> 00:14:12.100
in the worst case and the worst case,

253
00:14:12.250 --> 00:14:16.960
the additional overhead of the interface adds more complexity than what you've

254
00:14:16.961 --> 00:14:21.370
hidden underneath the interface.
Instead,
it's a net negative.
Well,

255
00:14:21.371 --> 00:14:23.740
we'd like to have,
of course,
the other side is a deep class,

256
00:14:24.340 --> 00:14:29.020
very simple interface with a very large amount of functionality underneath it.

257
00:14:29.590 --> 00:14:31.690
I mean,
that's another way of thinking about abstraction,
right?

258
00:14:31.691 --> 00:14:35.710
The idea of abstraction is we're trying to provide a simple way of thinking

259
00:14:35.711 --> 00:14:38.500
about something that's actually quite complicated underneath.

260
00:14:38.680 --> 00:14:42.730
So deep classes are good abstractions and this notion you can apply it to

261
00:14:42.731 --> 00:14:45.100
classes,
you can apply it to methods within classes.

262
00:14:45.250 --> 00:14:48.130
You can apply it to interfaces in general or modules and the systems or

263
00:14:48.131 --> 00:14:51.860
subsystems.
Anything like that that has an interface or implementation.

264
00:14:54.020 --> 00:14:58.540
<v 4>Yeah.
Question,
because</v>

265
00:15:02.060 --> 00:15:06.230
<v 2>it seems important to give at least a few hints.
The beginning,</v>

266
00:15:06.500 --> 00:15:08.180
this is what I give them before,
well,

267
00:15:08.270 --> 00:15:10.340
as concurrent while they're doing the first project,

268
00:15:10.341 --> 00:15:13.040
we don't have enough time for me to go through all the ideas before they start

269
00:15:13.041 --> 00:15:15.800
designing.
So while they're designing,
we're talking about this stuff in class.

270
00:15:18.310 --> 00:15:18.830
<v 4>Okay.</v>

271
00:15:18.830 --> 00:15:21.560
<v 2>Here's a classical example of a shallow method,</v>

272
00:15:21.561 --> 00:15:26.561
which I have to say I see distressingly often various essentially no information

273
00:15:27.561 --> 00:15:30.170
hiding and this method,
in order to use it,

274
00:15:30.171 --> 00:15:33.410
you pretty much need to understand the complete implementation.
And by the way,

275
00:15:33.411 --> 00:15:35.510
there's almost no implementation there.
In fact,

276
00:15:35.540 --> 00:15:40.540
this is so bad that it takes more keystrokes to invoke the method then if you

277
00:15:42.020 --> 00:15:44.360
just did the body of the function yourself.

278
00:15:44.990 --> 00:15:47.540
So it's basically a complete loss.

279
00:15:47.930 --> 00:15:50.060
Just adding complexity and getting nothing back for it.

280
00:15:51.290 --> 00:15:51.530
<v 4>Yeah.</v>

281
00:15:51.530 --> 00:15:54.500
<v 2>Another example of a,
actually have a relatively shallow class.</v>

282
00:15:54.501 --> 00:15:57.770
I see all the time as a class for list manipulation.
This is very shallow.

283
00:15:57.771 --> 00:16:00.170
I mean lists are really easy to manipulate.
It's two pointers.
We didn't know.

284
00:16:00.171 --> 00:16:02.780
We know the pointers are hiding underneath there someplace anyhow,

285
00:16:03.560 --> 00:16:05.450
and so that's a,
that's a very shallow class.

286
00:16:06.200 --> 00:16:08.870
Now you can't always eliminate shallow classes.
You know,

287
00:16:08.871 --> 00:16:11.750
sometimes you end up with the best you can do is a shadow class.

288
00:16:11.770 --> 00:16:14.540
So I wouldn't say you should never ever have them,

289
00:16:15.230 --> 00:16:18.490
but a shallow class doesn't buy you much.
From a design standpoint.

290
00:16:18.500 --> 00:16:20.750
It doesn't help you in the fight against complexity.

291
00:16:25.740 --> 00:16:26.573
<v 4>Okay.</v>

292
00:16:29.400 --> 00:16:30.233
<v 1>See,</v>

293
00:16:30.260 --> 00:16:34.910
I think one thing that is perhaps a bit subtle is that the size of the class is

294
00:16:34.911 --> 00:16:37.370
not the amount of code that is in it right now.

295
00:16:37.371 --> 00:16:41.240
It might be the amount of code that he eventually have to add or if you have to

296
00:16:41.241 --> 00:16:43.580
have multiple implementations of it.
Right.

297
00:16:43.700 --> 00:16:46.430
So maybe this doesn't make sense in isolation,

298
00:16:46.730 --> 00:16:50.420
but perhaps there is something else which is there another implementation if it

299
00:16:50.421 --> 00:16:52.460
is maybe right now or in the future,

300
00:16:52.461 --> 00:16:55.670
which is going in storing stuff in a database or something like that.

301
00:16:56.630 --> 00:17:01.630
And so I kind of wonder if you disagree with that characterization that you need

302
00:17:02.631 --> 00:17:07.190
to keep track of the evolution of the class in mind when deciding on its depth.

303
00:17:07.650 --> 00:17:08.730
<v 2>Well,
I agree with that.
In fact,</v>

304
00:17:08.731 --> 00:17:11.730
the whole idea behind the software design is we're doing things for the future.

305
00:17:12.140 --> 00:17:15.780
It's,
we're doing things today to make it easier for us to develop in the future.

306
00:17:15.781 --> 00:17:18.320
And so you have to think a little bit ahead.
Although question under,

307
00:17:18.340 --> 00:17:21.750
the classic problem with software is we can't visualize the future very well.

308
00:17:21.751 --> 00:17:23.550
So it's a dangerous to try and think too far ahead.

309
00:17:23.610 --> 00:17:27.000
But I agree with your concept in general.
In this particular case though,

310
00:17:27.120 --> 00:17:32.120
the problem is that the interface was already so specialized that there's just

311
00:17:32.941 --> 00:17:36.090
probably not a lot of room for wiggle reminder that there are almost certainly

312
00:17:36.091 --> 00:17:39.240
anything you've changed or the implementation is probably also going to change

313
00:17:39.241 --> 00:17:43.380
the interface.
And so again it,
it,
it's probably not going to help you,

314
00:17:43.530 --> 00:17:46.030
but you know,
if you have reason to believe that we'll know.

315
00:17:46.500 --> 00:17:47.500
<v 4>Yep,
Yep.
Sure.</v>

316
00:17:50.100 --> 00:17:52.050
<v 2>So the problem that leases,
and by the way,</v>

317
00:17:52.051 --> 00:17:55.230
I think this was one of the biggest mistakes people make too many,

318
00:17:55.440 --> 00:17:57.510
too small to shower classes.

319
00:17:58.410 --> 00:18:03.300
And the reason people do that is because they've been taught classes and methods

320
00:18:03.301 --> 00:18:04.021
should be small.

321
00:18:04.021 --> 00:18:06.810
How many of you at some time in some courts were taught your methods should be

322
00:18:06.811 --> 00:18:09.630
small?
And how many of you have been given a number,

323
00:18:09.990 --> 00:18:14.220
like any method larger than an lines you should chop it up.

324
00:18:14.250 --> 00:18:17.000
How many of you have heard something like that said,
okay,
what's,

325
00:18:17.640 --> 00:18:20.960
tell me a small value of n you've heard 20

326
00:18:22.590 --> 00:18:27.510
does anybody heard 10
I heard.
I've heard 10 sometimes.

327
00:18:28.350 --> 00:18:30.960
So if you take this to the extreme,

328
00:18:31.140 --> 00:18:34.830
this results in what I call class situs class.

329
00:18:34.831 --> 00:18:39.831
Situs is when somebody says classes are good and somebody else thought what they

330
00:18:39.841 --> 00:18:42.240
heard was more classes are better

331
00:18:44.700 --> 00:18:49.620
and so in underclass hide is your goal is to have as many small classes as

332
00:18:49.621 --> 00:18:54.621
possible where each class adds the tiniest possible amount of new functionality

333
00:18:54.900 --> 00:18:55.980
to the previous classes.

334
00:18:56.160 --> 00:18:58.560
If you want more functionality and that make another class for it.

335
00:18:59.920 --> 00:19:03.420
That's probably the best example of this and the world today is the Java Class

336
00:19:03.420 --> 00:19:07.170
Library.
There's nothing in the Java language that requires this,

337
00:19:07.171 --> 00:19:10.800
but somehow this has just become the culture in the job of world.

338
00:19:10.801 --> 00:19:15.180
These tons of little tiny shallow interfaces like for example,

339
00:19:15.210 --> 00:19:17.200
I think that just bugged me about Java when I started partying.

340
00:19:17.400 --> 00:19:20.370
If I want to open a file and read serialized objects from it,

341
00:19:20.780 --> 00:19:25.620
I have to create three objects for that.
First I have to create this file stream,

342
00:19:25.621 --> 00:19:29.010
but for some reason I don't get buffering.
I'm going to fast.
I want buffering.

343
00:19:29.780 --> 00:19:33.750
It's like,
do you want to eat today?
If I'm buffering,

344
00:19:33.751 --> 00:19:34.860
you have to create another object.

345
00:19:35.010 --> 00:19:36.840
And then if I want to see read serialize objects,

346
00:19:36.841 --> 00:19:38.300
you had another object on top of that.

347
00:19:38.350 --> 00:19:40.790
Each of these could throw exceptions that I have to catch it and they can,

348
00:19:40.800 --> 00:19:44.610
exceptions can come halfway through and have to clean up enormous amount of

349
00:19:44.611 --> 00:19:47.010
complexity for something that's really,
really simple.

350
00:19:47.490 --> 00:19:50.910
So I think they lost sight of the idea that first of all,
in managing complexity,

351
00:19:50.911 --> 00:19:54.540
the common case matters a lot.
You want to make the common case really,

352
00:19:54.541 --> 00:19:58.050
really simple.
I shouldn't have to do all of this,
you know?
Okay,

353
00:19:58.051 --> 00:20:01.470
maybe I want to be able to not have buffering,
but that should be an option that,

354
00:20:01.560 --> 00:20:02.850
you know,
if I don't want buffering,

355
00:20:02.851 --> 00:20:06.390
that should be worth things get more complicated.
Not,
I have to remember to ask,

356
00:20:06.391 --> 00:20:10.020
especially for Bufferin.
So to me it's not about length.

357
00:20:10.080 --> 00:20:12.000
Length is really not the fundamental issues.

358
00:20:12.030 --> 00:20:14.520
I don't have problems with methods that are hundreds of lines long,

359
00:20:14.850 --> 00:20:16.620
if they're relatively clean and if they have a,

360
00:20:16.621 --> 00:20:19.410
if they have a deep interface to them,
it's abstraction.

361
00:20:19.440 --> 00:20:22.980
That's the most important thing.
So rather than striving for length,

362
00:20:22.981 --> 00:20:25.320
you should first try and get these deep abstractions.

363
00:20:25.770 --> 00:20:28.380
And then if you end up with something that's really big and long and then see if

364
00:20:28.381 --> 00:20:31.230
you can chop it up.
But depth is more important.

365
00:20:32.850 --> 00:20:36.930
So what's an example of a deep interface?
My favorite in the world,

366
00:20:36.990 --> 00:20:40.890
probably one of the most beautiful interface ever invented is the unix file io

367
00:20:40.891 --> 00:20:41.724
interface.

368
00:20:42.030 --> 00:20:46.200
Five functions falling over easy interfaces to every function.

369
00:20:46.201 --> 00:20:47.270
The only complexity is the,

370
00:20:47.360 --> 00:20:50.830
the flags and the permissions for opener a little bit funky,

371
00:20:50.831 --> 00:20:53.020
but everything else is very,
very simple.

372
00:20:53.860 --> 00:20:57.250
And then think about what's hidden behind the simple interface.

373
00:20:57.430 --> 00:21:01.210
There's typically a hundreds of thousands of lines of code behind that that do

374
00:21:01.211 --> 00:21:05.310
everything from managing disk space to file caching to,
you know,

375
00:21:05.380 --> 00:21:09.310
device drivers that enormous amounts of code and of course many other lower

376
00:21:09.311 --> 00:21:11.140
level interfaces behind this.

377
00:21:11.410 --> 00:21:15.520
But just this amazingly beautiful five functions.

378
00:21:16.120 --> 00:21:18.610
Now today,
people look at this and they go,
well,
Duh.

379
00:21:18.610 --> 00:21:20.110
Of course that's the way you design things,

380
00:21:20.590 --> 00:21:25.290
but it was not like this is anybody in this room actually programmed at the

381
00:21:25.291 --> 00:21:29.800
round the time Unix came out,
only a few of us are old enough to have done that.

382
00:21:31.450 --> 00:21:33.640
Things were pretty horrible before that.

383
00:21:33.760 --> 00:21:35.680
Like for example have been pre unix file systems.

384
00:21:35.681 --> 00:21:38.830
There'll be a totally different set of kernel calls if you wanted to open a file

385
00:21:38.831 --> 00:21:42.300
for random access versus sequential access to different sets of critical

386
00:21:42.310 --> 00:21:43.600
different kinds of files,

387
00:21:43.870 --> 00:21:48.100
you have to declare your file random access or sequential when your units just

388
00:21:48.101 --> 00:21:51.040
had this amazingly simple interface.

389
00:21:52.050 --> 00:21:55.420
It's only a beautiful example.
Okay,

390
00:21:55.421 --> 00:21:59.110
let me go to my second design principle,

391
00:21:59.111 --> 00:22:01.360
which is define errors out of existence.

392
00:22:02.950 --> 00:22:07.950
So we all know that exceptions are huge source of complexity in systems.

393
00:22:09.101 --> 00:22:11.470
For example,
in the ramp cloud storage system,

394
00:22:11.471 --> 00:22:14.530
we thought we were building a low latency storage system figured out we need to

395
00:22:14.531 --> 00:22:17.080
be spending all of our time making things really fast and low latency.

396
00:22:17.260 --> 00:22:21.840
But in fact 90% of our time went into doing crash recovery.
So they're,

397
00:22:21.900 --> 00:22:25.600
they're a huge source of complexity.
And the,
again,

398
00:22:25.601 --> 00:22:28.000
the common wisdom kind of leads people astray.

399
00:22:28.030 --> 00:22:32.860
You're taught to program defensively just good.
But people then think,

400
00:22:33.150 --> 00:22:36.580
I should be throwing lots of exceptions.
The more exceptions I'm throwing,

401
00:22:36.581 --> 00:22:38.140
the better defense I'm doing.

402
00:22:38.590 --> 00:22:41.710
And as long as I building my module,

403
00:22:41.711 --> 00:22:44.560
catch all the errors and heave them up in the air is exceptions.

404
00:22:44.590 --> 00:22:48.100
I don't have to worry about where they land or who's going to deal with them.

405
00:22:48.280 --> 00:22:51.310
I've done my job effect the more than my throw the better program where I am.

406
00:22:51.730 --> 00:22:55.090
But then that just results in this explosion of exceptions that have to be

407
00:22:55.091 --> 00:22:56.560
caught and handled.

408
00:22:56.740 --> 00:22:59.650
And then the exceptions themselves create more bugs in a secondary exceptions

409
00:22:59.651 --> 00:23:00.484
and so on.

410
00:23:01.300 --> 00:23:06.300
So I would argue in general overall we should try to minimize the number of

411
00:23:06.551 --> 00:23:09.790
places where you have to handle exceptions.
You can't completely eliminate it,

412
00:23:09.791 --> 00:23:13.690
but try to minimize that.
And the best case of all,

413
00:23:14.290 --> 00:23:19.210
which I found you can do surprisingly often,
is simply to redefine the semantics.

414
00:23:19.390 --> 00:23:22.450
So if there is no error is no exception at all,
that's the best.

415
00:23:22.630 --> 00:23:23.770
It's just gone completely.

416
00:23:24.640 --> 00:23:27.760
So let me give you three examples of that first one.

417
00:23:27.800 --> 00:23:30.840
When I was designing the tickle scripting language,
many years ago,

418
00:23:31.060 --> 00:23:34.810
I introduced an unset command,
which deletes one or more variables.

419
00:23:35.710 --> 00:23:40.270
When I was doing this,
I thought that by the way,
this classic mistake people,

420
00:23:40.271 --> 00:23:41.104
I thought,

421
00:23:41.530 --> 00:23:44.890
why in their right mind would anybody ever deleted variable that doesn't exist?

422
00:23:45.050 --> 00:23:49.610
That makes no sense.
So I'm going to throw an exception for that.
Well,

423
00:23:49.611 --> 00:23:53.210
it turns out people do that all the time.
Uh,
for example,

424
00:23:53.211 --> 00:23:55.790
you're halfway through a computation and you decide you just want to bail.

425
00:23:55.940 --> 00:23:57.650
So you want to clean up all the mess you might've made.

426
00:23:57.650 --> 00:24:00.350
So you go through and delete every variable that you might have created,

427
00:24:00.500 --> 00:24:03.080
but you don't know which ones you actually got around to creating yet.

428
00:24:03.440 --> 00:24:06.350
And so some of them don't exist.
So in practice,

429
00:24:06.500 --> 00:24:10.370
people complain about this all the time.
And in fact,
if you look at tickle code,

430
00:24:10.730 --> 00:24:15.200
I bet virtually every invocation of the unset command is wrapped in a catch

431
00:24:15.201 --> 00:24:18.590
command that will catch the exception and throw it away when it happens.

432
00:24:19.700 --> 00:24:24.290
So what I should have done,
in fact,
I,
I don't know why I didn't fix it,

433
00:24:24.291 --> 00:24:26.060
once I found the problem,
that was my second mistake.

434
00:24:27.110 --> 00:24:31.700
What I should've done was redefined the semantics so that unset makes a variable

435
00:24:31.701 --> 00:24:34.430
not exist.
And if you think of it that way,

436
00:24:34.850 --> 00:24:39.510
oh well if the variable doesn't exist already,
we're done clean,
no harm,
no foul.

437
00:24:40.400 --> 00:24:43.460
And so that's what I should have done,
should not have thrown that exception.

438
00:24:44.870 --> 00:24:47.030
Another example is file deletion

439
00:24:50.150 --> 00:24:51.830
in windows,
at least in the early days,

440
00:24:53.310 --> 00:24:56.690
if you tried to delete a file when some process had the file open,

441
00:24:56.990 --> 00:24:57.860
that was not allowed.

442
00:24:58.640 --> 00:25:00.910
Anybody experienced this and the bidding used windows experiences.

443
00:25:01.470 --> 00:25:04.390
It's this horrible thing and then now you forgot,
okay,
who's got it open?

444
00:25:04.391 --> 00:25:06.870
And you start going around and killing programs to try and make it good,

445
00:25:06.890 --> 00:25:10.340
delete the file and you can't find which program has it open so fine.

446
00:25:10.341 --> 00:25:15.341
You just give it and you reboot and then it turns out and then it turns out that

447
00:25:15.381 --> 00:25:19.190
it's a system demon that has the file open.
So when you reboot,
it's still in use.

448
00:25:19.191 --> 00:25:22.910
You can't delete.
So eunuchs had as a beautiful,

449
00:25:23.030 --> 00:25:26.780
really lovely solution that makes this error go away.

450
00:25:27.560 --> 00:25:29.660
In unix,
if you delete a file while it's open,

451
00:25:29.810 --> 00:25:33.530
what happens is it deletes the file from the directory from the namespace.

452
00:25:33.530 --> 00:25:35.630
It no longer appears anywhere in the file system,

453
00:25:35.900 --> 00:25:40.400
but the actual contents of the file still hanging around so that any process

454
00:25:40.401 --> 00:25:43.220
that's using the file can continue to access the file.

455
00:25:43.610 --> 00:25:48.320
And then when the last open instance of the file is closed,

456
00:25:48.470 --> 00:25:50.930
then find that cleans up and throws away everything else.

457
00:25:51.200 --> 00:25:53.690
It's a lovely solution because you could have made the other mistake,

458
00:25:53.691 --> 00:25:56.510
which is that I'm going to delete the file and now anybody doing Ohio on the

459
00:25:56.511 --> 00:25:57.380
file gets an error.

460
00:25:57.890 --> 00:26:00.530
That would probably be even worse because now every program would have to be

461
00:26:00.531 --> 00:26:03.050
written to handle the case where the file goes away in the middle of you're

462
00:26:03.051 --> 00:26:03.884
accessing it.

463
00:26:04.070 --> 00:26:07.340
So you're just had this beautiful solution where there's no errors on either

464
00:26:07.341 --> 00:26:09.560
side.
It's just it just does the right thing.

465
00:26:10.850 --> 00:26:14.510
So when does the eventually realize this was a problem and I don't know where

466
00:26:14.511 --> 00:26:15.860
they are in the evolution of fixing it,

467
00:26:15.861 --> 00:26:20.000
but I know that the first stage they did is they had some special flag you could

468
00:26:20.001 --> 00:26:22.970
set,
let's say delete the file,
even if it's open or you could,

469
00:26:22.971 --> 00:26:25.820
maybe we open the file,
then you can allow it to be deleted while it's open.

470
00:26:26.960 --> 00:26:28.730
But they didn't get rid of the directory entry.

471
00:26:29.300 --> 00:26:34.300
They kept the directory entry around and so you couldn't recreate the file while

472
00:26:34.521 --> 00:26:37.250
it was open.
So if you were,
for example,
trying to rebuild and the,
you know,

473
00:26:37.251 --> 00:26:39.440
the binary was unused,
she couldn't,
you couldn't modify the,

474
00:26:39.650 --> 00:26:42.470
couldn't create a new version of the binary file because that directory entry

475
00:26:42.471 --> 00:26:46.170
was locked down,
they still didn't get it right.
So again,

476
00:26:46.171 --> 00:26:50.340
examples of why you just want to make these arrows go away.
A third example,

477
00:26:51.030 --> 00:26:54.900
which is people often considered more controversial when I say this one is

478
00:26:54.990 --> 00:26:56.760
substrings.
That's when Java,

479
00:26:56.761 --> 00:26:59.640
there's various methods and we'll extract a sub string out of a string.

480
00:27:00.240 --> 00:27:04.560
And these methods are very exception happy if either the indices is outside the

481
00:27:04.561 --> 00:27:06.210
range of the sub string and throws an exception.

482
00:27:06.211 --> 00:27:08.880
And I believe if they were kind of out of order,
throws an exception,

483
00:27:09.900 --> 00:27:11.550
I find this huge pain.

484
00:27:11.580 --> 00:27:16.580
I ended up typically having to write my own code to effectively clip my indices

485
00:27:17.341 --> 00:27:20.630
to the range of the string before I invoke the Java substring command.

486
00:27:20.690 --> 00:27:25.470
So I won't get these exceptions.
Yeah,
I consider this just a bad idea.
Instead,

487
00:27:25.720 --> 00:27:30.720
it was so much simpler just to find some string so that it returns the overlap

488
00:27:31.320 --> 00:27:35.520
between the indices you've specified.
And the available contents of the string.

489
00:27:36.420 --> 00:27:39.640
So if both of the indices are outside the range of the string and returns the

490
00:27:39.641 --> 00:27:41.670
empty string,
you know,
if they're in reverse order,

491
00:27:41.671 --> 00:27:43.560
clearly there can't be anything in the right order,

492
00:27:43.561 --> 00:27:45.750
it doesn't return and just does the clipping automatically.

493
00:27:46.380 --> 00:27:49.140
This would eliminate so much extra code people have to write.

494
00:27:49.141 --> 00:27:53.010
And also I suspect a lot of runtime exceptions that occur because people forgot

495
00:27:53.011 --> 00:27:56.730
to clip their indices to the range of the string before they invoke the command.

496
00:27:58.150 --> 00:27:58.501
So again,

497
00:27:58.501 --> 00:28:02.490
the overall idea here is to try and reduce the number of places where people

498
00:28:02.491 --> 00:28:04.370
have to deal with exceptions.
The,

499
00:28:04.510 --> 00:28:06.480
the book talks about a few other ways of doing this,

500
00:28:06.630 --> 00:28:10.340
but the best case of all is just to define the exceptions away.

501
00:28:10.530 --> 00:28:13.320
Just make the normal behavior always do the right thing.

502
00:28:14.980 --> 00:28:16.610
And nobody's objecting on the Java subject.

503
00:28:16.620 --> 00:28:18.600
Usually somebody raises their hand and objects to that.

504
00:28:20.050 --> 00:28:20.883
<v 0>Yeah,</v>

505
00:28:23.490 --> 00:28:24.650
<v 5>yeah.
So not an objection,</v>

506
00:28:24.710 --> 00:28:28.350
but a defining to the semantics perhaps is a more complete definition.

507
00:28:28.351 --> 00:28:31.020
I mean you,
you could simply say,
okay,
whatever,

508
00:28:31.021 --> 00:28:33.010
whatever set of parameters you pass.
A,

509
00:28:33.330 --> 00:28:36.630
you have a random behavior that are difficult to explain.

510
00:28:36.631 --> 00:28:39.180
But the examples you gave were very,
very intuitive.

511
00:28:39.240 --> 00:28:44.240
Like when you define the overlap between the indexes and the available space or

512
00:28:44.650 --> 00:28:46.450
a,
the tcl,
et Cetera,

513
00:28:47.080 --> 00:28:50.340
<v 2>somebody want to argue that the Java sub string shed thrash options.</v>

514
00:28:51.990 --> 00:28:52.960
<v 0>Microphone on here.</v>

515
00:28:55.340 --> 00:28:56.750
<v 2>I know some of your thinking it.
Sorry.</v>

516
00:28:57.240 --> 00:28:58.073
<v 0>Okay.</v>

517
00:28:59.660 --> 00:29:00.980
<v 5>Uh,
it should,
it should.</v>

518
00:29:01.450 --> 00:29:06.300
I think it should throw runtime exception because like you can't,
uh,
it,
uh,

519
00:29:06.490 --> 00:29:09.940
sometimes it could be just the wrong assumptions on client's side.

520
00:29:10.480 --> 00:29:12.670
Like they just done something wrong and they're,

521
00:29:12.700 --> 00:29:15.700
they're assuming that's correct range,
but it's not,

522
00:29:16.000 --> 00:29:17.620
I think it should be run time exception.

523
00:29:18.340 --> 00:29:20.740
<v 2>This is part of the philosophy about we're going to try and keep you from making</v>

524
00:29:20.741 --> 00:29:25.680
mistakes.
Sorry,
which it's a kind of a noble father.

525
00:29:25.960 --> 00:29:29.950
But the problem is that it's really hard to keep people from making mistakes.

526
00:29:30.490 --> 00:29:34.210
And so typically what happens when we try and do this as we introduced lots of

527
00:29:34.211 --> 00:29:36.610
complexity,
which makes it hard to even do the right thing.

528
00:29:37.110 --> 00:29:39.280
And so I had in general,
we want to make it really,

529
00:29:39.281 --> 00:29:43.200
really easy to do the common case,
the right thing.
Uh,
we should have,
yeah.

530
00:29:43.260 --> 00:29:45.550
Did you still have to do testing to catch mistakes?

531
00:29:45.870 --> 00:29:49.030
And so this isn't going to replace the need for unit tests,
but in general,

532
00:29:49.031 --> 00:29:52.150
I think when you try and build systems that can keep people from making
mistakes,

533
00:29:52.151 --> 00:29:54.640
you're usually create a whole lot of complexity for everybody.

534
00:29:55.070 --> 00:29:59.390
<v 6>So how do you distinguish between Java substring versus Java Dot.</v>

535
00:29:59.700 --> 00:30:03.890
A string dot character at index?
Should that one exception?

536
00:30:04.450 --> 00:30:04.640
<v 4>Yeah,</v>

537
00:30:04.640 --> 00:30:05.870
<v 6>if the next is out of range,</v>

538
00:30:07.470 --> 00:30:08.310
<v 2>good question.</v>

539
00:30:08.670 --> 00:30:11.910
That one probably should because you can't really return a character,
you know,

540
00:30:11.911 --> 00:30:16.260
what do you,
uh,
if you know,
you could redefine a kind of,

541
00:30:16.261 --> 00:30:17.640
like I triple e 14 point did,

542
00:30:17.641 --> 00:30:20.340
where there were special values that represented the arithmetic errors and

543
00:30:20.341 --> 00:30:21.060
things like that.

544
00:30:21.060 --> 00:30:23.700
So if you have some sort of a no character that you couldn't return,

545
00:30:23.910 --> 00:30:26.940
that might make sense.
But we don't really have that in our character sets.
So,

546
00:30:27.050 --> 00:30:28.920
so in that case you really can't,

547
00:30:29.430 --> 00:30:32.400
I'm not sure what you would return if you're going to return something.

548
00:30:34.540 --> 00:30:37.750
So in that case you probably do have to throw an exception.

549
00:30:38.670 --> 00:30:39.503
<v 4>Awesome.</v>

550
00:30:40.700 --> 00:30:44.130
<v 6>So one question.
So when is it a good idea to actually throw exception?</v>

551
00:30:44.131 --> 00:30:47.990
So they're intuitive cases.
You want to eliminate exceptions as much as possible.

552
00:30:48.260 --> 00:30:50.810
Then how do you decide?
No,
I,
there's nothing that I can do.

553
00:30:50.811 --> 00:30:54.410
My changing semantics doesn't work and I really have to throw an exception

554
00:30:54.411 --> 00:30:54.660
though.

555
00:30:54.660 --> 00:30:57.570
<v 2>Well,
if you fundamentally can't carry out your contract with your color,</v>

556
00:30:57.630 --> 00:30:58.890
if you can't implement your interface,

557
00:30:58.891 --> 00:31:00.600
then you sort of have to throw an exception.
You know,

558
00:31:00.601 --> 00:31:04.350
like if you're reading frank doing a read operation and the re can't succeed

559
00:31:04.351 --> 00:31:07.290
because you've got an io error,
you have to,
that's information that you,

560
00:31:07.300 --> 00:31:09.210
you do have to reflect that back to the color.

561
00:31:10.250 --> 00:31:11.700
So you can't eliminate all except you know,

562
00:31:11.701 --> 00:31:14.880
some of the students in the class thought this was really a great idea and

563
00:31:14.910 --> 00:31:16.960
something basically you wrote no exception handlers when they were calling,

564
00:31:17.590 --> 00:31:21.150
cause I'm just defining them out of existence.
I said,
no,
no.

565
00:31:21.151 --> 00:31:22.710
Some of them actually matter.
You have to.

566
00:31:23.270 --> 00:31:26.400
And then a lot of software design I think is what matters and what doesn't

567
00:31:26.401 --> 00:31:30.630
matter.
And ideally you'd like to make as little matter as possible.

568
00:31:30.760 --> 00:31:33.690
You'd like to be as to not depend on very many things,

569
00:31:33.720 --> 00:31:36.840
but you have to recognize the things that really are important and do matter.

570
00:31:36.990 --> 00:31:41.040
And those you do have to reflect in the system.
Yeah,
yeah.
Uh,

571
00:31:41.160 --> 00:31:45.900
do you have thoughts on exceptions versus extra status code or extra error code

572
00:31:45.901 --> 00:31:50.640
returning?
Boy,
that's a classic argument.
Exceptions versus returned values.

573
00:31:52.640 --> 00:31:54.180
Now there are times when each makes sense.

574
00:31:54.710 --> 00:31:59.010
I believe exceptions actually provide the most value when you throw them

575
00:31:59.030 --> 00:32:02.880
farthest,
if they're going a long way up the stack,

576
00:32:02.920 --> 00:32:06.240
that's where they provide the biggest benefit because you've made it unnecessary

577
00:32:06.241 --> 00:32:09.540
for a whole bunch of intermediate layers to deal with the situation.

578
00:32:09.541 --> 00:32:11.010
You can take it all the way back to the source and,

579
00:32:11.220 --> 00:32:12.240
and deal with it at the source.

580
00:32:12.690 --> 00:32:15.360
If you are catching exceptions and methods you call,

581
00:32:15.930 --> 00:32:19.410
you know there's not as much value for that compared to just getting a return

582
00:32:19.411 --> 00:32:21.420
value.
It's not,
it's not a whole lot different.

583
00:32:21.680 --> 00:32:23.390
And one of the problems with exceptions also they have,

584
00:32:23.520 --> 00:32:27.690
they all have clunky syntax and actually checking your return value is actually

585
00:32:27.691 --> 00:32:31.410
simpler syntactically than declaring an exception handler.
But,

586
00:32:31.440 --> 00:32:33.900
but you know a lot of times some of these exceptions you really will want them

587
00:32:33.901 --> 00:32:35.160
to propagate along ways.

588
00:32:35.161 --> 00:32:39.030
And so then even if the color is gonna gonna look at,

589
00:32:39.170 --> 00:32:43.180
you probably want to manifest it as an exception rather than return value and

590
00:32:43.200 --> 00:32:47.660
salt on crushing as a way of like avoiding good pricing.

591
00:32:47.661 --> 00:32:51.080
Good thoughts on crashing as a way.
Yes.
Yeah.
Yeah.

592
00:32:51.110 --> 00:32:55.040
Actually crashing is a fine thing to do in certain situations.
Like for example,

593
00:32:55.041 --> 00:32:58.790
in most programs I would argue you should not be trying to come out of memory

594
00:32:58.791 --> 00:32:59.624
exceptions.

595
00:32:59.780 --> 00:33:02.870
It's just hopelessly complicated to try and do that cause they're your depends

596
00:33:02.871 --> 00:33:06.250
so much on memory that for most applications if you want to have a memory of

597
00:33:06.251 --> 00:33:09.230
just crash,
I mean print the message and crash.
It almost never happens.

598
00:33:09.231 --> 00:33:13.580
Machines today have tons of memory anyhow.
I think,
Eh,
you know,
again,

599
00:33:14.370 --> 00:33:15.290
use with caution,

600
00:33:16.130 --> 00:33:18.680
but I think there's situations where just crashing as a fine thing,

601
00:33:18.740 --> 00:33:19.271
find a way to do it.

602
00:33:19.271 --> 00:33:22.700
It's that the alternative would create so much complexity that you probably

603
00:33:22.701 --> 00:33:25.100
wouldn't get it right in the first place and it doesn't go crashing anyway.

604
00:33:26.290 --> 00:33:28.700
<v 1>He,
John,
not this 17 cushions on the duty,</v>

605
00:33:28.701 --> 00:33:31.930
so I'll just ask the top ranked one so that we don't run out of time.

606
00:33:32.530 --> 00:33:36.940
The question is from [inaudible] and I'm in the life development is often under

607
00:33:36.950 --> 00:33:38.810
various constraints.
For example,
tight.

608
00:33:38.830 --> 00:33:41.950
Could you need to experiment and be flexible about design,

609
00:33:41.951 --> 00:33:44.730
lack of Mitchell tools,
library,
et cetera.
Uh,

610
00:33:44.830 --> 00:33:48.580
does your approach to software design philosophy change based on real world

611
00:33:48.581 --> 00:33:49.414
constraints?

612
00:33:49.890 --> 00:33:52.310
<v 2>Uh,
yes.
And actually that's a good leader.</v>

613
00:33:52.340 --> 00:33:53.650
Let me move on to the next part of the talk,

614
00:33:53.651 --> 00:33:56.430
which I'm going to talk about that and I think I want to keep moving to,

615
00:33:56.440 --> 00:33:58.470
cause we're,
we're starting to run a little tight on time.

616
00:34:00.280 --> 00:34:04.450
What about a couple of specific techniques or philosophies you can use,

617
00:34:04.610 --> 00:34:07.330
but I think one of the biggest obstacles to good design is mindset.

618
00:34:08.650 --> 00:34:11.200
Don't have the right mindset and you will just never produce a good design.

619
00:34:12.660 --> 00:34:17.230
I think there's two ways of approaching the program or design process,

620
00:34:17.231 --> 00:34:20.680
which I call it tactical and strategic.
Unfortunately,

621
00:34:20.890 --> 00:34:23.920
most people take the wrong approach,
which is the tactical approach,

622
00:34:25.470 --> 00:34:30.130
the tactical approach.
Your goal is to get something working,
you know,

623
00:34:30.131 --> 00:34:33.880
your next feature,
fixing a bug,
whatever,
but that's your goals.

624
00:34:33.900 --> 00:34:36.790
Get something working.
So you think,
how can that be wrong?

625
00:34:36.820 --> 00:34:39.430
That's isn't that the whole goal of building system?

626
00:34:39.431 --> 00:34:41.470
We want them to be working well.

627
00:34:41.471 --> 00:34:43.510
The problem with this approach is that when you do it,

628
00:34:43.511 --> 00:34:48.040
then you usually have the mindset that,
well,
I'll try and make it mostly clean,

629
00:34:48.041 --> 00:34:50.470
but if I have a little,
if I had to take a couple of,
you know,

630
00:34:50.471 --> 00:34:54.010
shortcuts are a little bit of clue just as long as I know to too many of them.

631
00:34:54.820 --> 00:34:57.770
If I get it working,
that's what really counts.
Uh,

632
00:34:58.060 --> 00:35:02.980
the problem with that is that those Kluge is build up really fast because not

633
00:35:02.981 --> 00:35:05.470
only are you doing it,
but everybody else on your team is doing it.

634
00:35:06.250 --> 00:35:07.930
And then after awhile you start seeing,
oh,

635
00:35:07.931 --> 00:35:10.270
I probably shouldn't have made that decision back there,

636
00:35:10.271 --> 00:35:13.450
but we've got our next deadline.
We've got to hit.
Uh,
you know,

637
00:35:13.451 --> 00:35:15.730
I'll try and find time after that,
that deadline.

638
00:35:15.730 --> 00:35:18.250
But then by the time the deadlines done,
you've introduced so many coaches,

639
00:35:18.251 --> 00:35:20.950
you realize that's going to take weeks to fix all of these and you don't have

640
00:35:20.951 --> 00:35:23.530
time for that.
And so it just never happens.

641
00:35:24.250 --> 00:35:28.630
So the result of this inevitably is the system turns to spaghetti really,

642
00:35:28.660 --> 00:35:31.000
really fast.
Uh,

643
00:35:31.210 --> 00:35:36.210
and the problem is that complexity isn't one mistake you make is not a single

644
00:35:37.440 --> 00:35:38.970
thing that makes us just some complicated,

645
00:35:39.240 --> 00:35:43.470
it's hundreds or thousands of mistakes made by many people over a period of
time.

646
00:35:44.220 --> 00:35:46.170
And so,
uh,
so that means,
first of all,

647
00:35:46.171 --> 00:35:49.230
you don't notice it as it's happening because it's just a bit at a time.

648
00:35:49.530 --> 00:35:51.240
But then even worse once it's happened,

649
00:35:51.241 --> 00:35:54.090
it's almost impossible to fix because there's no one thing you can go back and

650
00:35:54.091 --> 00:35:54.930
fix to fix the problem.

651
00:35:54.931 --> 00:35:59.550
It's thousands of things and Tundras of places and so it's just so overwhelming

652
00:35:59.551 --> 00:36:03.360
and never get to it.
So by the way,
there's an extreme of the,

653
00:36:03.361 --> 00:36:06.930
the tactical programming person sort of personality type I call the tactical

654
00:36:06.931 --> 00:36:07.764
tornado.

655
00:36:08.340 --> 00:36:12.810
This is a person who turns out enormous amounts of pretty shotty code that kind

656
00:36:12.811 --> 00:36:17.811
of 80% works at a huge rate and leaves a wake of destruction behind them.

657
00:36:20.640 --> 00:36:24.060
And in many organizations,
these people are considered heroes.

658
00:36:24.120 --> 00:36:26.790
This is who management goes to when we need the new feature for tomorrow.

659
00:36:26.791 --> 00:36:31.080
And they'll have a feature tomorrow that works for most of the day tomorrow.

660
00:36:31.081 --> 00:36:35.400
Anyhow,
in fact,
actually I want to give this talk.
Somebody said,
oh,

661
00:36:35.401 --> 00:36:37.320
is that what you mean by the 10 x programmers?

662
00:36:41.400 --> 00:36:43.100
No.
No.

663
00:36:43.740 --> 00:36:47.580
How many of you feel like you've been in the presence of one or more tactical

664
00:36:47.581 --> 00:36:51.300
tornadoes over your career?
Yeah,
every organization has them.

665
00:36:51.301 --> 00:36:55.290
I'm sure they're here at Google and unfortunately one of the things I hope to do

666
00:36:55.291 --> 00:36:59.130
is to provide a name for this so we can start calling them out and maybe educate

667
00:36:59.131 --> 00:37:01.980
management about how many of you feel like your management actually rewards

668
00:37:01.981 --> 00:37:05.220
tactical tornadoes.
Yeah,
that's even worse unfortunately.

669
00:37:07.530 --> 00:37:11.220
So,
you know,
the tactical approach is really,
really easy to slide into.

670
00:37:11.490 --> 00:37:14.820
Very hard not to do that.
But so the first thing you have to realize,

671
00:37:14.821 --> 00:37:17.640
if you want to do great design,
you have to realize working code is not enough.

672
00:37:17.850 --> 00:37:22.770
That can't be the only goal.
It's so table stakes.

673
00:37:22.771 --> 00:37:25.980
Of course things have to work,
but that shouldn't be the real goal.

674
00:37:28.210 --> 00:37:30.720
It's that you should take what I call a strategic approach,

675
00:37:31.860 --> 00:37:35.400
or the goal is a great design.
That's the most important thing.
Yes,

676
00:37:35.401 --> 00:37:37.380
it's got to work today.
But we have to have a great design.

677
00:37:37.950 --> 00:37:41.430
Why do you want a great design?
It's so that we can develop faster in the future.

678
00:37:42.030 --> 00:37:44.100
So it's really,
it's really all about investing.

679
00:37:44.460 --> 00:37:47.820
Invest in good design today because most of the code we develop is going to be

680
00:37:47.821 --> 00:37:50.820
in the future.
You know,
that's,
and so if we mess things up today,

681
00:37:51.210 --> 00:37:52.950
we're slowing ourselves down for the future.

682
00:37:53.580 --> 00:37:54.970
So you have to think about complexity.

683
00:37:55.010 --> 00:37:59.040
Try and find ways to drive complexity out of the system.
And fundamentally,

684
00:37:59.070 --> 00:38:00.060
this is the hard part.

685
00:38:00.090 --> 00:38:03.270
You have to sweat the small stuff and you sort of have to have a zero tolerance

686
00:38:03.271 --> 00:38:07.530
approach.
Don't let those little bits of lint creep in because if they do,

687
00:38:07.920 --> 00:38:11.730
then you're going to slide back into a tactical mode again.
You know?

688
00:38:11.731 --> 00:38:16.050
So if you program strategically,
you're going to go slower at first,

689
00:38:16.440 --> 00:38:19.140
but presumably in the end and you'll end up going faster.

690
00:38:19.170 --> 00:38:20.940
I mean even with a strategic approach,
here's,

691
00:38:20.960 --> 00:38:23.760
development was still slow down over time.
Cause complexity,

692
00:38:24.000 --> 00:38:26.130
complexity is inevitable.
We can't prevent it.

693
00:38:26.131 --> 00:38:29.280
We can only kind of slow growth as much as we can.

694
00:38:30.240 --> 00:38:34.590
But eventually you'll end up going to be faster.
So the,

695
00:38:34.600 --> 00:38:36.640
the issue is you have to invest.

696
00:38:37.060 --> 00:38:40.480
If you're not willing to take a little bit of extra time today at least a little

697
00:38:40.481 --> 00:38:45.220
bit,
you can't do good design,
but in my opinion,
it all pays back.

698
00:38:45.460 --> 00:38:46.960
You always get your investment back.

699
00:38:47.620 --> 00:38:50.710
Now the challenge is what are the parameters of these curves?

700
00:38:50.711 --> 00:38:54.660
Like how much slower or do I have to go initially?
You know,

701
00:38:54.850 --> 00:38:57.160
when do I get to the point where the slopes are the same?

702
00:38:57.160 --> 00:39:00.370
So I mean at least now running as fast as I was tactically,

703
00:39:00.870 --> 00:39:01.930
when do I actually catch up?

704
00:39:01.931 --> 00:39:05.020
So I'd actually have a net gain and then how much faster I go with the end.

705
00:39:06.430 --> 00:39:07.600
This unfortunately,

706
00:39:07.660 --> 00:39:10.930
I don't know of any quantitative answers to any of those questions.
You know,

707
00:39:11.050 --> 00:39:15.490
I have opinions like my opinion is that the crossover period is somewhere in the

708
00:39:15.491 --> 00:39:16.720
six to 12 month range,

709
00:39:16.930 --> 00:39:19.140
roughly how long it takes you to forget about why you wrote that,

710
00:39:19.190 --> 00:39:23.110
that last chunk of code.
But I don't have any data to back that up unfortunately.

711
00:39:23.950 --> 00:39:25.630
So that's the challenge because people,
you know,

712
00:39:25.631 --> 00:39:30.580
people can see the cost today but they can't really estimate what the bit,

713
00:39:30.581 --> 00:39:33.280
when the benefit is going to come or how long in the future it's going to be.

714
00:39:33.460 --> 00:39:36.490
And so it's really easy just to optimize for this park down here.

715
00:39:40.930 --> 00:39:41.601
<v 7>Yeah.
Just quick question.</v>

716
00:39:41.601 --> 00:39:45.260
If you thought of the analyzing open source development and seeing whether or

717
00:39:45.261 --> 00:39:49.990
not you can observe this,
I mean it would of course some judgment calls.

718
00:39:50.110 --> 00:39:51.500
<v 2>Gotcha.
How are you doing?
You can look at,</v>

719
00:39:51.900 --> 00:39:54.270
look at the rate of commits or the new lines added.

720
00:39:54.271 --> 00:39:56.340
But the problem is you don't know how much effort went into those.

721
00:39:56.610 --> 00:39:56.910
<v 7>Yeah.</v>

722
00:39:56.910 --> 00:40:00.390
So I think like when you storage device comes out and people were writing new

723
00:40:00.391 --> 00:40:01.530
file systems or something,
you know,

724
00:40:01.531 --> 00:40:04.570
you could look at this across different classes and see how things happened.

725
00:40:05.870 --> 00:40:08.120
<v 2>That's a thought.
I,
I,
it's hard.</v>

726
00:40:09.260 --> 00:40:11.710
So the question is how much do you invest?
Actually,
let me,
uh,

727
00:40:11.780 --> 00:40:12.410
let me charge for a,

728
00:40:12.410 --> 00:40:15.050
for a couple of more slides cause we're starting to run a little tight on time.

729
00:40:16.070 --> 00:40:18.440
So how much,
what's the right amount to invest in?
You know,

730
00:40:18.441 --> 00:40:22.460
if you look at most startups,
honestly,
they're mostly completely 100% tactical.

731
00:40:22.730 --> 00:40:25.240
They feel this tremendous pressure to get the products out.
Yo,

732
00:40:25.280 --> 00:40:27.470
our financing is going to run out in six months,

733
00:40:27.860 --> 00:40:30.320
whatever evil we put in with our,
you know,

734
00:40:30.321 --> 00:40:33.050
when we become famous and wealthy and do our IPO will be able to hire more

735
00:40:33.051 --> 00:40:36.350
engineers to clean up this mess.
And so you know,

736
00:40:36.351 --> 00:40:40.550
they end up with is horrible spaghetti code basis.
And unfortunately of course,

737
00:40:40.551 --> 00:40:43.910
once you get that it's,
it's pretty much impossible to clean it up.

738
00:40:43.911 --> 00:40:44.930
I've never heard of anybody.

739
00:40:45.230 --> 00:40:47.510
Maybe if you could go back and completely rewrite and you could do it,

740
00:40:47.880 --> 00:40:51.860
maybe there have been examples of that,
but almost never happens.
So to me,
uh,

741
00:40:51.861 --> 00:40:53.450
Facebook is the poster child for this.

742
00:40:54.050 --> 00:40:57.350
They even built it into their company model,
move quickly and to break things.

743
00:40:57.410 --> 00:41:02.240
And they did both of those.
So in a sense,
developers kind of like this,

744
00:41:02.241 --> 00:41:04.940
a fresh college hires could come in,
they're super empowered,

745
00:41:04.941 --> 00:41:08.600
they push their first committed that are changing the website.
In one week.

746
00:41:08.900 --> 00:41:12.960
That first week on the job feels like in a really empowering for them,
but their,

747
00:41:12.970 --> 00:41:16.310
their code base was just a notorious mess.
One summer,

748
00:41:16.311 --> 00:41:18.820
a couple of my graduate students went there for internships that came back and

749
00:41:18.821 --> 00:41:20.900
they just couldn't believe what they'd seen.

750
00:41:21.560 --> 00:41:25.550
And this was interesting because my students had been whining for the whole

751
00:41:25.551 --> 00:41:29.690
previous year about why do we have to write unit tests and write documentation

752
00:41:29.691 --> 00:41:32.950
and Linux doesn't have any unit tests and Lily's doesn't have any comments.

753
00:41:33.110 --> 00:41:33.943
Do we have to do this?

754
00:41:34.580 --> 00:41:37.580
I never heard that again after they came back from Facebook.

755
00:41:40.400 --> 00:41:43.220
So Facebook has eventually realize this and this,

756
00:41:43.221 --> 00:41:47.660
or they changed their motto to move quickly with solid infrastructure.
It's like,

757
00:41:48.140 --> 00:41:50.540
no,
no,
I meant to say what?
It's not wood.

758
00:41:54.980 --> 00:41:58.730
So have you been able to fix it?
I don't know.
Now people hear this.
They say,
well,

759
00:41:58.820 --> 00:42:01.520
yeah,
but Mark Zuckerberg is the fourth wealthiest person on the planet.

760
00:42:01.521 --> 00:42:04.960
How can this be a bad?
How can this be a bad approach?
And Chris,

761
00:42:04.961 --> 00:42:07.790
the answer you can,
you know you can be successful with crappy code.

762
00:42:07.820 --> 00:42:11.300
You can be tactical and build companies that succeed.
Facebook has done it,

763
00:42:11.840 --> 00:42:13.760
but I have two thoughts on this.

764
00:42:13.761 --> 00:42:16.520
One is you can also succeed with the other approach.

765
00:42:16.910 --> 00:42:19.760
And although I don't have a personal expense with either of these companies,

766
00:42:19.761 --> 00:42:24.410
my sense is that both Google and vmware took a much more stronger design culture

767
00:42:24.411 --> 00:42:27.050
approach,
at least particularly in the early years.
You know,

768
00:42:27.051 --> 00:42:31.160
2000 to 2010 those were the two companies known as silicon valleys.

769
00:42:31.340 --> 00:42:33.560
This is where the really great software developers go.

770
00:42:33.561 --> 00:42:36.230
They really care about design and they do really good coding.

771
00:42:37.070 --> 00:42:40.580
And the reason this matters is that if you have that culture,

772
00:42:40.581 --> 00:42:43.280
I think you're in a much better position to recruit the best programmers.

773
00:42:43.970 --> 00:42:45.890
And we know about this 10 x phenomenon.

774
00:42:46.090 --> 00:42:50.600
You know that the best way to get great products out fast is to get the best

775
00:42:50.601 --> 00:42:51.434
programmers.

776
00:42:51.920 --> 00:42:55.550
And so I think the strongest argument in favor of a good design culture is that

777
00:42:55.551 --> 00:42:59.150
it allows you to hire top people and that will give you an advantage.

778
00:42:59.870 --> 00:43:02.330
So you can do things the crappy way if you want,

779
00:43:02.331 --> 00:43:05.090
but that there's enough success stories to show that you can make this work.

780
00:43:05.120 --> 00:43:09.380
You can do the investment approach,
but okay,
but then again,
okay,

781
00:43:09.381 --> 00:43:13.280
but how much to invest?
I would say,
how much can you afford?

782
00:43:13.430 --> 00:43:14.480
And just ask yourself,

783
00:43:14.780 --> 00:43:19.100
what's the most we can afford at this stage in our lifetime to invest?

784
00:43:19.730 --> 00:43:23.810
I think in terms of maybe 10 or 20% something like that,

785
00:43:24.020 --> 00:43:28.040
I bet almost everybody you can afford to go 10% slower today realizing you're

786
00:43:28.041 --> 00:43:30.050
going to get it all back.
It's not a sunk cost.

787
00:43:30.051 --> 00:43:32.750
It's all coming back to you in some,
you know,

788
00:43:32.751 --> 00:43:34.970
six months to a few years are going to get it all back again.

789
00:43:35.360 --> 00:43:39.950
You can afford to do that and I think in terms of small steps,
not heroics,

790
00:43:39.951 --> 00:43:44.870
you know you can't spend six months and completely designed the whole system

791
00:43:44.871 --> 00:43:49.070
from,
you know,
from first principles before you write any code that doesn't work.

792
00:43:49.110 --> 00:43:51.000
We know one of the problems with softwares,

793
00:43:51.020 --> 00:43:53.300
we can't visualize the way our systems are going to turn out.

794
00:43:53.420 --> 00:43:55.190
You have to use as somewhat interruptive approach.

795
00:43:55.670 --> 00:43:58.640
So take I say think of it in terms of small steps.

796
00:43:58.940 --> 00:44:00.140
So when you're building new modules,

797
00:44:00.141 --> 00:44:02.360
take a little bit of time to design the interface,

798
00:44:02.361 --> 00:44:04.550
try and come up with deep classes,
right?

799
00:44:04.551 --> 00:44:06.950
The documentation as you're going unit tests of course.

800
00:44:07.790 --> 00:44:09.350
And then whenever you make changes,

801
00:44:09.500 --> 00:44:12.020
you have to realize you can't get it right the first time.

802
00:44:12.380 --> 00:44:14.420
It's one of the rules of software.
You just,
you just can't.

803
00:44:14.421 --> 00:44:17.600
So assume every time you're in a system,
you're going to have to be improving.

804
00:44:17.601 --> 00:44:20.210
Things always look for something you can make better.

805
00:44:20.870 --> 00:44:25.070
And one reason for this is you're probably making something worse when you go in

806
00:44:25.071 --> 00:44:27.140
also.
So even if you just want to break even,

807
00:44:27.560 --> 00:44:30.590
you got to find something to improve.
So just think of it,

808
00:44:30.591 --> 00:44:32.390
I'm just trying to at least break even.
So

809
00:44:32.710 --> 00:44:33.543
<v 4>yeah.</v>

810
00:44:34.350 --> 00:44:37.260
<v 2>So,
uh,
this was against the normal philosophy.</v>

811
00:44:37.261 --> 00:44:40.050
I think oftentimes when people are changing existing code,
they go for the,

812
00:44:40.290 --> 00:44:43.710
what's the smallest number of lines of code I can possibly change to do this?

813
00:44:44.100 --> 00:44:47.370
I think sometimes just because they're afraid,
I don't understand this.

814
00:44:47.610 --> 00:44:49.850
I'm going to break something so I'll make the fewest lines have changed.

815
00:44:49.851 --> 00:44:52.770
So I'll just kind of directly access the global variable and other file rather

816
00:44:52.771 --> 00:44:56.070
than trying to find a clean interface for it.
So don't do that.

817
00:44:56.190 --> 00:44:58.650
Try and find a clean way of doing things.

818
00:44:59.220 --> 00:45:01.590
And ideally in the best case,

819
00:45:01.920 --> 00:45:05.850
you'd like to end up where you would have ended up if you had built the whole

820
00:45:05.851 --> 00:45:08.460
system from the scratch,
from scratch,
knowing what you know today,

821
00:45:08.760 --> 00:45:09.450
that's what you're like,

822
00:45:09.450 --> 00:45:12.120
is this the way we would have done it if we'd built it from scratch?

823
00:45:12.750 --> 00:45:16.170
That's the ideal.
Now you know you can't always do that.

824
00:45:16.171 --> 00:45:20.220
Sometimes that would be a refactoring is way beyond the scale of what you can
do.

825
00:45:20.670 --> 00:45:24.690
So again,
I,
I would just say ask yourself at any,
at any given point in time,

826
00:45:24.780 --> 00:45:28.920
am I doing the most I possibly can.
Don't just give in and say,
hey,

827
00:45:28.921 --> 00:45:30.720
the boss says we've got to get a release out tomorrow.

828
00:45:30.721 --> 00:45:32.970
So I'm just going to hack this thing in and make the boss happy.
Ask,

829
00:45:33.030 --> 00:45:34.800
is this the best I could possibly do?

830
00:45:36.250 --> 00:45:38.020
<v 5>John,
you didn't touch on Leering,</v>

831
00:45:38.410 --> 00:45:41.950
which is often considered very good in software engineering,

832
00:45:41.951 --> 00:45:45.850
but it also has a challenge of performance of the code.

833
00:45:46.210 --> 00:45:47.140
When it executes.

834
00:45:47.470 --> 00:45:51.970
Often the functionalities are replicated in multiple layers and it's not clear

835
00:45:51.971 --> 00:45:54.430
how to distill that without mucking up the coat.

836
00:45:56.080 --> 00:45:59.040
<v 2>Uh,
so what's your question now?
Our layers.
Good.</v>

837
00:45:59.330 --> 00:45:59.571
<v 5>Yeah.</v>

838
00:45:59.571 --> 00:46:04.571
So how do you deal with less demand for abstraction layers and the demand for

839
00:46:04.641 --> 00:46:05.780
performance?
Both contracts,

840
00:46:05.830 --> 00:46:08.950
<v 2>but like we need layers for managing complexity.
So in that sense they're good.</v>

841
00:46:08.980 --> 00:46:11.890
They do have problems for performance.
I think people do too many layers.

842
00:46:12.490 --> 00:46:14.170
I think so.
Uh,

843
00:46:14.320 --> 00:46:17.680
I think that's a common mistake is to throw in lots of skinny layers again,

844
00:46:17.681 --> 00:46:21.340
rather than having a smaller number of meteor layers.
That's one problem.

845
00:46:21.341 --> 00:46:24.220
The other thing is that fourth cases where performance matters.

846
00:46:24.640 --> 00:46:28.210
If you think a little bit about what your key performance metrics are,

847
00:46:28.450 --> 00:46:33.040
I believe you can often define your layers in a way that allows you to achieve

848
00:46:33.041 --> 00:46:34.660
very high performance even with layering.

849
00:46:35.380 --> 00:46:37.330
But you have to be thinking a little bit about the,

850
00:46:37.480 --> 00:46:40.630
at least the overall kind of gross level performance metrics while you're doing

851
00:46:40.631 --> 00:46:45.430
your system design.
Okay.
So anyhow,
I think,

852
00:46:45.490 --> 00:46:48.280
I think this investment thing is the biggest challenge particularly because a

853
00:46:48.281 --> 00:46:51.310
lot of managers I think don't really get it and they're pushing for the next

854
00:46:51.311 --> 00:46:51.671
feature,

855
00:46:51.671 --> 00:46:56.230
the next release and I don't know how to combat that except except to half the

856
00:46:56.231 --> 00:46:59.140
people that everybody recognizes that the great engineers in the company go to

857
00:46:59.141 --> 00:47:01.200
management and try and get management buy in.

858
00:47:01.210 --> 00:47:03.370
And I think it'd be great if companies could have sort of explicit,

859
00:47:03.610 --> 00:47:05.140
this is in our engineering philosophy,

860
00:47:05.320 --> 00:47:09.400
we will invest that sort of 10% we assume it roughly on average 10% of our

861
00:47:09.401 --> 00:47:11.890
resources are going towards making designs better,

862
00:47:12.040 --> 00:47:14.410
not just cranking out next features that,
John,

863
00:47:15.750 --> 00:47:17.300
<v 5>I have looked at this for 20 years now,</v>

864
00:47:17.301 --> 00:47:21.050
but the quantitative analyses that you're describing where the domain of the

865
00:47:21.051 --> 00:47:23.690
software engineering community for awhile,

866
00:47:23.840 --> 00:47:26.960
I wondering if you sort of poked into that space to see if they have a

867
00:47:26.961 --> 00:47:30.100
experimentation numbers,
analyses that might be useful

868
00:47:30.100 --> 00:47:31.420
<v 2>or have they just dropped off the map?</v>

869
00:47:31.880 --> 00:47:35.230
I haven't looked very carefully at partly because I'm sort of skeptical that it

870
00:47:35.231 --> 00:47:37.060
is possible to measure it in a meaningful way.
So I haven't,

871
00:47:37.510 --> 00:47:40.240
but I would love to see numbers if there were some more believable,

872
00:47:40.241 --> 00:47:43.760
but I haven't looked enough to know.
Okay.
So,

873
00:47:43.761 --> 00:47:45.820
and just have a couple more slides and open up for questions.

874
00:47:46.390 --> 00:47:50.770
So is the course working?
Uh,
you know,
it's hard to tell for sure.
I mean,

875
00:47:50.771 --> 00:47:52.630
you can't become a great program in one quarter.

876
00:47:52.900 --> 00:47:56.170
It'll take still lots of experience for these people will have to come back and

877
00:47:56.171 --> 00:47:58.030
ask them once they've been out in industry awhile.

878
00:47:58.390 --> 00:48:00.820
This is just the sort of the first step in the process I think.

879
00:48:01.270 --> 00:48:03.970
But the class has a really fun energy to it.
Really Fun.

880
00:48:04.180 --> 00:48:08.350
Then the students start off in the first round of code reviews and they're very

881
00:48:08.351 --> 00:48:09.041
tentative,

882
00:48:09.041 --> 00:48:11.560
kind of afraid to criticize each other and not really sure what they should be

883
00:48:11.561 --> 00:48:14.620
saying.
Uh,
so the,
the first rounds kind of tentative,

884
00:48:14.740 --> 00:48:19.740
then they meet with me and they get unloaded on and then they started,
oh,
okay,

885
00:48:19.810 --> 00:48:23.320
I can do that too.
And so about the halfway through the second code of your,

886
00:48:23.321 --> 00:48:26.560
typically the tone of discussions changes where students are now being more

887
00:48:26.561 --> 00:48:27.550
critical of each other.

888
00:48:27.760 --> 00:48:30.520
Where these interesting arguments in class about whether one approach is more

889
00:48:30.521 --> 00:48:32.110
complicated than another.

890
00:48:32.440 --> 00:48:35.530
And it's really clear by the end of the quarter that the students are thinking

891
00:48:35.531 --> 00:48:38.050
about programming in a very different way than they thought about it before.

892
00:48:38.051 --> 00:48:41.860
So that's,
I think that's really encouraging.
I will have to say though,

893
00:48:41.920 --> 00:48:44.140
even if the students don't become better designers,

894
00:48:44.141 --> 00:48:47.380
actually I'm becoming a better designer.
I'm teaching the class.

895
00:48:47.440 --> 00:48:49.410
It's really interesting for me.
You know,

896
00:48:49.411 --> 00:48:52.420
you might think it's tedious reading 20,000 lines of code in a week,

897
00:48:52.421 --> 00:48:56.530
three times over a quarter and it does take some time.

898
00:48:56.680 --> 00:49:00.220
But actually I learned a lot from that because the students were all doing the

899
00:49:00.221 --> 00:49:01.430
same thing and the same language.

900
00:49:01.431 --> 00:49:04.810
And so I can see different approaches and I can see kind of common mistakes that

901
00:49:04.811 --> 00:49:05.644
they make.

902
00:49:05.710 --> 00:49:09.550
And actually what's ended up happening is I've changed my view about a couple of

903
00:49:09.551 --> 00:49:12.250
design issues as a,
as a result of teaching the course.

904
00:49:12.460 --> 00:49:16.890
And in particular the ones that bottom of the slide was I realized that uh,

905
00:49:17.260 --> 00:49:21.040
making classes just slightly general purpose,

906
00:49:21.520 --> 00:49:23.470
even though you're only going to use them in one place,

907
00:49:24.040 --> 00:49:26.440
actually mix them amazingly simpler and deeper.

908
00:49:26.830 --> 00:49:30.190
Hadn't realized that until I saw some student projects sex the second time I was

909
00:49:30.191 --> 00:49:31.024
teaching the course.

910
00:49:31.180 --> 00:49:34.870
So it's been really interesting for me to to see this and I feel like I'm

911
00:49:34.871 --> 00:49:38.140
learning more about the process of software design interest in getting better

912
00:49:38.141 --> 00:49:42.460
ideas for how to,
how to teach it as I go.
Then as I've,

913
00:49:42.520 --> 00:49:44.500
as I've talked to people about the course,
people kept saying,
well,

914
00:49:44.501 --> 00:49:48.070
you should write a book on this,
and I was on sabbatical last year,
so I decided,

915
00:49:48.130 --> 00:49:50.230
okay,
I will do that.
So I have written this book.

916
00:49:50.231 --> 00:49:53.710
It's they're relatively small book 170 pages.
Again,

917
00:49:53.711 --> 00:49:57.820
still fairly philosophical in nature more than prescriptive.

918
00:49:58.270 --> 00:50:01.840
So the hope is that I can reach more people because I can only teach 20 people

919
00:50:01.841 --> 00:50:02.860
here in the class,

920
00:50:03.160 --> 00:50:07.270
can't do more than that and ideally I'm hoping the book will kind of be a

921
00:50:07.271 --> 00:50:09.760
lightning rod that maybe we can kickstart a discussion.

922
00:50:09.780 --> 00:50:13.270
I hope people write to me and disagree with things in the book or suggest other

923
00:50:13.271 --> 00:50:15.490
design ideas or provide better examples.

924
00:50:16.380 --> 00:50:19.570
I'm also trying to define terms that people can use.

925
00:50:19.810 --> 00:50:24.010
One of the things I hope maybe the book can do is people can use that in design

926
00:50:24.011 --> 00:50:28.620
reviews,
have ideas and ways of talking about design and design reviews.
Actually,

927
00:50:28.830 --> 00:50:32.020
I have a question for you.
Uh,
how many people who do design reviews,

928
00:50:32.030 --> 00:50:35.270
I assume almost everybody.
Yeah.
And how many of you in your design reviews,

929
00:50:35.300 --> 00:50:40.300
it's common for you to discuss design issues as opposed to coding style and

930
00:50:40.461 --> 00:50:44.540
bugs?
How many of the commonly talk about design things?
Good.
Great.

931
00:50:44.870 --> 00:50:47.450
I'd like to see more of that.
So I didn't have,

932
00:50:47.451 --> 00:50:49.820
the book's been out for a couple of months.
Uh,
if you read it,

933
00:50:49.830 --> 00:50:52.100
have thoughts or comments,
I'd love to get your input on it.

934
00:50:52.550 --> 00:50:54.590
My view is this is just a first stab.

935
00:50:54.890 --> 00:50:57.620
If this actually ends up being a useful book,
it'll probably be,

936
00:50:57.710 --> 00:50:59.780
it's kind of like software,
you know,
about version three,
you know,

937
00:50:59.781 --> 00:51:00.950
we're really hits its stride.

938
00:51:01.160 --> 00:51:04.790
I'll need to get feedback and revise and fix things that are wrong and new
ideas.

939
00:51:06.650 --> 00:51:10.400
So just to conclude,
I really believe we can teach sophomore design.
I really,

940
00:51:10.460 --> 00:51:11.810
I really believe we can.
Uh,

941
00:51:12.070 --> 00:51:15.190
my current approach unfortunately is woefully non-scalable.

942
00:51:15.230 --> 00:51:17.770
I haven't figured that out.
We really need somebody with a lot of experience.

943
00:51:17.790 --> 00:51:19.550
I think reading the,
the students code,

944
00:51:20.660 --> 00:51:23.240
I feel like some principals are emerging,
you know,

945
00:51:23.241 --> 00:51:26.120
if you read the book and agree or disagree with me,
I'd be curious to hear your,

946
00:51:26.320 --> 00:51:28.100
your take on that one.

947
00:51:28.160 --> 00:51:32.120
I hope to do in the future is just to somehow leverage this out into the

948
00:51:32.121 --> 00:51:32.451
community.

949
00:51:32.451 --> 00:51:36.140
I'd love to see just a greater sense of design awareness in the software

950
00:51:36.141 --> 00:51:38.240
community as a whole.
Can we have the discussion?

951
00:51:38.270 --> 00:51:39.980
Can we make that an important part of our community?

952
00:51:40.160 --> 00:51:43.430
It's just sad that we don't really even have the discussion today.

953
00:51:43.970 --> 00:51:46.760
So I created a mailing list for discussion topics about the book.

954
00:51:46.820 --> 00:51:48.320
Hasn't been much traffic on it so far,

955
00:51:48.321 --> 00:51:52.130
but I hope there will be more in the future and I've got to hope to take ideas

956
00:51:52.131 --> 00:51:55.840
from people and and make the book better and better in the class better over

957
00:51:55.850 --> 00:51:58.640
time in the long,
the long term goals be great.

958
00:51:58.641 --> 00:52:02.780
If five or 10 years from now we actually have a relatively robust set of

959
00:52:02.781 --> 00:52:06.020
principles that most developers agree a good for software design.

960
00:52:07.100 --> 00:52:09.470
So thanks for your attention and I'd be happy to take more questions.

961
00:52:14.400 --> 00:52:15.233
<v 0>Yep.</v>

962
00:52:15.400 --> 00:52:18.320
<v 6>Let me get a few questions from the dirty out here.
Okay.</v>

963
00:52:20.490 --> 00:52:21.300
<v 2>Okay.</v>

964
00:52:21.300 --> 00:52:24.520
<v 6>Doula testing considerations like unit testing or mocks,</v>

965
00:52:24.680 --> 00:52:26.670
influence interfaces and abstractions,

966
00:52:27.860 --> 00:52:30.740
<v 2>testing considerations.
Uh,
I'm a huge fan of a plumbing unit.</v>

967
00:52:30.741 --> 00:52:32.090
Tests are crucially important.

968
00:52:32.510 --> 00:52:34.850
I debated whether to try and teach them in the class.

969
00:52:34.851 --> 00:52:38.390
Actually I did a little bit at one time in the class,
but it was just,

970
00:52:38.420 --> 00:52:40.130
it was too much of a distraction for the class.

971
00:52:40.131 --> 00:52:42.830
We only have 10 weeks and so I finally decided I needed for the class.

972
00:52:42.831 --> 00:52:46.280
I just got to focus on design.
So I don't do unit testing in the class,
but,

973
00:52:46.520 --> 00:52:49.300
but I'm a complete advocate of unit tests.
I can't,

974
00:52:49.600 --> 00:52:51.320
can't imagine doing software without yelling at us.

975
00:52:52.280 --> 00:52:56.150
<v 6>So it was uh,
I was,
I was intrigued by your,
uh,</v>

976
00:52:56.300 --> 00:52:58.840
in the first part of the discussion when you said,
uh,

977
00:52:59.000 --> 00:53:03.200
in the iterative process you actually dropped,
um,

978
00:53:03.410 --> 00:53:08.150
have you initially had students build on other,
other students code?

979
00:53:08.690 --> 00:53:09.800
To me that's a very,

980
00:53:09.801 --> 00:53:14.540
very [inaudible] problem and I'm just surprised that you,
I mean,

981
00:53:14.541 --> 00:53:15.530
I wish you would teach that.

982
00:53:16.940 --> 00:53:20.140
<v 2>I agree with you.
In a perfect world,
that would be one of the things we do.</v>

983
00:53:20.190 --> 00:53:24.130
And the problem is we've got 10 weeks,
how do I use that 10 weeks?

984
00:53:24.131 --> 00:53:28.680
And I decided I want to try and do the most I can design.
And so I just,

985
00:53:28.681 --> 00:53:30.000
I have to sacrifice other things.

986
00:53:30.030 --> 00:53:33.210
It's the same reason why unit tests and got thrown out because I felt like it

987
00:53:33.211 --> 00:53:36.420
was better for them to be thinking about more design issues than then unit

988
00:53:36.421 --> 00:53:38.940
testing issues.
But I agree with your thoughts completely.

989
00:53:40.800 --> 00:53:44.730
Do you have tas for the course?
Do we have tas?
Yeah,
me.

990
00:53:46.080 --> 00:53:47.520
Not right now because I,

991
00:53:47.560 --> 00:53:52.080
I've just worried that the tas would not be able to give a high enough level of

992
00:53:52.081 --> 00:53:52.830
feedback.

993
00:53:52.830 --> 00:53:56.970
I've started wondering if maybe students who have taken the course previously

994
00:53:56.971 --> 00:53:58.350
could ta,
uh,

995
00:53:58.370 --> 00:54:02.130
I made so far actually the demand has not been more than my capacity and so I've

996
00:54:02.131 --> 00:54:04.770
been able to,
to keep it small.
If the demand grows,

997
00:54:04.771 --> 00:54:06.900
I may try and experiment to see if,

998
00:54:07.440 --> 00:54:11.490
if previous course participants can ta.
But again,

999
00:54:12.510 --> 00:54:15.300
I worry and also for the first few offers,

1000
00:54:15.301 --> 00:54:18.180
I want it to read all the code myself too because I wanted to learn from it as

1001
00:54:18.181 --> 00:54:19.014
well.
So

1002
00:54:19.460 --> 00:54:22.220
<v 5>have you thought about using software engineers as tas?</v>

1003
00:54:23.630 --> 00:54:25.490
We read and write code every day.

1004
00:54:25.610 --> 00:54:28.040
<v 2>Uh,
I'm not opposed to it in principle,</v>

1005
00:54:28.041 --> 00:54:30.470
but I want to make sure students don't get mixed messages.

1006
00:54:31.100 --> 00:54:35.930
And so particularly because the idea is I'm teaching the course are not ideas

1007
00:54:35.960 --> 00:54:39.950
that are widely,
and that's not necessarily widely spread in the community.

1008
00:54:39.951 --> 00:54:42.230
Like the worst thing,
what happened is if a software engineer comes in and says,

1009
00:54:42.440 --> 00:54:44.900
no,
this method is longer than 20 lines,
you've got to break it up.

1010
00:54:47.720 --> 00:54:48.730
So if,

1011
00:54:48.790 --> 00:54:52.190
if I could find people that are sort of bought into the philosophy and maybe you

1012
00:54:52.191 --> 00:54:54.710
know,
if the book gets out there and more people buy,

1013
00:54:54.740 --> 00:54:55.700
maybe we could do more of that.

1014
00:54:57.090 --> 00:55:01.090
<v 5>Okay.
One question from the Dory,
the second highest rated one or threat,</v>

1015
00:55:01.120 --> 00:55:02.280
still a bad idea.

1016
00:55:07.300 --> 00:55:09.730
<v 2>No.
One of the interesting things when you,</v>

1017
00:55:09.970 --> 00:55:13.230
when the only form in which you publish something as a set of slides rather than

1018
00:55:13.240 --> 00:55:14.021
a paper,
which that was,

1019
00:55:14.021 --> 00:55:17.360
I was just an invited talk and just next conference a long time ago.
It's ease.

1020
00:55:17.410 --> 00:55:17.951
Interesting.

1021
00:55:17.951 --> 00:55:21.490
People can come back and interpret that at whole bunches of different ways over

1022
00:55:21.491 --> 00:55:22.210
the years.

1023
00:55:22.210 --> 00:55:26.170
So that was done in a very narrow context of the time where people were starting

1024
00:55:26.171 --> 00:55:29.080
to introduce threads for things that didn't even need three as they were doing

1025
00:55:29.081 --> 00:55:31.930
threading and on machines that didn't even have multiple processors on them.

1026
00:55:32.680 --> 00:55:35.890
And so that was sort of that talk was a reaction to that.

1027
00:55:37.000 --> 00:55:40.560
Threads are unavoidable for certain things.
You just have to use them but,

1028
00:55:40.690 --> 00:55:42.460
but they're still,
you know,

1029
00:55:42.461 --> 00:55:45.910
there's sort of the next worst alternative where the worst all sort of made navy

1030
00:55:45.911 --> 00:55:48.910
in some cases not using threads incredibly hard to program.

1031
00:55:48.911 --> 00:55:52.610
So I'm still not a fan of threads but they're kind of a fact of life.
Yeah.

1032
00:55:52.750 --> 00:55:57.340
<v 5>I a question on the tico language.
I think the language is uh,</v>

1033
00:55:57.900 --> 00:55:58.733
uh,

1034
00:55:58.940 --> 00:56:03.940
a very simple points itself but eventually not gained like larger scope.

1035
00:56:05.641 --> 00:56:10.630
Who adoption.
I want to ask,
uh,
in you are,
because you are the language,

1036
00:56:10.730 --> 00:56:15.730
a humanitarian like is there like high level issues in the language of design?

1037
00:56:16.791 --> 00:56:21.150
You think you got it the wrong,
which makes it whatever

1038
00:56:21.170 --> 00:56:23.000
<v 2>happened to tickle?
I think it would be your question.</v>

1039
00:56:24.970 --> 00:56:29.470
I don't want to diverge too much on that.
I would say two things.
First off,

1040
00:56:29.650 --> 00:56:32.740
one of the things chicken wasn't best at was doing kind of simple interactive

1041
00:56:32.741 --> 00:56:34.360
gooeys with TK.

1042
00:56:34.900 --> 00:56:38.620
And when the web came along the web basically took that over and tickled did not

1043
00:56:38.621 --> 00:56:39.760
make the transition to the web.

1044
00:56:39.761 --> 00:56:42.050
So a lot of things people would have used tickle ticket for,

1045
00:56:42.100 --> 00:56:47.020
they ended up doing in the web.
Second thing is,
is it really the right language?

1046
00:56:47.260 --> 00:56:49.600
I'm not sure in retrospect that it's the right language.
I actually,

1047
00:56:49.601 --> 00:56:52.180
I built it for very different purpose.
I built that as a,

1048
00:56:52.450 --> 00:56:56.140
as more of a textual command language and you'd be typing commands to programs,

1049
00:56:56.141 --> 00:56:57.370
almost like a shell language.

1050
00:56:57.640 --> 00:56:59.800
And then I ended up getting used as a scripting language.

1051
00:57:00.430 --> 00:57:03.920
It has a bunch of interesting properties,
but,
uh,

1052
00:57:04.410 --> 00:57:05.620
I don't know if I were doing it again,

1053
00:57:05.621 --> 00:57:07.390
I'm not sure I would design the same language,

1054
00:57:07.480 --> 00:57:09.850
but I think that the biggest thing that happened is the kind of the web came

1055
00:57:09.851 --> 00:57:12.810
along and tickled,
did not effectively make the transition in the web.

1056
00:57:13.750 --> 00:57:14.500
<v 1>Okay.
So,
uh,</v>

1057
00:57:14.500 --> 00:57:18.050
this a lot of really interesting questions both on the Dorian in the room.
Uh,

1058
00:57:18.130 --> 00:57:21.160
in the interest of time I'm going to do two more dirty questions and two more in

1059
00:57:21.161 --> 00:57:22.870
the room and then now,
uh,
uh,

1060
00:57:23.040 --> 00:57:26.980
John is going to stay down and hopefully answer more questions as well.
Okay.
So,

1061
00:57:26.981 --> 00:57:29.570
uh,
any uh,
thoughts on the hiring process?

1062
00:57:29.571 --> 00:57:32.980
So based on what you've observed and the question has,

1063
00:57:33.220 --> 00:57:35.710
how would you change the hiring process,
which is,
so I've got them heavy.

1064
00:57:35.711 --> 00:57:37.870
Can you share your experience when you ran your company

1065
00:57:38.410 --> 00:57:40.780
<v 2>hiring process?
That's actually,
I'm not trying to release a software design,</v>

1066
00:57:40.781 --> 00:57:42.610
but I have a very strong opinion about hiring process,

1067
00:57:43.300 --> 00:57:48.070
which is you should hire for slope,
not y intercept I think.

1068
00:57:48.220 --> 00:57:49.480
I think people when they hire,

1069
00:57:49.660 --> 00:57:52.630
they do a pattern match of what this person has done.

1070
00:57:52.631 --> 00:57:55.990
Try and find the person who has exactly done the job we want to do.
Okay.

1071
00:57:56.200 --> 00:57:58.090
I think that's the wrong way to hire.
In general,

1072
00:57:58.091 --> 00:57:59.640
I think you want to hire the person who,

1073
00:57:59.700 --> 00:58:01.690
the fastest learner who has the fastest slope.

1074
00:58:02.110 --> 00:58:05.350
I don't particularly care whether they've done the job I want to do because a

1075
00:58:05.360 --> 00:58:09.070
particular startup,
when things change so rapidly,
uh,
you know,
things change.

1076
00:58:09.100 --> 00:58:12.890
So I look,
I look for people who are,
they're really smart,
fast learners,
rather.

1077
00:58:12.940 --> 00:58:15.670
Also,
by the way,
the person who has done this job five times before,

1078
00:58:15.850 --> 00:58:19.270
you sort of wonder,
well,
why haven't they moved on to the next job?

1079
00:58:19.600 --> 00:58:21.670
Oftentimes those people have kind of hit their plateau,

1080
00:58:21.820 --> 00:58:24.840
whereas the person with the rapid slope has the potential.
Yep.

1081
00:58:25.090 --> 00:58:28.180
<v 1>Last question from the duty.
What do you think about heightened slaw?</v>

1082
00:58:29.420 --> 00:58:31.360
<v 2>Sorry,
remind me of a hieros liars.</v>

1083
00:58:32.450 --> 00:58:36.960
<v 1>I googled it and it taste with a sufficient number of users of an API.</v>

1084
00:58:36.961 --> 00:58:39.300
It does not matter what you promise in the contract.

1085
00:58:39.570 --> 00:58:43.390
All observable behaviors of your system will be depended on by somebody.

1086
00:58:46.160 --> 00:58:51.150
<v 2>Uh,
I think there's truth to that.
But yeah,
over time what happens is that,</v>

1087
00:58:51.151 --> 00:58:52.420
so the application,
they sink,

1088
00:58:52.480 --> 00:58:55.990
they find every crevice and sink their roots under that they will discover.
So,

1089
00:58:56.110 --> 00:58:58.930
so unless you're very careful with your API Apis,
yeah.

1090
00:58:59.260 --> 00:59:03.380
I think that's probably true.
Sad,
but true.
Hi.

1091
00:59:03.640 --> 00:59:04.120
<v 1>Uh,</v>

1092
00:59:04.120 --> 00:59:08.110
have you observed any change in the simplicity of the complexity of the software

1093
00:59:08.111 --> 00:59:11.860
design based on the choice of languages and supporting ecosystem?

1094
00:59:12.270 --> 00:59:12.901
<v 2>Oh,
a good question.</v>

1095
00:59:12.901 --> 00:59:15.960
Are there some language that's somehow lend themselves to better design than

1096
00:59:15.961 --> 00:59:19.440
other languages?
No,
there probably are.

1097
00:59:19.890 --> 00:59:24.380
I think that's mostly secondary.
So second order thing but for example,

1098
00:59:24.381 --> 00:59:27.160
I'd rather it today I'd rather put them in c plus plus and c because I liked

1099
00:59:27.161 --> 00:59:30.470
them.
The object oriented features and c plus plus.
Now C plus plus is sort of a,

1100
00:59:30.690 --> 00:59:33.520
a big beast of a language with a horrible learning curve.
But,

1101
00:59:33.690 --> 00:59:35.630
but I appreciate the power of it.

1102
00:59:36.080 --> 00:59:39.380
But honestly I think the design principles are fairly universal.

1103
00:59:39.381 --> 00:59:40.850
You can use them in any language.

1104
00:59:41.150 --> 00:59:45.560
You know that that simple file system interface for Unix was done in c with no

1105
00:59:45.561 --> 00:59:47.750
object oriented stuff and that people that say,

1106
00:59:47.810 --> 00:59:50.750
oh no actually you notice it's actually object oriented cause it was a file

1107
00:59:50.751 --> 00:59:54.140
descriptor that gets passed around and the object oriented was really crucial to

1108
00:59:54.141 --> 00:59:57.710
that.
I say no,
they just found a really sweet interface.

1109
00:59:57.720 --> 01:00:02.720
So I haven't found one language that somehow is dramatically better than others

1110
01:00:02.811 --> 01:00:05.510
for design,
but I don't think people have opinions.

1111
01:00:05.511 --> 01:00:07.370
I'd be curious to hear other opinions about that.

1112
01:00:07.840 --> 01:00:11.220
<v 1>So,
uh,
back to hiring,
you mentioned we should hire on slope,</v>

1113
01:00:11.950 --> 01:00:14.620
northern y intercept and I radically agree.

1114
01:00:15.130 --> 01:00:20.080
How do I estimate this,
measure that,
right?
Especially,
no,
I do that.

1115
01:00:20.140 --> 01:00:21.550
You need at least two points,
right?

1116
01:00:21.551 --> 01:00:24.820
In an interview I get only one and I'm terrified of hiring more tactical

1117
01:00:24.821 --> 01:00:25.654
tornadoes.

1118
01:00:28.190 --> 01:00:32.090
<v 2>I don't know.
You know,
so I will tell you what correlated best for me,</v>

1119
01:00:32.091 --> 01:00:32.960
but it's sort of crazy.

1120
01:00:34.480 --> 01:00:37.970
I found in mice worth people worked out best were the ones where I just really

1121
01:00:37.971 --> 01:00:41.780
enjoyed my conversation with them during the interview.
And that's sort of weird.

1122
01:00:41.781 --> 01:00:45.380
I feel kind of funny saying that because that means somehow somebody sucked up

1123
01:00:45.381 --> 01:00:46.850
to me and I liked them and hire them.

1124
01:00:47.420 --> 01:00:51.860
I don't think that's it because I'm a pretty sensitive meter for suck upness

1125
01:00:52.190 --> 01:00:56.030
and,
and that really pisses me off.
So,
but,
and I don't,

1126
01:00:56.031 --> 01:00:58.460
and people have also pointed out,
but that's if you take that out too,

1127
01:00:58.461 --> 01:01:00.650
that's kind of a risk.
They were just hiring more people like yourself,

1128
01:01:00.651 --> 01:01:02.270
and so you're not going to do diversity very well.

1129
01:01:02.780 --> 01:01:06.620
So I have no idea what to make of that or whether it's even a good idea,

1130
01:01:06.621 --> 01:01:10.160
but that,
that's the one thing that seemed to correlate in my experience.

1131
01:01:11.630 --> 01:01:15.320
Okay.
So let's think a John once again,
no.

1132
01:01:15.630 --> 01:01:20.430
<v 0>[inaudible].</v>

