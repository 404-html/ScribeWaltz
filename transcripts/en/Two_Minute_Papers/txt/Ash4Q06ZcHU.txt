Speaker 1:          00:01          Okay. So when you come to the base rendering lecture, this is going to be unit four. We will have two parts in it. So one, the first part will be spatial acceleration structures. At the next part we be my bank. I will hold to the next three lectures. So this one and two more. And then um, Carter, it takes over again.

Speaker 2:          00:25          Okay.

Speaker 1:          00:25          So I'm spatial accelerations to act. Just so we are we, um, the rain during pipeline as it was shown in the first lecture. So we started with a three d scene, perform some kind of light simulation, generates a image out of it that's going to be these plate. So spatial acceleration structures are, um, central to the light simulation because they increase the efficiency of ratio. So Seo hurt last time, um, re based methodologies. So from geometric optics are mainly employed to enable photorealistic rendering. And in this work you have to shoot a lot of race. So usually in the order of medium 2 billion and if you can cut down the computational cost of this procedure, then you will gain significant speed up.

Speaker 2:          01:24          Oops.

Speaker 1:          01:26          So,

Speaker 2:          01:29          okay

Speaker 1:          01:29          though Samurais so generally the Monte Carlo method uses racial thing to sample, to integration of the rendering equation or shown the last time. So usually you have to compute the closest intersection with the scene. So this is equivalent to computing the local recipe litty. So how far does it rate, um, travel through the scene before it hits its first, um, object.

Speaker 2:          01:56          Okay.

Speaker 1:          01:56          And this is usually very expensive for large amount of scene objects because if you start with one raid and you want to check does it intersect any of my scene, say triangles, then if you have millions of triangles that each ray has to check all the mundane of triangles, which one's the first that they intersect. If you have millions of race, you'll see that this is a good, I think explosion and you will not converge in any reasonable time to a high quality image. So the naive approach would be just to, uh, determined the intersection with each object. So the object could now be, yeah, usually triangles can also be nonlinear surface patches or whatever you want to use.

Speaker 2:          02:44          Okay.

Speaker 1:          02:45          So if you just go through all the objects, one after the other and check which one is the closest.

Speaker 2:          02:53          Okay.

Speaker 1:          02:53          You have to go through all the op check to, it's a linear approach. So the complexities of an, a better approach would be to reorganize all the objects in your scene, say the triangles in some kind of spacial hierarchy so that I know that safe in the left half of this room is, are these triangles in the right half of these triangles. And then if I have a rate that I know that it only travels through one half of the room, that can immediately discard half of the triangles in my scene and don't need to intersect against them.

Speaker 1:          03:32          Yeah. So these are this approach. I mean it's um, a bit more sophisticated than that leads then to a sub linear complexity. Usually it gets close to lava rhythmic. So I mean, this isn't very old topic. So this popped up very soon when, um, ray tracing was used. So there are many methodologies that were looked into and two main techniques say are considered the state of the art. So one our Katie trees and the other are bounding volume hierarchies. So a kd tree subdivides the space itself. So, um, your scene is situated in a surrounding space, three dimensional and you then um, cut this space into pieces as can be seen in this example on the right hand side here, the space in which the opposite of checks reside is just the square and each object is just a point. And as you see with um, requested sub division of the space, you group objects together in a spatially local volumes.

Speaker 1:          05:00          So, and if you, the right side gives you the subdivision of the space itself and whether the object line those, but each split of the space can be seen as uh, um, as a construction of a binary tree. So you start off, have the root node, which is the whole space. Then you try to find some kind of good cart through the space so that approximately half of the objects are in one half and half of the opportunities and the other. So it doesn't make sense to start off with the whole volume and then separate a very small part from it because every ray has to start, it's traversal of the tree at the root node and then it has the decision, am I in the big volume or do I have to check the small volume too? If you have a lot of small volumes and this is inefficient again, so what do you want to do is to place or to get the criteria that you are not going to have to intersect a lot of triangles as far up in the two years possible.

Speaker 1:          06:13          So in this example, the first cart, the vertical cut through the whole space, um, subdivides the objects approximately in half so that half of the objects are left of the cart, half of the objects or right of the cut in three d this would be a cut plane through the volume, but it's the same procedure. And then you recursively sub divide the, um, the parts. So the two south volumes that you generated with the first cart. And, uh, also try again to have half of the objects, they are half of the chicken Steyer and you continue with this procedure until you will have one object per volume. I mean of course you can also terminate earlier. So if you are okay with having 100 triangles in each leaf node of the tree, then you have to check through all these 100 triangles if you entered the subspace. But the domain advantage you gain with this is that if you have some ray from this volume, then you can do very quick checks against the subspaces.

Speaker 1:          07:32          So you know that all the subspace here, uh, um, rectangles in a volume, they won't be boxes. And you can do very quick intersection tests against boxes. And if the, if you know that you are not going to intersect a box, which is one test, but there are thousands of triangles in this box, then you can immediately discard all these triangles for your real intersection test. So you only have to check the triangle intersections in those boxes that you checked beforehand that you intersect. And you can imagine that if you have huge areas that you don't intersect, you gain a lot of speed because you don't do unnecessary work. So Katie threes sub divide the space and then you have to, um, and then in the app volumes, the object slide and other approach, uh, bounding volume hierarchies there you grouped the objects together. So you take, you start with the triangles and then you'll say, I put clothes, triangles into groups, and then you can build up a tree structure. But this three structional, um, depends on the triangles. So the fundamental unit there is a triangle, not a sub space of your whole scene him.

Speaker 1:          09:12          So, um, now they have advantages and disadvantages. Otherwise you would only take the better one. So I'm Katie trees. They are usually faster for traversal. On the CPU. Here, I mean a multicore CPU, yes.

Speaker 2:          09:29          Okay.

Speaker 1:          09:30          But they have usually a larger amount of nodes and the health, the applicator references. Because if we go back to this example here, we have points. Okay. At point can, um, does not have a spatial extent, but if you imagine that you have triangles and your cart through the whole volume, then it could be that your caught through triangles and then you have two possibilities. I know you just add the triangle to both volumes. So you'll get the applicator for ansys. That means your triangle, this card is less efficient because you have to check against this triangle. If you're in the left or in the writer or you cut the triangle it safe. And Ed one half of the year, one half of the year. But I'm cutting a lot of scene called dent is computationally expensive. So this would then degrade the, um, the performance of the KD three generation. Um, bounding volume hierarchies are very popular for a gps and multicore architectures. So the scene for example. So they, um, got more attention in the, um, in recent research because it is, um, because most of the current work tried to implement, um, Soltis spacial hierarchy generation on cheap gps or um, other highly parallel architectures.

Speaker 1:          11:07          Um, they are also easier to update because imagine you have a moving object inside your scene. A key d three cuts the whole volume apart. And then if you have eh, objects moving from one side up volume to another, you would have to update the whole Katie tree because you don't really have a grasp on which level you have to edit it. Bounding volume, hierarchies on the other side, the group objects together. So the air, you can't just, you have the option of ignoring dynamic complication because say you have two objects and B that are close together, so generate your bounding volume hierarchy. So they are grouped together at some level of the tree and if they then move apart, the group inc is not influenced. The only thing that happens is that the bounding volume, the toll both groups gets larger and larger. So what happens is that you are a spacial hierarchy gets more inefficient because say a lot of empty spaces generated in between or checked in to be so Trey a race, the travel, exactly.

Speaker 1:          12:27          Through this gap between them, they would still have to check a and B. If you would then update your bounding volume hierarchy to acknowledge that they are spatially separated, then they would be kept at a, they would be put into different branches of the tree at a different level, but you don't have to do that. So in bounding volume hierarchies dynamic seems just degrade your performance but don't invalidate your whole, uh, hierarchy. Because in Katy trees, if you move from one sub volume to the other, you have to update this in the whole tree. And this could be quite complicated because I'm traversing the three, four Hallett and Emerick scene can be very closely. Um, I mean, you, and another advantage for founding volume hierarchist is that they are, um, that every object is only in one three leafs. I mean, this is naturally because it's constructed that way. But, uh, um, a negative point of them are that the nodes can spatially overlap. So if you put two triangles that are close by each other in two different nodes of the bonding volume hierarchy, then you still generate a box around them to do a fast intersection test. But if those triangles are, say, see right next to each other than a simple box, we'll have some overlap. So the abounding volume hierarchy can be inefficient.

Speaker 2:          14:07          Okay.

Speaker 1:          14:08          If you generate a lot of boxes with content in it that overlap to a large extent.